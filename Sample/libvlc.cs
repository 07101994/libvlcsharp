// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libvlc
{
    /// <summary>Logging messages level.</summary>
    /// <remarks>Future LibVLC versions may define new levels.</remarks>
    public enum LibvlcLogLevel
    {
        /// <summary>Debug message</summary>
        LIBVLC_DEBUG = 0,
        /// <summary>Important informational message</summary>
        LIBVLC_NOTICE = 2,
        /// <summary>Warning (potential error) message</summary>
        LIBVLC_WARNING = 3,
        /// <summary>Error message</summary>
        LIBVLC_ERROR = 4
    }

    /// <summary>This structure is opaque. It represents a libvlc instance</summary>
    /// <summary>
    /// <para>Event manager that belongs to a libvlc object, and from whom events can</para>
    /// <para>be received.</para>
    /// </summary>
    /// <summary>Type of a LibVLC event.</summary>
    /// <summary>Callback function notification</summary>
    /// <param name="p_event">the event triggering the callback</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcCallbackT(global::System.IntPtr p_event, global::System.IntPtr p_data);

    public unsafe partial class LibvlcInstanceT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcInstanceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcInstanceT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcInstanceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcInstanceT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcInstanceT __CreateInstance(global::libvlc.LibvlcInstanceT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcInstanceT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcInstanceT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcInstanceT.__Internal));
            *(global::libvlc.LibvlcInstanceT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcInstanceT(global::libvlc.LibvlcInstanceT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcInstanceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcEventManagerT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcEventManagerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcEventManagerT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcEventManagerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcEventManagerT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcEventManagerT __CreateInstance(global::libvlc.LibvlcEventManagerT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcEventManagerT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcEventManagerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcEventManagerT.__Internal));
            *(global::libvlc.LibvlcEventManagerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcEventManagerT(global::libvlc.LibvlcEventManagerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcEventManagerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class VlcLogT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.VlcLogT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.VlcLogT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.VlcLogT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.VlcLogT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.VlcLogT __CreateInstance(global::libvlc.VlcLogT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.VlcLogT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.VlcLogT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.VlcLogT.__Internal));
            *(global::libvlc.VlcLogT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VlcLogT(global::libvlc.VlcLogT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VlcLogT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Description of a module.</summary>
    public unsafe partial class LibvlcModuleDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_shortname;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_longname;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_help;

            [FieldOffset(32)]
            internal global::System.IntPtr p_next;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcModuleDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcModuleDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcModuleDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcModuleDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcModuleDescriptionT __CreateInstance(global::libvlc.LibvlcModuleDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcModuleDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcModuleDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcModuleDescriptionT.__Internal));
            *(global::libvlc.LibvlcModuleDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcModuleDescriptionT(global::libvlc.LibvlcModuleDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcModuleDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcModuleDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszShortname
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_shortname;
            }

            set
            {
                ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_shortname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszHelp
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_help;
            }

            set
            {
                ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->psz_help = (global::System.IntPtr) value;
            }
        }

        public global::libvlc.LibvlcModuleDescriptionT PNext
        {
            get
            {
                global::libvlc.LibvlcModuleDescriptionT __result0;
                if (((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap.ContainsKey(((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlc.LibvlcModuleDescriptionT) global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap[((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlc.LibvlcModuleDescriptionT.__CreateInstance(((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlc.LibvlcModuleDescriptionT.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class libvlc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_errmsg")]
            internal static extern global::System.IntPtr LibvlcErrmsg();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clearerr")]
            internal static extern void LibvlcClearerr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_printerr")]
            internal static extern global::System.IntPtr LibvlcPrinterr([MarshalAs(UnmanagedType.LPStr)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_new")]
            internal static extern global::System.IntPtr LibvlcNew(int argc, sbyte** argv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_release")]
            internal static extern void LibvlcRelease(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_retain")]
            internal static extern void LibvlcRetain(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_add_intf")]
            internal static extern int LibvlcAddIntf(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_exit_handler")]
            internal static extern void LibvlcSetExitHandler(global::System.IntPtr p_instance, global::System.IntPtr cb, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_user_agent")]
            internal static extern void LibvlcSetUserAgent(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string http);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_app_id")]
            internal static extern void LibvlcSetAppId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string id, [MarshalAs(UnmanagedType.LPStr)] string version, [MarshalAs(UnmanagedType.LPStr)] string icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_version")]
            internal static extern global::System.IntPtr LibvlcGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_compiler")]
            internal static extern global::System.IntPtr LibvlcGetCompiler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_changeset")]
            internal static extern global::System.IntPtr LibvlcGetChangeset();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_free")]
            internal static extern void LibvlcFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_attach")]
            internal static extern int LibvlcEventAttach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_detach")]
            internal static extern void LibvlcEventDetach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr p_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_type_name")]
            internal static extern global::System.IntPtr LibvlcEventTypeName(int event_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_context")]
            internal static extern void LibvlcLogGetContext(global::System.IntPtr ctx, sbyte** module, sbyte** file, uint* line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_object")]
            internal static extern void LibvlcLogGetObject(global::System.IntPtr ctx, sbyte** name, sbyte** header, ulong* id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_unset")]
            internal static extern void LibvlcLogUnset(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_set_file")]
            internal static extern void LibvlcLogSetFile(global::System.IntPtr p_instance, global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_module_description_list_release")]
            internal static extern void LibvlcModuleDescriptionListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcVideoFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clock")]
            internal static extern long LibvlcClock();
        }

        /// <summary>
        /// <para>A human-readable error message for the last LibVLC error in the calling</para>
        /// <para>thread. The resulting string is valid until another error occurs (at least</para>
        /// <para>until the next LibVLC call).</para>
        /// </summary>
        /// <remarks>This will be NULL if there was no error.</remarks>
        public static string LibvlcErrmsg()
        {
            var __ret = __Internal.LibvlcErrmsg();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Clears the LibVLC error status for the current thread. This is optional.</para>
        /// <para>By default, the error status is automatically overridden when a new error</para>
        /// <para>occurs, and destroyed when the thread exits.</para>
        /// </summary>
        public static void LibvlcClearerr()
        {
            __Internal.LibvlcClearerr();
        }

        /// <summary>
        /// <para>Sets the LibVLC error status and message for the current thread.</para>
        /// <para>Any previous error is overridden.</para>
        /// </summary>
        /// <param name="fmt">the format string</param>
        /// <param name="args">the arguments</param>
        /// <returns>a nul terminated string in any case</returns>
        public static string LibvlcPrinterr(string fmt)
        {
            var __ret = __Internal.LibvlcPrinterr(fmt);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Create and initialize a libvlc instance.</para>
        /// <para>This functions accept a list of &quot;command line&quot; arguments similar to the</para>
        /// <para>main(). These arguments affect the LibVLC instance default configuration.</para>
        /// </summary>
        /// <param name="argc">the number of arguments (should be 0)</param>
        /// <param name="argv">list of arguments (should be NULL)</param>
        /// <returns>the libvlc instance or NULL in case of error</returns>
        /// <remarks>
        /// <para>LibVLC may create threads. Therefore, any thread-unsafe process</para>
        /// <para>initialization must be performed before calling libvlc_new(). In particular</para>
        /// <para>and where applicable:</para>
        /// <para>- setlocale() and textdomain(),</para>
        /// <para>- setenv(), unsetenv() and putenv(),</para>
        /// <para>- with the X11 display system, XInitThreads()</para>
        /// <para>(see also libvlc_media_player_set_xwindow()) and</para>
        /// <para>- on Microsoft Windows, SetErrorMode().</para>
        /// <para>- sigprocmask() shall never be invoked; pthread_sigmask() can be used.</para>
        /// <para>On POSIX systems, the SIGCHLD signalmust notbe ignored, i.e. the</para>
        /// <para>signal handler must set to SIG_DFL or a function pointer, not SIG_IGN.</para>
        /// <para>Also while LibVLC is active, the wait() function shall not be called, and</para>
        /// <para>any call to waitpid() shall use a strictly positive value for the first</para>
        /// <para>parameter (i.e. the PID). Failure to follow those rules may lead to a</para>
        /// <para>deadlock or a busy loop.</para>
        /// <para>Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked,</para>
        /// <para>even if it is not, in principles, necessary, e.g.:</para>
        /// <para>On Microsoft Windows Vista/2008, the process error mode</para>
        /// <para>SEM_FAILCRITICALERRORS flagmustbe set before using LibVLC.</para>
        /// <para>On later versions, that is optional and unnecessary.</para>
        /// <para>Also on Microsoft Windows (Vista and any later version), setting the default</para>
        /// <para>DLL directories to SYSTEM32 exclusively is strongly recommended for</para>
        /// <para>security reasons:</para>
        /// <para>Arguments are meant to be passed from the command line to LibVLC, just like</para>
        /// <para>VLC media player does. The list of valid arguments depends on the LibVLC</para>
        /// <para>version, the operating system and platform, and set of available LibVLC</para>
        /// <para>plugins. Invalid or unsupported arguments will cause the function to fail</para>
        /// <para>(i.e. return NULL). Also, some arguments may alter the behaviour or</para>
        /// <para>otherwise interfere with other LibVLC functions.</para>
        /// <para>There is absolutely no warranty or promise of forward, backward and</para>
        /// <para>cross-platform compatibility with regards to libvlc_new() arguments.</para>
        /// <para>We recommend that you do not use them, other than when debugging.</para>
        /// </remarks>
        public static global::libvlc.LibvlcInstanceT LibvlcNew(int argc, sbyte** argv)
        {
            var __ret = __Internal.LibvlcNew(argc, argv);
            global::libvlc.LibvlcInstanceT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcInstanceT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcInstanceT) global::libvlc.LibvlcInstanceT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcInstanceT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Decrement the reference count of a libvlc instance, and destroy it</para>
        /// <para>if it reaches zero.</para>
        /// </summary>
        /// <param name="p_instance">the instance to destroy</param>
        public static void LibvlcRelease(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRelease(__arg0);
        }

        /// <summary>
        /// <para>Increments the reference count of a libvlc instance.</para>
        /// <para>The initial reference count is 1 after libvlc_new() returns.</para>
        /// </summary>
        /// <param name="p_instance">the instance to reference</param>
        public static void LibvlcRetain(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRetain(__arg0);
        }

        /// <summary>Try to start a user interface for the libvlc instance.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="name">interface name, or NULL for default</param>
        /// <returns>0 on success, -1 on error.</returns>
        public static int LibvlcAddIntf(global::libvlc.LibvlcInstanceT p_instance, string name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAddIntf(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Registers a callback for the LibVLC exit event. This is mostly useful if</para>
        /// <para>the VLC playlist and/or at least one interface are started with</para>
        /// <para>libvlc_playlist_play() or libvlc_add_intf() respectively.</para>
        /// <para>Typically, this function will wake up your application main loop (from</para>
        /// <para>another thread).</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="cb">
        /// <para>callback to invoke when LibVLC wants to exit,</para>
        /// <para>or NULL to disable the exit handler (as by default)</para>
        /// </param>
        /// <param name="opaque">data pointer for the callback</param>
        /// <remarks>
        /// <para>This function should be called before the playlist or interface are</para>
        /// <para>started. Otherwise, there is a small race condition: the exit event could</para>
        /// <para>be raised before the handler is registered.</para>
        /// <para>This function and libvlc_wait() cannot be used at the same time.</para>
        /// </remarks>
        public static void LibvlcSetExitHandler(global::libvlc.LibvlcInstanceT p_instance, global::libvlc.Delegates.Action_IntPtr cb, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LibvlcSetExitHandler(__arg0, __arg1, opaque);
        }

        /// <summary>
        /// <para>Sets the application name. LibVLC passes this as the user agent string</para>
        /// <para>when a protocol requires it.</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="name">human-readable application name, e.g. &quot;FooBar player 1.2.3&quot;</param>
        /// <param name="http">HTTP User Agent, e.g. &quot;FooBar/1.2.3 Python/2.6.0&quot;</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static void LibvlcSetUserAgent(global::libvlc.LibvlcInstanceT p_instance, string name, string http)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetUserAgent(__arg0, name, http);
        }

        /// <summary>
        /// <para>Sets some meta-information about the application.</para>
        /// <para>See also libvlc_set_user_agent().</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="id">Java-style application identifier, e.g. &quot;com.acme.foobar&quot;</param>
        /// <param name="version">application version numbers, e.g. &quot;1.2.3&quot;</param>
        /// <param name="icon">application icon name, e.g. &quot;foobar&quot;</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public static void LibvlcSetAppId(global::libvlc.LibvlcInstanceT p_instance, string id, string version, string icon)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetAppId(__arg0, id, version, icon);
        }

        /// <summary>Retrieve libvlc version.</summary>
        /// <returns>a string containing the libvlc version</returns>
        /// <remarks>Example: &quot;1.1.0-git The Luggage&quot;</remarks>
        public static string LibvlcGetVersion()
        {
            var __ret = __Internal.LibvlcGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc compiler version.</summary>
        /// <returns>a string containing the libvlc compiler version</returns>
        /// <remarks>Example: &quot;gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)&quot;</remarks>
        public static string LibvlcGetCompiler()
        {
            var __ret = __Internal.LibvlcGetCompiler();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc changeset.</summary>
        /// <returns>a string containing the libvlc changeset</returns>
        /// <remarks>Example: &quot;aa9bce0bc4&quot;</remarks>
        public static string LibvlcGetChangeset()
        {
            var __ret = __Internal.LibvlcGetChangeset();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Frees an heap allocation returned by a LibVLC function.</para>
        /// <para>If you know you're using the same underlying C run-time as the LibVLC</para>
        /// <para>implementation, then you can call ANSI C free() directly instead.</para>
        /// </summary>
        /// <param name="ptr">the pointer</param>
        public static void LibvlcFree(global::System.IntPtr ptr)
        {
            __Internal.LibvlcFree(ptr);
        }

        /// <summary>Register for an event notification.</summary>
        /// <param name="p_event_manager">
        /// <para>the event manager to which you want to attach to.</para>
        /// <para>Generally it is obtained by vlc_my_object_event_manager() where</para>
        /// <para>my_object is the object you want to listen to.</para>
        /// </param>
        /// <param name="i_event_type">the desired event to which we want to listen</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="user_data">user provided data to carry with the event</param>
        /// <returns>0 on success, ENOMEM on error</returns>
        public static int LibvlcEventAttach(global::libvlc.LibvlcEventManagerT p_event_manager, int i_event_type, global::libvlc.LibvlcCallbackT f_callback, global::System.IntPtr user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            var __ret = __Internal.LibvlcEventAttach(__arg0, i_event_type, __arg2, user_data);
            return __ret;
        }

        /// <summary>Unregister an event notification.</summary>
        /// <param name="p_event_manager">the event manager</param>
        /// <param name="i_event_type">the desired event to which we want to unregister</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="p_user_data">user provided data to carry with the event</param>
        public static void LibvlcEventDetach(global::libvlc.LibvlcEventManagerT p_event_manager, int i_event_type, global::libvlc.LibvlcCallbackT f_callback, global::System.IntPtr p_user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            __Internal.LibvlcEventDetach(__arg0, i_event_type, __arg2, p_user_data);
        }

        /// <summary>Get an event's type name.</summary>
        /// <param name="event_type">the desired event</param>
        public static string LibvlcEventTypeName(int event_type)
        {
            var __ret = __Internal.LibvlcEventTypeName(event_type);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Gets log message debug infos.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="module">module name storage (or NULL) [OUT]</param>
        /// <param name="file">source code file name storage (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves self-debug information about a log message:</para>
        /// <para>- the name of the VLC module emitting the message,</para>
        /// <para>- the name of the source code module (i.e. file) and</para>
        /// <para>- the line number within the source code module.</para>
        /// <para>The returned module name and file name will be NULL if unknown.</para>
        /// <para>The returned line number will similarly be zero if unknown.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetContext(global::libvlc.VlcLogT ctx, sbyte** module, sbyte** file, ref uint line)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (uint* __refParamPtr3 = &line)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetContext(__arg0, module, file, __arg3);
            }
        }

        /// <summary>Gets log message info.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="name">object name storage (or NULL) [OUT]</param>
        /// <param name="header">object header (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves meta-information about a log message:</para>
        /// <para>- the type name of the VLC object emitting the message,</para>
        /// <para>- the object header if any, and</para>
        /// <para>- a temporaly-unique object identifier.</para>
        /// <para>This information is mainly meant formanualtroubleshooting.</para>
        /// <para>The returned type name may be &quot;generic&quot; if unknown, but it cannot be NULL.</para>
        /// <para>The returned header will be NULL if unset; in current versions, the header</para>
        /// <para>is used to distinguish for VLM inputs.</para>
        /// <para>The returned object ID will be zero if the message is not associated with</para>
        /// <para>any VLC object.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetObject(global::libvlc.VlcLogT ctx, sbyte** name, sbyte** header, ref ulong id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __refParamPtr3 = &id)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetObject(__arg0, name, header, __arg3);
            }
        }

        /// <summary>Unsets the logging callback.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <remarks>
        /// <para>This function deregisters the logging callback for a LibVLC instance.</para>
        /// <para>This is rarely needed as the callback is implicitly unset when the instance</para>
        /// <para>is destroyed.</para>
        /// <para>This function will wait for any pending callbacks invocation to</para>
        /// <para>complete (causing a deadlock if called from within the callback).</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogUnset(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogUnset(__arg0);
        }

        /// <summary>Sets up logging to a file.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <param name="stream">
        /// <para>FILE pointer opened for writing</para>
        /// <para>(the FILE pointer must remain valid until libvlc_log_unset())</para>
        /// </param>
        /// <remarks>LibVLC 2.1.0 or later</remarks>
        public static void LibvlcLogSetFile(global::libvlc.LibvlcInstanceT p_instance, global::System.IntPtr stream)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogSetFile(__arg0, stream);
        }

        /// <summary>Release a list of module descriptions.</summary>
        /// <param name="p_list">the list to be released</param>
        public static void LibvlcModuleDescriptionListRelease(global::libvlc.LibvlcModuleDescriptionT p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcModuleDescriptionListRelease(__arg0);
        }

        /// <summary>Returns a list of audio filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::libvlc.LibvlcModuleDescriptionT LibvlcAudioFilterListGet(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioFilterListGet(__arg0);
            global::libvlc.LibvlcModuleDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcModuleDescriptionT) global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcModuleDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Returns a list of video filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::libvlc.LibvlcModuleDescriptionT LibvlcVideoFilterListGet(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVideoFilterListGet(__arg0);
            global::libvlc.LibvlcModuleDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcModuleDescriptionT) global::libvlc.LibvlcModuleDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcModuleDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Return the current time as defined by LibVLC. The unit is the microsecond.</para>
        /// <para>Time increases monotonically (regardless of time zone changes and RTC</para>
        /// <para>adjustements).</para>
        /// <para>The origin is arbitrary but consistent across the whole system</para>
        /// <para>(e.g. the system uptim, the time since the system was booted).</para>
        /// </summary>
        /// <remarks>On systems that support it, the POSIX monotonic clock is used.</remarks>
        public static long LibvlcClock()
        {
            var __ret = __Internal.LibvlcClock();
            return __ret;
        }
    }

    /// <summary>
    /// <para>LibVLC renderer discoverer finds available renderers available on the local</para>
    /// <para>network</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC renderer discoverer external API</para>
    /// </summary>
    /// <summary>Renderer item</summary>
    /// <remarks>
    /// <para>This struct is passed by a</para>
    /// <para>or deleted.</para>
    /// <para>An item is valid until the</para>
    /// <para>is called with the same pointer.</para>
    /// <para>libvlc_renderer_discoverer_event_manager()</para>
    /// </remarks>
    public unsafe partial class LibvlcRendererItemT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRendererItemT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRendererItemT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcRendererItemT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRendererItemT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcRendererItemT __CreateInstance(global::libvlc.LibvlcRendererItemT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRendererItemT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcRendererItemT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcRendererItemT.__Internal));
            *(global::libvlc.LibvlcRendererItemT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcRendererItemT(global::libvlc.LibvlcRendererItemT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcRendererItemT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcRendererDiscovererT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRendererDiscovererT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRendererDiscovererT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcRendererDiscovererT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRendererDiscovererT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcRendererDiscovererT __CreateInstance(global::libvlc.LibvlcRendererDiscovererT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRendererDiscovererT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcRendererDiscovererT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcRendererDiscovererT.__Internal));
            *(global::libvlc.LibvlcRendererDiscovererT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcRendererDiscovererT(global::libvlc.LibvlcRendererDiscovererT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcRendererDiscovererT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Renderer discoverer description</summary>
    /// <remarks>libvlc_renderer_discoverer_list_get()</remarks>
    public unsafe partial class LibvlcRdDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_longname;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRdDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcRdDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcRdDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRdDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcRdDescriptionT __CreateInstance(global::libvlc.LibvlcRdDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcRdDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcRdDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcRdDescriptionT.__Internal));
            *(global::libvlc.LibvlcRdDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcRdDescriptionT(global::libvlc.LibvlcRdDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcRdDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcRdDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcRdDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcRdDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcRdDescriptionT.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlc.LibvlcRdDescriptionT.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class libvlc_renderer_discoverer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_name")]
            internal static extern global::System.IntPtr LibvlcRendererItemName(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_type")]
            internal static extern global::System.IntPtr LibvlcRendererItemType(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_icon_uri")]
            internal static extern global::System.IntPtr LibvlcRendererItemIconUri(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_flags")]
            internal static extern int LibvlcRendererItemFlags(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_new")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererNew(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_release")]
            internal static extern void LibvlcRendererDiscovererRelease(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_start")]
            internal static extern int LibvlcRendererDiscovererStart(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_stop")]
            internal static extern void LibvlcRendererDiscovererStop(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererEventManager(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_get")]
            internal static extern ulong LibvlcRendererDiscovererListGet(global::System.IntPtr p_inst, global::System.IntPtr ppp_services);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_release")]
            internal static extern void LibvlcRendererDiscovererListRelease(global::System.IntPtr pp_services, ulong i_count);
        }

        /// <summary>Get the human readable name of a renderer item</summary>
        /// <returns>the name of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemName(global::libvlc.LibvlcRendererItemT p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Get the type (not translated) of a renderer item. For now, the type can only</para>
        /// <para>be &quot;chromecast&quot; (&quot;upnp&quot;, &quot;airplay&quot; may come later).</para>
        /// </summary>
        /// <returns>the type of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemType(global::libvlc.LibvlcRendererItemT p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemType(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the icon uri of a renderer item</summary>
        /// <returns>the uri of the item's icon (can be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemIconUri(global::libvlc.LibvlcRendererItemT p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemIconUri(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the flags of a renderer item</summary>
        /// <returns>bitwise flag: capabilities of the renderer, see</returns>
        /// <remarks>
        /// <para>LIBVLC_RENDERER_CAN_AUDIO</para>
        /// <para>LIBVLC_RENDERER_CAN_VIDEO</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererItemFlags(global::libvlc.LibvlcRendererItemT p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemFlags(__arg0);
            return __ret;
        }

        /// <summary>Create a renderer discoverer object by name</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="psz_name">
        /// <para>service name; use libvlc_renderer_discoverer_list_get() to</para>
        /// <para>get a list of the discoverer names available in this libVLC instance</para>
        /// </param>
        /// <returns>media discover object or NULL in case of error</returns>
        /// <remarks>
        /// <para>After this object is created, you should attach to events in order to be</para>
        /// <para>notified of the discoverer events.</para>
        /// <para>You need to call libvlc_renderer_discoverer_start() in order to start the</para>
        /// <para>discovery.</para>
        /// <para>libvlc_renderer_discoverer_event_manager()</para>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcRendererDiscovererT LibvlcRendererDiscovererNew(global::libvlc.LibvlcInstanceT p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererNew(__arg0, psz_name);
            global::libvlc.LibvlcRendererDiscovererT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcRendererDiscovererT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcRendererDiscovererT) global::libvlc.LibvlcRendererDiscovererT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcRendererDiscovererT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release a renderer discoverer object</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static void LibvlcRendererDiscovererRelease(global::libvlc.LibvlcRendererDiscovererT p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererRelease(__arg0);
        }

        /// <summary>Start renderer discovery</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>To stop it, call libvlc_renderer_discoverer_stop() or</para>
        /// <para>libvlc_renderer_discoverer_release() directly.</para>
        /// <para>libvlc_renderer_discoverer_stop()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererDiscovererStart(global::libvlc.LibvlcRendererDiscovererT p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererStart(__arg0);
            return __ret;
        }

        /// <summary>Stop renderer discovery.</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererStop(global::libvlc.LibvlcRendererDiscovererT p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererStop(__arg0);
        }

        /// <summary>Get the event manager of the renderer discoverer</summary>
        /// <returns>a valid event manager (can't fail)</returns>
        /// <remarks>
        /// <para>The possible events to attach are</para>
        /// <para>and</para>
        /// <para>The</para>
        /// <para>VLC, users should take care of copying this struct for their internal usage.</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_added.item</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_removed.item</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcEventManagerT LibvlcRendererDiscovererEventManager(global::libvlc.LibvlcRendererDiscovererT p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media discoverer services</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="ppp_services">
        /// <para>address to store an allocated array of renderer</para>
        /// <para>discoverer services (must be freed with libvlc_renderer_list_release() by</para>
        /// <para>the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of media discoverer services (0 on error)</returns>
        /// <remarks>
        /// <para>libvlc_renderer_list_release()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static ulong LibvlcRendererDiscovererListGet(global::libvlc.LibvlcInstanceT p_inst, global::libvlc.LibvlcRdDescriptionT ppp_services)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __arg1 = ReferenceEquals(ppp_services, null) ? global::System.IntPtr.Zero : ppp_services.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererListGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release an array of media discoverer services</summary>
        /// <param name="pp_services">array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_list_get()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererListRelease(global::libvlc.LibvlcRdDescriptionT pp_services, ulong i_count)
        {
            var __arg0 = ReferenceEquals(pp_services, null) ? global::System.IntPtr.Zero : pp_services.__Instance;
            __Internal.LibvlcRendererDiscovererListRelease(__arg0, i_count);
        }
    }

    /// <summary>Meta data types</summary>
    public enum LibvlcMetaT
    {
        LibvlcMetaTitle = 0,
        LibvlcMetaArtist = 1,
        LibvlcMetaGenre = 2,
        LibvlcMetaCopyright = 3,
        LibvlcMetaAlbum = 4,
        LibvlcMetaTrackNumber = 5,
        LibvlcMetaDescription = 6,
        LibvlcMetaRating = 7,
        LibvlcMetaDate = 8,
        LibvlcMetaSetting = 9,
        LibvlcMetaURL = 10,
        LibvlcMetaLanguage = 11,
        LibvlcMetaNowPlaying = 12,
        LibvlcMetaPublisher = 13,
        LibvlcMetaEncodedBy = 14,
        LibvlcMetaArtworkURL = 15,
        LibvlcMetaTrackID = 16,
        LibvlcMetaTrackTotal = 17,
        LibvlcMetaDirector = 18,
        LibvlcMetaSeason = 19,
        LibvlcMetaEpisode = 20,
        LibvlcMetaShowName = 21,
        LibvlcMetaActors = 22,
        LibvlcMetaAlbumArtist = 23,
        LibvlcMetaDiscNumber = 24,
        LibvlcMetaDiscTotal = 25
    }

    public enum LibvlcTrackTypeT
    {
        LibvlcTrackUnknown = -1,
        LibvlcTrackAudio = 0,
        LibvlcTrackVideo = 1,
        LibvlcTrackText = 2
    }

    /// <summary>Note the order of libvlc_state_t enum must match exactly the order of</summary>
    /// <remarks>
    /// <para>mediacontrol_PlayerStatus,</para>
    /// <para>input_state_e enums,</para>
    /// <para>and VideoLAN.LibVLC.State (at bindings/cil/src/media.cs).</para>
    /// <para>Expected states by web plugins are:</para>
    /// <para>IDLE/CLOSE=0, OPENING=1, PLAYING=3, PAUSED=4,</para>
    /// <para>STOPPING=5, ENDED=6, ERROR=7</para>
    /// </remarks>
    public enum LibvlcStateT
    {
        LibvlcNothingSpecial = 0,
        LibvlcOpening = 1,
        LibvlcBuffering = 2,
        LibvlcPlaying = 3,
        LibvlcPaused = 4,
        LibvlcStopped = 5,
        LibvlcEnded = 6,
        LibvlcError = 7
    }

    [Flags]
    public enum LibvlcMediaOption
    {
        LibvlcMediaOptionTrusted = 2,
        LibvlcMediaOptionUnique = 256
    }

    public enum LibvlcVideoOrientT
    {
        /// <summary>Normal. Top line represents top, left column left.</summary>
        LibvlcVideoOrientTopLeft = 0,
        /// <summary>Flipped horizontally</summary>
        LibvlcVideoOrientTopRight = 1,
        /// <summary>Flipped vertically</summary>
        LibvlcVideoOrientBottomLeft = 2,
        /// <summary>Rotated 180 degrees</summary>
        LibvlcVideoOrientBottomRight = 3,
        /// <summary>Transposed</summary>
        LibvlcVideoOrientLeftTop = 4,
        /// <summary>Rotated 90 degrees clockwise (or 270 anti-clockwise)</summary>
        LibvlcVideoOrientLeftBottom = 5,
        /// <summary>Rotated 90 degrees anti-clockwise</summary>
        LibvlcVideoOrientRightTop = 6,
        /// <summary>Anti-transposed</summary>
        LibvlcVideoOrientRightBottom = 7
    }

    [Flags]
    public enum LibvlcVideoProjectionT
    {
        LibvlcVideoProjectionRectangular = 0,
        /// <summary>360 spherical</summary>
        LibvlcVideoProjectionEquirectangular = 1,
        LibvlcVideoProjectionCubemapLayoutStandard = 256
    }

    /// <summary>Media type</summary>
    /// <remarks>libvlc_media_get_type</remarks>
    public enum LibvlcMediaTypeT
    {
        LibvlcMediaTypeUnknown = 0,
        LibvlcMediaTypeFile = 1,
        LibvlcMediaTypeDirectory = 2,
        LibvlcMediaTypeDisc = 3,
        LibvlcMediaTypeStream = 4,
        LibvlcMediaTypePlaylist = 5
    }

    /// <summary>Parse flags used by libvlc_media_parse_with_options()</summary>
    /// <remarks>libvlc_media_parse_with_options</remarks>
    [Flags]
    public enum LibvlcMediaParseFlagT
    {
        /// <summary>Parse media if it's a local file</summary>
        LibvlcMediaParseLocal = 0,
        /// <summary>Parse media even if it's a network file</summary>
        LibvlcMediaParseNetwork = 1,
        /// <summary>Fetch meta and covert art using local resources</summary>
        LibvlcMediaFetchLocal = 2,
        /// <summary>Fetch meta and covert art using network resources</summary>
        LibvlcMediaFetchNetwork = 4,
        /// <summary>
        /// <para>Interact with the user (via libvlc_dialog_cbs) when preparsing this item</para>
        /// <para>(and not its sub items). Set this flag in order to receive a callback</para>
        /// <para>when the input is asking for credentials.</para>
        /// </summary>
        LibvlcMediaDoInteract = 8
    }

    /// <summary>
    /// <para>Parse status used sent by libvlc_media_parse_with_options() or returned by</para>
    /// <para>libvlc_media_get_parsed_status()</para>
    /// </summary>
    /// <remarks>
    /// <para>libvlc_media_parse_with_options</para>
    /// <para>libvlc_media_get_parsed_status</para>
    /// </remarks>
    public enum LibvlcMediaParsedStatusT
    {
        LibvlcMediaParsedStatusSkipped = 1,
        LibvlcMediaParsedStatusFailed = 2,
        LibvlcMediaParsedStatusTimeout = 3,
        LibvlcMediaParsedStatusDone = 4
    }

    /// <summary>Type of a media slave: subtitle or audio.</summary>
    public enum LibvlcMediaSlaveTypeT
    {
        LibvlcMediaSlaveTypeSubtitle = 0,
        LibvlcMediaSlaveTypeAudio = 1
    }

    /// <summary>
    /// <para>It consists of a media location and various optional meta data.</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media item/descriptor external API</para>
    /// </summary>
    /// <summary>Callback prototype to open a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_media_new_callbacks()</param>
    /// <param name="datap">storage space for a private data pointer [OUT]</param>
    /// <param name="sizep">byte length of the bitstream or UINT64_MAX if unknown [OUT]</param>
    /// <returns>
    /// <para>0 on success, non-zero on error. In case of failure, the other</para>
    /// <para>callbacks will not be invoked and any value stored in *datap and *sizep is</para>
    /// <para>discarded.</para>
    /// </returns>
    /// <remarks>
    /// <para>The same media item can be opened multiple times. Each time, this callback</para>
    /// <para>is invoked. It should allocate and initialize any instance-specific</para>
    /// <para>resources, then store them in *datap. The instance resources can be freed</para>
    /// <para>in the</para>
    /// <para>For convenience, *datap is initially NULL and *sizep is initially 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcMediaOpenCb(global::System.IntPtr opaque, void** datap, ulong* sizep);

    /// <summary>Callback prototype to read data from a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <param name="buf">start address of the buffer to read data into</param>
    /// <param name="len">bytes length of the buffer</param>
    /// <returns>
    /// <para>strictly positive number of bytes read, 0 on end-of-stream,</para>
    /// <para>or -1 on non-recoverable error</para>
    /// </returns>
    /// <remarks>
    /// <para>callback</para>
    /// <para>If no data is immediately available, then the callback should sleep.</para>
    /// <para>The application is responsible for avoiding deadlock situations.</para>
    /// <para>In particular, the callback should return an error if playback is stopped;</para>
    /// <para>if it does not return, then libvlc_media_player_stop() will never return.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate long LibvlcMediaReadCb(global::System.IntPtr opaque, byte* buf, ulong len);

    /// <summary>Callback prototype to seek a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <param name="offset">absolute byte offset to seek to</param>
    /// <returns>0 on success, -1 on error.</returns>
    /// <remarks>callback</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcMediaSeekCb(global::System.IntPtr opaque, ulong offset);

    /// <summary>Callback prototype to close a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <remarks>callback</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcMediaCloseCb(global::System.IntPtr opaque);

    public unsafe partial class LibvlcMediaT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaT __CreateInstance(global::libvlc.LibvlcMediaT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaT.__Internal));
            *(global::libvlc.LibvlcMediaT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaT(global::libvlc.LibvlcMediaT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcMediaListT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaListT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaListT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaListT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaListT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaListT __CreateInstance(global::libvlc.LibvlcMediaListT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaListT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaListT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaListT.__Internal));
            *(global::libvlc.LibvlcMediaListT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaListT(global::libvlc.LibvlcMediaListT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaListT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcMediaStatsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 60)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_read_bytes;

            [FieldOffset(4)]
            internal float f_input_bitrate;

            [FieldOffset(8)]
            internal int i_demux_read_bytes;

            [FieldOffset(12)]
            internal float f_demux_bitrate;

            [FieldOffset(16)]
            internal int i_demux_corrupted;

            [FieldOffset(20)]
            internal int i_demux_discontinuity;

            [FieldOffset(24)]
            internal int i_decoded_video;

            [FieldOffset(28)]
            internal int i_decoded_audio;

            [FieldOffset(32)]
            internal int i_displayed_pictures;

            [FieldOffset(36)]
            internal int i_lost_pictures;

            [FieldOffset(40)]
            internal int i_played_abuffers;

            [FieldOffset(44)]
            internal int i_lost_abuffers;

            [FieldOffset(48)]
            internal int i_sent_packets;

            [FieldOffset(52)]
            internal int i_sent_bytes;

            [FieldOffset(56)]
            internal float f_send_bitrate;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaStatsT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaStatsT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaStatsT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaStatsT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaStatsT __CreateInstance(global::libvlc.LibvlcMediaStatsT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaStatsT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaStatsT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaStatsT.__Internal));
            *(global::libvlc.LibvlcMediaStatsT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaStatsT(global::libvlc.LibvlcMediaStatsT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaStatsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcMediaStatsT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int IReadBytes
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_read_bytes;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_read_bytes = value;
            }
        }

        public float FInputBitrate
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_input_bitrate;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_input_bitrate = value;
            }
        }

        public int IDemuxReadBytes
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_read_bytes;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_read_bytes = value;
            }
        }

        public float FDemuxBitrate
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_demux_bitrate;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_demux_bitrate = value;
            }
        }

        public int IDemuxCorrupted
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_corrupted;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_corrupted = value;
            }
        }

        public int IDemuxDiscontinuity
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_discontinuity;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_demux_discontinuity = value;
            }
        }

        public int IDecodedVideo
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_decoded_video;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_decoded_video = value;
            }
        }

        public int IDecodedAudio
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_decoded_audio;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_decoded_audio = value;
            }
        }

        public int IDisplayedPictures
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_displayed_pictures;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_displayed_pictures = value;
            }
        }

        public int ILostPictures
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_lost_pictures;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_lost_pictures = value;
            }
        }

        public int IPlayedAbuffers
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_played_abuffers;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_played_abuffers = value;
            }
        }

        public int ILostAbuffers
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_lost_abuffers;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_lost_abuffers = value;
            }
        }

        public int ISentPackets
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_sent_packets;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_sent_packets = value;
            }
        }

        public int ISentBytes
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_sent_bytes;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->i_sent_bytes = value;
            }
        }

        public float FSendBitrate
        {
            get
            {
                return ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_send_bitrate;
            }

            set
            {
                ((global::libvlc.LibvlcMediaStatsT.__Internal*) __Instance)->f_send_bitrate = value;
            }
        }
    }

    public unsafe partial class LibvlcMediaTrackInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_codec;

            [FieldOffset(4)]
            internal int i_id;

            [FieldOffset(8)]
            internal global::libvlc.LibvlcTrackTypeT i_type;

            [FieldOffset(12)]
            internal int i_profile;

            [FieldOffset(16)]
            internal int i_level;

            [FieldOffset(20)]
            internal global::libvlc.LibvlcMediaTrackInfoT._.__Internal u;
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::libvlc.LibvlcMediaTrackInfoT._.__.__Internal audio;

                [FieldOffset(0)]
                internal global::libvlc.LibvlcMediaTrackInfoT._.___.__Internal video;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint i_channels;

                    [FieldOffset(4)]
                    internal uint i_rate;
                }
            }

            public unsafe partial class ___
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint i_height;

                    [FieldOffset(4)]
                    internal uint i_width;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaTrackInfoT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaTrackInfoT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaTrackInfoT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaTrackInfoT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaTrackInfoT __CreateInstance(global::libvlc.LibvlcMediaTrackInfoT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaTrackInfoT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaTrackInfoT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaTrackInfoT.__Internal));
            *(global::libvlc.LibvlcMediaTrackInfoT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaTrackInfoT(global::libvlc.LibvlcMediaTrackInfoT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaTrackInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcMediaTrackInfoT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ICodec
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_codec;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_codec = value;
            }
        }

        public int IId
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_id = value;
            }
        }

        public global::libvlc.LibvlcTrackTypeT IType
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_type = value;
            }
        }

        public int IProfile
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_profile;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_profile = value;
            }
        }

        public int ILevel
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_level;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackInfoT.__Internal*) __Instance)->i_level = value;
            }
        }
    }

    public unsafe partial class LibvlcAudioTrackT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_channels;

            [FieldOffset(4)]
            internal uint i_rate;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioTrackT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioTrackT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcAudioTrackT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioTrackT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcAudioTrackT __CreateInstance(global::libvlc.LibvlcAudioTrackT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioTrackT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcAudioTrackT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcAudioTrackT.__Internal));
            *(global::libvlc.LibvlcAudioTrackT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcAudioTrackT(global::libvlc.LibvlcAudioTrackT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcAudioTrackT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcAudioTrackT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint IChannels
        {
            get
            {
                return ((global::libvlc.LibvlcAudioTrackT.__Internal*) __Instance)->i_channels;
            }

            set
            {
                ((global::libvlc.LibvlcAudioTrackT.__Internal*) __Instance)->i_channels = value;
            }
        }

        public uint IRate
        {
            get
            {
                return ((global::libvlc.LibvlcAudioTrackT.__Internal*) __Instance)->i_rate;
            }

            set
            {
                ((global::libvlc.LibvlcAudioTrackT.__Internal*) __Instance)->i_rate = value;
            }
        }
    }

    public unsafe partial class LibvlcVideoTrackT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_height;

            [FieldOffset(4)]
            internal uint i_width;

            [FieldOffset(8)]
            internal uint i_sar_num;

            [FieldOffset(12)]
            internal uint i_sar_den;

            [FieldOffset(16)]
            internal uint i_frame_rate_num;

            [FieldOffset(20)]
            internal uint i_frame_rate_den;

            [FieldOffset(24)]
            internal global::libvlc.LibvlcVideoOrientT i_orientation;

            [FieldOffset(28)]
            internal global::libvlc.LibvlcVideoProjectionT i_projection;

            [FieldOffset(32)]
            internal global::libvlc.LibvlcVideoTrackT._.__Internal pose;
        }

        public unsafe partial class _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal float f_yaw_degrees;

                [FieldOffset(4)]
                internal float f_pitch_degrees;

                [FieldOffset(8)]
                internal float f_roll_degrees;

                [FieldOffset(12)]
                internal float f_fov_degrees;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcVideoTrackT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcVideoTrackT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcVideoTrackT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcVideoTrackT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcVideoTrackT __CreateInstance(global::libvlc.LibvlcVideoTrackT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcVideoTrackT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcVideoTrackT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcVideoTrackT.__Internal));
            *(global::libvlc.LibvlcVideoTrackT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcVideoTrackT(global::libvlc.LibvlcVideoTrackT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcVideoTrackT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcVideoTrackT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint IHeight
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_height;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_height = value;
            }
        }

        public uint IWidth
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_width;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_width = value;
            }
        }

        public uint ISarNum
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_sar_num;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_sar_num = value;
            }
        }

        public uint ISarDen
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_sar_den;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_sar_den = value;
            }
        }

        public uint IFrameRateNum
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_frame_rate_num;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_frame_rate_num = value;
            }
        }

        public uint IFrameRateDen
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_frame_rate_den;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_frame_rate_den = value;
            }
        }

        public global::libvlc.LibvlcVideoOrientT IOrientation
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_orientation;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_orientation = value;
            }
        }

        public global::libvlc.LibvlcVideoProjectionT IProjection
        {
            get
            {
                return ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_projection;
            }

            set
            {
                ((global::libvlc.LibvlcVideoTrackT.__Internal*) __Instance)->i_projection = value;
            }
        }
    }

    public unsafe partial class LibvlcSubtitleTrackT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_encoding;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcSubtitleTrackT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcSubtitleTrackT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcSubtitleTrackT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcSubtitleTrackT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcSubtitleTrackT __CreateInstance(global::libvlc.LibvlcSubtitleTrackT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcSubtitleTrackT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcSubtitleTrackT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcSubtitleTrackT.__Internal));
            *(global::libvlc.LibvlcSubtitleTrackT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcSubtitleTrackT(global::libvlc.LibvlcSubtitleTrackT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcSubtitleTrackT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcSubtitleTrackT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszEncoding
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcSubtitleTrackT.__Internal*) __Instance)->psz_encoding;
            }

            set
            {
                ((global::libvlc.LibvlcSubtitleTrackT.__Internal*) __Instance)->psz_encoding = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class LibvlcMediaTrackT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_codec;

            [FieldOffset(4)]
            internal uint i_original_fourcc;

            [FieldOffset(8)]
            internal int i_id;

            [FieldOffset(12)]
            internal global::libvlc.LibvlcTrackTypeT i_type;

            [FieldOffset(16)]
            internal int i_profile;

            [FieldOffset(20)]
            internal int i_level;

            [FieldOffset(24)]
            internal global::libvlc.LibvlcMediaTrackT._.__Internal _;

            [FieldOffset(32)]
            internal uint i_bitrate;

            [FieldOffset(40)]
            internal global::System.IntPtr psz_language;

            [FieldOffset(48)]
            internal global::System.IntPtr psz_description;
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr audio;

                [FieldOffset(0)]
                internal global::System.IntPtr video;

                [FieldOffset(0)]
                internal global::System.IntPtr subtitle;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaTrackT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaTrackT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaTrackT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaTrackT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaTrackT __CreateInstance(global::libvlc.LibvlcMediaTrackT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaTrackT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaTrackT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaTrackT.__Internal));
            *(global::libvlc.LibvlcMediaTrackT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaTrackT(global::libvlc.LibvlcMediaTrackT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaTrackT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcMediaTrackT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ICodec
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_codec;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_codec = value;
            }
        }

        public uint IOriginalFourcc
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_original_fourcc;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_original_fourcc = value;
            }
        }

        public int IId
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_id = value;
            }
        }

        public global::libvlc.LibvlcTrackTypeT IType
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_type = value;
            }
        }

        public int IProfile
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_profile;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_profile = value;
            }
        }

        public int ILevel
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_level;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_level = value;
            }
        }

        public uint IBitrate
        {
            get
            {
                return ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_bitrate;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->i_bitrate = value;
            }
        }

        public sbyte* PszLanguage
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->psz_language;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->psz_language = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlc.LibvlcMediaTrackT.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>A slave of a libvlc_media_t</summary>
    /// <remarks>libvlc_media_slaves_get</remarks>
    public unsafe partial class LibvlcMediaSlaveT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_uri;

            [FieldOffset(8)]
            internal global::libvlc.LibvlcMediaSlaveTypeT i_type;

            [FieldOffset(12)]
            internal uint i_priority;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaSlaveT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaSlaveT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaSlaveT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaSlaveT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaSlaveT __CreateInstance(global::libvlc.LibvlcMediaSlaveT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaSlaveT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaSlaveT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaSlaveT.__Internal));
            *(global::libvlc.LibvlcMediaSlaveT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaSlaveT(global::libvlc.LibvlcMediaSlaveT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaSlaveT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcMediaSlaveT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszUri
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->psz_uri;
            }

            set
            {
                ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->psz_uri = (global::System.IntPtr) value;
            }
        }

        public global::libvlc.LibvlcMediaSlaveTypeT IType
        {
            get
            {
                return ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->i_type = value;
            }
        }

        public uint IPriority
        {
            get
            {
                return ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->i_priority;
            }

            set
            {
                ((global::libvlc.LibvlcMediaSlaveT.__Internal*) __Instance)->i_priority = value;
            }
        }
    }

    public unsafe partial class libvlc_media
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_location")]
            internal static extern global::System.IntPtr LibvlcMediaNewLocation(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_mrl);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_path")]
            internal static extern global::System.IntPtr LibvlcMediaNewPath(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_fd")]
            internal static extern global::System.IntPtr LibvlcMediaNewFd(global::System.IntPtr p_instance, int fd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_callbacks")]
            internal static extern global::System.IntPtr LibvlcMediaNewCallbacks(global::System.IntPtr instance, global::System.IntPtr open_cb, global::System.IntPtr read_cb, global::System.IntPtr seek_cb, global::System.IntPtr close_cb, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_as_node")]
            internal static extern global::System.IntPtr LibvlcMediaNewAsNode(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_add_option")]
            internal static extern void LibvlcMediaAddOption(global::System.IntPtr p_md, [MarshalAs(UnmanagedType.LPStr)] string psz_options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_add_option_flag")]
            internal static extern void LibvlcMediaAddOptionFlag(global::System.IntPtr p_md, [MarshalAs(UnmanagedType.LPStr)] string psz_options, uint i_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_retain")]
            internal static extern void LibvlcMediaRetain(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_release")]
            internal static extern void LibvlcMediaRelease(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_mrl")]
            internal static extern sbyte* LibvlcMediaGetMrl(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_duplicate")]
            internal static extern global::System.IntPtr LibvlcMediaDuplicate(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_meta")]
            internal static extern sbyte* LibvlcMediaGetMeta(global::System.IntPtr p_md, global::libvlc.LibvlcMetaT e_meta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_set_meta")]
            internal static extern void LibvlcMediaSetMeta(global::System.IntPtr p_md, global::libvlc.LibvlcMetaT e_meta, [MarshalAs(UnmanagedType.LPStr)] string psz_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_save_meta")]
            internal static extern int LibvlcMediaSaveMeta(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_state")]
            internal static extern global::libvlc.LibvlcStateT LibvlcMediaGetState(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_stats")]
            internal static extern int LibvlcMediaGetStats(global::System.IntPtr p_md, global::System.IntPtr p_stats);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_subitems")]
            internal static extern global::System.IntPtr LibvlcMediaSubitems(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaEventManager(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_duration")]
            internal static extern long LibvlcMediaGetDuration(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_with_options")]
            internal static extern int LibvlcMediaParseWithOptions(global::System.IntPtr p_md, global::libvlc.LibvlcMediaParseFlagT parse_flag, int timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_stop")]
            internal static extern void LibvlcMediaParseStop(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_parsed_status")]
            internal static extern global::libvlc.LibvlcMediaParsedStatusT LibvlcMediaGetParsedStatus(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_set_user_data")]
            internal static extern void LibvlcMediaSetUserData(global::System.IntPtr p_md, global::System.IntPtr p_new_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_user_data")]
            internal static extern global::System.IntPtr LibvlcMediaGetUserData(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_tracks_get")]
            internal static extern uint LibvlcMediaTracksGet(global::System.IntPtr p_md, global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_codec_description")]
            internal static extern global::System.IntPtr LibvlcMediaGetCodecDescription(global::libvlc.LibvlcTrackTypeT i_type, uint i_codec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_tracks_release")]
            internal static extern void LibvlcMediaTracksRelease(global::System.IntPtr p_tracks, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_type")]
            internal static extern global::libvlc.LibvlcMediaTypeT LibvlcMediaGetType(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_add")]
            internal static extern int LibvlcMediaSlavesAdd(global::System.IntPtr p_md, global::libvlc.LibvlcMediaSlaveTypeT i_type, uint i_priority, [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_clear")]
            internal static extern void LibvlcMediaSlavesClear(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_get")]
            internal static extern uint LibvlcMediaSlavesGet(global::System.IntPtr p_md, global::System.IntPtr ppp_slaves);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_release")]
            internal static extern void LibvlcMediaSlavesRelease(global::System.IntPtr pp_slaves, uint i_count);
        }

        /// <summary>
        /// <para>Create a media with a certain given media resource location,</para>
        /// <para>for instance a valid URL.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_mrl">the media location</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>To refer to a local file with this function,</para>
        /// <para>the file://... URI syntaxmustbe used (see IETF RFC3986).</para>
        /// <para>We recommend using libvlc_media_new_path() instead when dealing with</para>
        /// <para>local files.</para>
        /// <para>libvlc_media_release</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaT LibvlcMediaNewLocation(global::libvlc.LibvlcInstanceT p_instance, string psz_mrl)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewLocation(__arg0, psz_mrl);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media for a certain file path.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="path">local filesystem path</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>libvlc_media_release</remarks>
        public static global::libvlc.LibvlcMediaT LibvlcMediaNewPath(global::libvlc.LibvlcInstanceT p_instance, string path)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewPath(__arg0, path);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a media for an already open file descriptor.</para>
        /// <para>The file descriptor shall be open for reading (or reading and writing).</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="fd">open file descriptor</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>Regular file descriptors, pipe read descriptors and character device</para>
        /// <para>descriptors (including TTYs) are supported on all platforms.</para>
        /// <para>Block device descriptors are supported where available.</para>
        /// <para>Directory descriptors are supported on systems that provide fdopendir().</para>
        /// <para>Sockets are supported on all platforms where they are file descriptors,</para>
        /// <para>i.e. all except Windows.</para>
        /// <para>This library willnotautomatically close the file descriptor</para>
        /// <para>under any circumstance. Nevertheless, a file descriptor can usually only be</para>
        /// <para>rendered once in a media player. To render it a second time, the file</para>
        /// <para>descriptor should probably be rewound to the beginning with lseek().</para>
        /// <para>libvlc_media_release</para>
        /// <para>LibVLC 1.1.5 and later.</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaT LibvlcMediaNewFd(global::libvlc.LibvlcInstanceT p_instance, int fd)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewFd(__arg0, fd);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media with custom callbacks to read the data from.</summary>
        /// <param name="instance">LibVLC instance</param>
        /// <param name="open_cb">callback to open the custom bitstream input media</param>
        /// <param name="read_cb">callback to read data (must not be NULL)</param>
        /// <param name="seek_cb">callback to seek, or NULL if seeking is not supported</param>
        /// <param name="close_cb">callback to close the media, or NULL if unnecessary</param>
        /// <param name="opaque">data pointer for the open callback</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>If open_cb is NULL, the opaque pointer will be passed to read_cb,</para>
        /// <para>seek_cb and close_cb, and the stream size will be treated as unknown.</para>
        /// <para>The callbacks may be called asynchronously (from another thread).</para>
        /// <para>A single stream instance need not be reentrant. However the open_cb needs to</para>
        /// <para>be reentrant if the media is used by multiple player instances.</para>
        /// <para>The callbacks may be used until all or any player instances</para>
        /// <para>that were supplied the media item are stopped.</para>
        /// <para>libvlc_media_release</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaT LibvlcMediaNewCallbacks(global::libvlc.LibvlcInstanceT instance, global::libvlc.LibvlcMediaOpenCb open_cb, global::libvlc.LibvlcMediaReadCb read_cb, global::libvlc.LibvlcMediaSeekCb seek_cb, global::libvlc.LibvlcMediaCloseCb close_cb, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
            var __arg1 = open_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(open_cb);
            var __arg2 = read_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read_cb);
            var __arg3 = seek_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(seek_cb);
            var __arg4 = close_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(close_cb);
            var __ret = __Internal.LibvlcMediaNewCallbacks(__arg0, __arg1, __arg2, __arg3, __arg4, opaque);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media as an empty node with a given name.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the node</param>
        /// <returns>the new empty media or NULL on error</returns>
        /// <remarks>libvlc_media_release</remarks>
        public static global::libvlc.LibvlcMediaT LibvlcMediaNewAsNode(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewAsNode(__arg0, psz_name);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Add an option to the media.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="psz_options">the options (as a string)</param>
        /// <remarks>
        /// <para>This option will be used to determine how the media_player will</para>
        /// <para>read the media. This allows to use VLC's advanced</para>
        /// <para>reading/streaming options on a per-media basis.</para>
        /// <para>The options are listed in 'vlc --long-help' from the command line,</para>
        /// <para>e.g. &quot;-sout-all&quot;. Keep in mind that available options and their semantics</para>
        /// <para>vary across LibVLC versions and builds.</para>
        /// <para>Not all options affects libvlc_media_t objects:</para>
        /// <para>Specifically, due to architectural issues most audio and video options,</para>
        /// <para>such as text renderer options, have no effects on an individual media.</para>
        /// <para>These options must be set through libvlc_new() instead.</para>
        /// </remarks>
        public static void LibvlcMediaAddOption(global::libvlc.LibvlcMediaT p_md, string psz_options)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaAddOption(__arg0, psz_options);
        }

        /// <summary>Add an option to the media with configurable flags.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="psz_options">the options (as a string)</param>
        /// <param name="i_flags">the flags for this option</param>
        /// <remarks>
        /// <para>This option will be used to determine how the media_player will</para>
        /// <para>read the media. This allows to use VLC's advanced</para>
        /// <para>reading/streaming options on a per-media basis.</para>
        /// <para>The options are detailed in vlc --long-help, for instance</para>
        /// <para>&quot;--sout-all&quot;. Note that all options are not usable on medias:</para>
        /// <para>specifically, due to architectural issues, video-related options</para>
        /// <para>such as text renderer options cannot be set on a single media. They</para>
        /// <para>must be set on the whole libvlc instance instead.</para>
        /// </remarks>
        public static void LibvlcMediaAddOptionFlag(global::libvlc.LibvlcMediaT p_md, string psz_options, uint i_flags)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaAddOptionFlag(__arg0, psz_options, i_flags);
        }

        /// <summary>
        /// <para>Retain a reference to a media descriptor object (libvlc_media_t). Use</para>
        /// <para>libvlc_media_release() to decrement the reference count of a</para>
        /// <para>media descriptor object.</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        public static void LibvlcMediaRetain(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaRetain(__arg0);
        }

        /// <summary>
        /// <para>Decrement the reference count of a media descriptor object. If the</para>
        /// <para>reference count is 0, then libvlc_media_release() will release the</para>
        /// <para>media descriptor object. It will send out an libvlc_MediaFreed event</para>
        /// <para>to all listeners. If the media descriptor object has been released it</para>
        /// <para>should not be used again.</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        public static void LibvlcMediaRelease(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaRelease(__arg0);
        }

        /// <summary>Get the media resource locator (mrl) from a media descriptor object</summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>string with mrl of media descriptor object</returns>
        public static sbyte* LibvlcMediaGetMrl(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetMrl(__arg0);
            return __ret;
        }

        /// <summary>Duplicate a media descriptor object.</summary>
        /// <param name="p_md">a media descriptor object.</param>
        public static global::libvlc.LibvlcMediaT LibvlcMediaDuplicate(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaDuplicate(__arg0);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Read the meta of the media.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="e_meta">the meta to read</param>
        /// <returns>the media's meta</returns>
        /// <remarks>
        /// <para>If the media has not yet been parsed this will return NULL.</para>
        /// <para>libvlc_media_parse</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>libvlc_MediaMetaChanged</para>
        /// </remarks>
        public static sbyte* LibvlcMediaGetMeta(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMetaT e_meta)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetMeta(__arg0, e_meta);
            return __ret;
        }

        /// <summary>
        /// <para>Set the meta of the media (this function will not save the meta, call</para>
        /// <para>libvlc_media_save_meta in order to save the meta)</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="e_meta">the meta to write</param>
        /// <param name="psz_value">the media's meta</param>
        public static void LibvlcMediaSetMeta(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMetaT e_meta, string psz_value)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSetMeta(__arg0, e_meta, psz_value);
        }

        /// <summary>Save the meta previously set</summary>
        /// <param name="p_md">the media desriptor</param>
        /// <returns>true if the write operation was successful</returns>
        public static int LibvlcMediaSaveMeta(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSaveMeta(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get current state of media descriptor object. Possible media states are</para>
        /// <para>libvlc_NothingSpecial=0, libvlc_Opening, libvlc_Playing, libvlc_Paused,</para>
        /// <para>libvlc_Stopped, libvlc_Ended, libvlc_Error.</para>
        /// </summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>state of media descriptor object</returns>
        /// <remarks>libvlc_state_t</remarks>
        public static global::libvlc.LibvlcStateT LibvlcMediaGetState(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetState(__arg0);
            return __ret;
        }

        /// <summary>Get the current statistics about the media</summary>
        /// <param name="p_md:">media descriptor object</param>
        /// <param name="p_stats:">
        /// <para>structure that contain the statistics about the media</para>
        /// <para>(this structure must be allocated by the caller)</para>
        /// </param>
        /// <returns>true if the statistics are available, false otherwise</returns>
        public static int LibvlcMediaGetStats(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaStatsT p_stats)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(p_stats, null) ? global::System.IntPtr.Zero : p_stats.__Instance;
            var __ret = __Internal.LibvlcMediaGetStats(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get subitems of media descriptor object. This will increment</para>
        /// <para>the reference count of supplied media descriptor object. Use</para>
        /// <para>libvlc_media_list_release() to decrement the reference counting.</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>list of media descriptor subitems or NULL</returns>
        public static global::libvlc.LibvlcMediaListT LibvlcMediaSubitems(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSubitems(__arg0);
            global::libvlc.LibvlcMediaListT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaListT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaListT) global::libvlc.LibvlcMediaListT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaListT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get event manager from media descriptor object.</para>
        /// <para>NOTE: this function doesn't increment reference counting.</para>
        /// </summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>event manager object</returns>
        public static global::libvlc.LibvlcEventManagerT LibvlcMediaEventManager(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get duration (in ms) of media descriptor object item.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>duration of media item or -1 on error</returns>
        public static long LibvlcMediaGetDuration(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetDuration(__arg0);
            return __ret;
        }

        /// <summary>Parse the media asynchronously with options.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="parse_flag">parse options:</param>
        /// <param name="timeout">
        /// <para>maximum time allowed to preparse the media. If -1, the</para>
        /// <para>default &quot;preparse-timeout&quot; option will be used as a timeout. If 0, it will</para>
        /// <para>wait indefinitely. If &gt; 0, the timeout will be used (in milliseconds).</para>
        /// </param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>This fetches (local or network) art, meta data and/or tracks information.</para>
        /// <para>This method is the extended version of libvlc_media_parse_with_options().</para>
        /// <para>To track when this is over you can listen to libvlc_MediaParsedChanged</para>
        /// <para>event. However if this functions returns an error, you will not receive any</para>
        /// <para>events.</para>
        /// <para>It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All</para>
        /// <para>these flags can be combined. By default, media is parsed if it's a local</para>
        /// <para>file.</para>
        /// <para>Parsing can be aborted with libvlc_media_parse_stop().</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_tracks_get</para>
        /// <para>libvlc_media_get_parsed_status</para>
        /// <para>libvlc_media_parse_flag_t</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaParseWithOptions(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaParseFlagT parse_flag, int timeout)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaParseWithOptions(__arg0, parse_flag, timeout);
            return __ret;
        }

        /// <summary>Stop the parsing of the media</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>When the media parsing is stopped, the libvlc_MediaParsedChanged event will</para>
        /// <para>be sent with the libvlc_media_parsed_status_timeout status.</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcMediaParseStop(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParseStop(__arg0);
        }

        /// <summary>Get Parsed status for media descriptor object.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>a value of the libvlc_media_parsed_status_t enum</returns>
        /// <remarks>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_parsed_status_t</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaParsedStatusT LibvlcMediaGetParsedStatus(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetParsedStatus(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets media descriptor's user_data. user_data is specialized data</para>
        /// <para>accessed by the host application, VLC.framework uses it as a pointer to</para>
        /// <para>an native object that references a libvlc_media_t pointer</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="p_new_user_data">pointer to user data</param>
        public static void LibvlcMediaSetUserData(global::libvlc.LibvlcMediaT p_md, global::System.IntPtr p_new_user_data)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSetUserData(__arg0, p_new_user_data);
        }

        /// <summary>
        /// <para>Get media descriptor's user_data. user_data is specialized data</para>
        /// <para>accessed by the host application, VLC.framework uses it as a pointer to</para>
        /// <para>an native object that references a libvlc_media_t pointer</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        public static global::System.IntPtr LibvlcMediaGetUserData(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetUserData(__arg0);
            return __ret;
        }

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed with libvlc_media_tracks_release</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams (zero on error)</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>LibVLC 2.1.0 and later.</para>
        /// </remarks>
        public static uint LibvlcMediaTracksGet(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaTrackT tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaTracksGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get codec description from media elementary stream</summary>
        /// <param name="i_type">i_type from libvlc_media_track_t</param>
        /// <param name="i_codec">i_codec or i_original_fourcc from libvlc_media_track_t</param>
        /// <returns>codec description</returns>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_track_t</para>
        /// </remarks>
        public static string LibvlcMediaGetCodecDescription(global::libvlc.LibvlcTrackTypeT i_type, uint i_codec)
        {
            var __ret = __Internal.LibvlcMediaGetCodecDescription(i_type, i_codec);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Release media descriptor's elementary streams description array</summary>
        /// <param name="p_tracks">tracks info array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>LibVLC 2.1.0 and later.</remarks>
        public static void LibvlcMediaTracksRelease(global::libvlc.LibvlcMediaTrackT p_tracks, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_tracks, null) ? global::System.IntPtr.Zero : p_tracks.__Instance;
            __Internal.LibvlcMediaTracksRelease(__arg0, i_count);
        }

        /// <summary>Get the media type of the media descriptor object</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>media type</returns>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_type_t</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaTypeT LibvlcMediaGetType(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetType(__arg0);
            return __ret;
        }

        /// <summary>Add a slave to the current media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="i_type">subtitle or audio</param>
        /// <param name="i_priority">from 0 (low priority) to 4 (high priority)</param>
        /// <param name="psz_uri">Uri of the slave (should contain a valid scheme).</param>
        /// <returns>0 on success, -1 on error.</returns>
        /// <remarks>
        /// <para>A slave is an external input source that may contains an additional subtitle</para>
        /// <para>track (like a .srt) or an additional audio track (like a .ac3).</para>
        /// <para>This function must be called before the media is parsed (via</para>
        /// <para>libvlc_media_parse_with_options()) or before the media is played (via</para>
        /// <para>libvlc_media_player_play())</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcMediaSlavesAdd(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaSlaveTypeT i_type, uint i_priority, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSlavesAdd(__arg0, i_type, i_priority, psz_uri);
            return __ret;
        }

        /// <summary>
        /// <para>Clear all slaves previously added by libvlc_media_slaves_add() or</para>
        /// <para>internally.</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaSlavesClear(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSlavesClear(__arg0);
        }

        /// <summary>Get a media descriptor's slave list</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="ppp_slaves">
        /// <para>address to store an allocated array of slaves (must be</para>
        /// <para>freed with libvlc_media_slaves_release()) [OUT]</para>
        /// </param>
        /// <returns>the number of slaves (zero on error)</returns>
        /// <remarks>
        /// <para>The list will contain slaves parsed by VLC or previously added by</para>
        /// <para>libvlc_media_slaves_add(). The typical use case of this function is to save</para>
        /// <para>a list of slave in a database for a later use.</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_slaves_add</para>
        /// </remarks>
        public static uint LibvlcMediaSlavesGet(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaSlaveT ppp_slaves)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(ppp_slaves, null) ? global::System.IntPtr.Zero : ppp_slaves.__Instance;
            var __ret = __Internal.LibvlcMediaSlavesGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release a media descriptor's slave list</summary>
        /// <param name="pp_slaves">slave array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaSlavesRelease(global::libvlc.LibvlcMediaSlaveT pp_slaves, uint i_count)
        {
            var __arg0 = ReferenceEquals(pp_slaves, null) ? global::System.IntPtr.Zero : pp_slaves.__Instance;
            __Internal.LibvlcMediaSlavesRelease(__arg0, i_count);
        }
    }

    /// <summary>Description for titles</summary>
    public enum LibvlcTitle
    {
        LibvlcTitleMenu = 1,
        LibvlcTitleInteractive = 2
    }

    /// <summary>Marq options definition</summary>
    public enum LibvlcVideoMarqueeOptionT
    {
        LibvlcMarqueeEnable = 0,
        LibvlcMarqueeText = 1,
        /// <summary>string argument</summary>
        LibvlcMarqueeColor = 2,
        /// <summary>string argument</summary>
        LibvlcMarqueeOpacity = 3,
        /// <summary>string argument</summary>
        LibvlcMarqueePosition = 4,
        /// <summary>string argument</summary>
        LibvlcMarqueeRefresh = 5,
        /// <summary>string argument</summary>
        LibvlcMarqueeSize = 6,
        /// <summary>string argument</summary>
        LibvlcMarqueeTimeout = 7,
        /// <summary>string argument</summary>
        LibvlcMarqueeX = 8,
        /// <summary>string argument</summary>
        LibvlcMarqueeY = 9
    }

    /// <summary>Navigation mode</summary>
    public enum LibvlcNavigateModeT
    {
        LibvlcNavigateActivate = 0,
        LibvlcNavigateUp = 1,
        LibvlcNavigateDown = 2,
        LibvlcNavigateLeft = 3,
        LibvlcNavigateRight = 4,
        LibvlcNavigatePopup = 5
    }

    /// <summary>Enumeration of values used to set position (e.g. of video title).</summary>
    public enum LibvlcPositionT
    {
        LibvlcPositionDisable = -1,
        LibvlcPositionCenter = 0,
        LibvlcPositionLeft = 1,
        LibvlcPositionRight = 2,
        LibvlcPositionTop = 3,
        LibvlcPositionTopLeft = 4,
        LibvlcPositionTopRight = 5,
        LibvlcPositionBottom = 6,
        LibvlcPositionBottomLeft = 7,
        LibvlcPositionBottomRight = 8
    }

    /// <summary>
    /// <para>Enumeration of teletext keys than can be passed via</para>
    /// <para>libvlc_video_set_teletext()</para>
    /// </summary>
    public enum LibvlcTeletextKeyT
    {
        LibvlcTeletextKeyRed = 7471104,
        LibvlcTeletextKeyGreen = 6750208,
        LibvlcTeletextKeyYellow = 7929856,
        LibvlcTeletextKeyBlue = 6422528,
        LibvlcTeletextKeyIndex = 6881280
    }

    /// <summary>option values for libvlc_video_{get,set}_logo_{int,string}</summary>
    public enum LibvlcVideoLogoOptionT
    {
        LibvlcLogoEnable = 0,
        /// <summary>string argument, &quot;file,d,t;file,d,t;...&quot;</summary>
        LibvlcLogoFile = 1,
        LibvlcLogoX = 2,
        LibvlcLogoY = 3,
        LibvlcLogoDelay = 4,
        LibvlcLogoRepeat = 5,
        LibvlcLogoOpacity = 6,
        LibvlcLogoPosition = 7
    }

    /// <summary>option values for libvlc_video_{get,set}_adjust_{int,float,bool}</summary>
    public enum LibvlcVideoAdjustOptionT
    {
        LibvlcAdjustEnable = 0,
        LibvlcAdjustContrast = 1,
        LibvlcAdjustBrightness = 2,
        LibvlcAdjustHue = 3,
        LibvlcAdjustSaturation = 4,
        LibvlcAdjustGamma = 5
    }

    /// <summary>Audio device types</summary>
    public enum LibvlcAudioOutputDeviceTypesT
    {
        LibvlcAudioOutputDeviceError = -1,
        LibvlcAudioOutputDeviceMono = 1,
        LibvlcAudioOutputDeviceStereo = 2,
        LibvlcAudioOutputDevice2F2R = 4,
        LibvlcAudioOutputDevice3F2R = 5,
        LibvlcAudioOutputDevice5_1 = 6,
        LibvlcAudioOutputDevice6_1 = 7,
        LibvlcAudioOutputDevice7_1 = 8,
        LibvlcAudioOutputDeviceSPDIF = 10
    }

    /// <summary>Audio channels</summary>
    public enum LibvlcAudioOutputChannelT
    {
        LibvlcAudioChannelError = -1,
        LibvlcAudioChannelStereo = 1,
        LibvlcAudioChannelRStereo = 2,
        LibvlcAudioChannelLeft = 3,
        LibvlcAudioChannelRight = 4,
        LibvlcAudioChannelDolbys = 5
    }

    /// <summary>Media player roles.</summary>
    /// <remarks>
    /// <para>LibVLC 3.0.0 and later.</para>
    /// <para>See</para>
    /// </remarks>
    public enum LibvlcMediaPlayerRole
    {
        /// <summary>Don't use a media player role</summary>
        LibvlcRoleNone = 0,
        /// <summary>Music (or radio) playback</summary>
        LibvlcRoleMusic = 1,
        /// <summary>Video playback</summary>
        LibvlcRoleVideo = 2,
        /// <summary>Speech, real-time communication</summary>
        LibvlcRoleCommunication = 3,
        /// <summary>Video game</summary>
        LibvlcRoleGame = 4,
        /// <summary>User interaction feedback</summary>
        LiblvcRoleNotification = 5,
        /// <summary>Embedded animation (e.g. in web page)</summary>
        LibvlcRoleAnimation = 6,
        /// <summary>Audio editting/production</summary>
        LibvlcRoleProduction = 7,
        /// <summary>Accessibility</summary>
        LibvlcRoleAccessibility = 8,
        LibvlcRoleTest = 9
    }

    /// <summary>
    /// <para>A LibVLC media player plays one media (usually in a custom drawable).</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC simple media player external API</para>
    /// </summary>
    /// <summary>Opaque equalizer handle.</summary>
    /// <remarks>Equalizer settings can be applied to a media player.</remarks>
    /// <summary>Callback prototype to allocate and lock a picture buffer.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="planes">
    /// <para>start address of the pixel planes (LibVLC allocates the array</para>
    /// <para>of void pointers, this callback must initialize the array) [OUT]</para>
    /// </param>
    /// <returns>
    /// <para>a private pointer for the display and unlock callbacks to identify</para>
    /// <para>the picture buffers</para>
    /// </returns>
    /// <remarks>
    /// <para>Whenever a new video frame needs to be decoded, the lock callback is</para>
    /// <para>invoked. Depending on the video chroma, one or three pixel planes of</para>
    /// <para>adequate dimensions must be returned via the second parameter. Those</para>
    /// <para>planes must be aligned on 32-bytes boundaries.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr LibvlcVideoLockCb(global::System.IntPtr opaque, void** planes);

    /// <summary>Callback prototype to unlock a picture buffer.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="picture">private pointer returned from the</param>
    /// <param name="planes">pixel planes as defined by the</param>
    /// <remarks>
    /// <para>When the video frame decoding is complete, the unlock callback is invoked.</para>
    /// <para>This callback might not be needed at all. It is only an indication that the</para>
    /// <para>application can now read the pixel values if it needs to.</para>
    /// <para>A picture buffer is unlocked after the picture is decoded,</para>
    /// <para>but before the picture is displayed.</para>
    /// <para>callback [IN]</para>
    /// <para>callback (this parameter is only for convenience) [IN]</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoUnlockCb(global::System.IntPtr opaque, global::System.IntPtr picture, void** planes);

    /// <summary>Callback prototype to display a picture.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="picture">private pointer returned from the</param>
    /// <remarks>
    /// <para>When the video frame needs to be shown, as determined by the media playback</para>
    /// <para>clock, the display callback is invoked.</para>
    /// <para>callback [IN]</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoDisplayCb(global::System.IntPtr opaque, global::System.IntPtr picture);

    /// <summary>
    /// <para>Callback prototype to configure picture buffers format.</para>
    /// <para>This callback gets the format of the video as output by the video decoder</para>
    /// <para>and the chain of video filters (if any). It can opt to change any parameter</para>
    /// <para>as it needs. In that case, LibVLC will attempt to convert the video format</para>
    /// <para>(rescaling and chroma conversion) but these operations can be CPU intensive.</para>
    /// </summary>
    /// <param name="opaque">
    /// <para>pointer to the private pointer passed to</para>
    /// <para>libvlc_video_set_callbacks() [IN/OUT]</para>
    /// </param>
    /// <param name="chroma">pointer to the 4 bytes video format identifier [IN/OUT]</param>
    /// <param name="width">pointer to the pixel width [IN/OUT]</param>
    /// <param name="height">pointer to the pixel height [IN/OUT]</param>
    /// <param name="pitches">
    /// <para>table of scanline pitches in bytes for each pixel plane</para>
    /// <para>(the table is allocated by LibVLC) [OUT]</para>
    /// </param>
    /// <param name="lines">table of scanlines count for each plane [OUT]</param>
    /// <returns>the number of picture buffers allocated, 0 indicates failure</returns>
    /// <remarks>
    /// <para>For each pixels plane, the scanline pitch must be bigger than or equal to</para>
    /// <para>the number of bytes per pixel multiplied by the pixel width.</para>
    /// <para>Similarly, the number of scanlines must be bigger than of equal to</para>
    /// <para>the pixel height.</para>
    /// <para>Furthermore, we recommend that pitches and lines be multiple of 32</para>
    /// <para>to not break assumptions that might be held by optimized code</para>
    /// <para>in the video decoders, video filters and/or video converters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate uint LibvlcVideoFormatCb(void** opaque, sbyte* chroma, uint* width, uint* height, uint* pitches, uint* lines);

    /// <summary>Callback prototype to configure picture buffers format.</summary>
    /// <param name="opaque">
    /// <para>private pointer as passed to libvlc_video_set_callbacks()</para>
    /// <para>(and possibly modified by</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoCleanupCb(global::System.IntPtr opaque);

    /// <summary>Callback prototype for audio playback.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="samples">pointer to a table of audio samples to play back [IN]</param>
    /// <param name="count">number of audio samples to play back</param>
    /// <param name="pts">expected play time stamp (see libvlc_delay())</param>
    /// <remarks>
    /// <para>The LibVLC media player decodes and post-processes the audio signal</para>
    /// <para>asynchronously (in an internal thread). Whenever audio samples are ready</para>
    /// <para>to be queued to the output, this callback is invoked.</para>
    /// <para>The number of samples provided per invocation may depend on the file format,</para>
    /// <para>the audio coding algorithm, the decoder plug-in, the post-processing</para>
    /// <para>filters and timing. Application must not assume a certain number of samples.</para>
    /// <para>The exact format of audio samples is determined by libvlc_audio_set_format()</para>
    /// <para>or libvlc_audio_set_format_callbacks() as is the channels layout.</para>
    /// <para>Note that the number of samples is per channel. For instance, if the audio</para>
    /// <para>track sampling rate is 48000&#160;Hz, then 1200&#160;samples represent 25&#160;milliseconds</para>
    /// <para>of audio signal - regardless of the number of audio channels.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioPlayCb(global::System.IntPtr data, global::System.IntPtr samples, uint count, long pts);

    /// <summary>Callback prototype for audio pause.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="pts">time stamp of the pause request (should be elapsed already)</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback to pause audio playback.</para>
    /// <para>The pause callback is never called if the audio is already paused.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioPauseCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio resumption.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="pts">time stamp of the resumption request (should be elapsed already)</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback to resume audio playback after it was</para>
    /// <para>previously paused.</para>
    /// <para>The resume callback is never called if the audio is not paused.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioResumeCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio buffer flush.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback if it needs to discard all pending buffers and</para>
    /// <para>stop playback as soon as possible. This typically occurs when the media is</para>
    /// <para>stopped.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioFlushCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio buffer drain.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>
    /// <para>LibVLC may invoke this callback when the decoded audio track is ending.</para>
    /// <para>There will be no further decoded samples for the track, but playback should</para>
    /// <para>nevertheless continue until all already pending buffers are rendered.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioDrainCb(global::System.IntPtr data);

    /// <summary>Callback prototype for audio volume change.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="volume">software volume (1. = nominal, 0. = mute)</param>
    /// <param name="mute">muted flag</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioSetVolumeCb(global::System.IntPtr data, float volume, [MarshalAs(UnmanagedType.I1)] bool mute);

    /// <summary>Callback prototype to setup the audio playback.</summary>
    /// <param name="opaque">
    /// <para>pointer to the data pointer passed to</para>
    /// <para>libvlc_audio_set_callbacks() [IN/OUT]</para>
    /// </param>
    /// <param name="format">4 bytes sample format [IN/OUT]</param>
    /// <param name="rate">sample rate [IN/OUT]</param>
    /// <param name="channels">channels count [IN/OUT]</param>
    /// <returns>0 on success, anything else to skip audio playback</returns>
    /// <remarks>This is called when the media player needs to create a new audio output.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcAudioSetupCb(void** data, sbyte* format, uint* rate, uint* channels);

    /// <summary>Callback prototype for audio playback cleanup.</summary>
    /// <param name="opaque">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>This is called when the media player no longer needs an audio output.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioCleanupCb(global::System.IntPtr data);

    public unsafe partial class LibvlcMediaPlayerT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaPlayerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaPlayerT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaPlayerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaPlayerT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaPlayerT __CreateInstance(global::libvlc.LibvlcMediaPlayerT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaPlayerT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaPlayerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaPlayerT.__Internal));
            *(global::libvlc.LibvlcMediaPlayerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaPlayerT(global::libvlc.LibvlcMediaPlayerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaPlayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcEqualizerT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcEqualizerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcEqualizerT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcEqualizerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcEqualizerT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcEqualizerT __CreateInstance(global::libvlc.LibvlcEqualizerT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcEqualizerT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcEqualizerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcEqualizerT.__Internal));
            *(global::libvlc.LibvlcEqualizerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcEqualizerT(global::libvlc.LibvlcEqualizerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcEqualizerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>
    /// <para>Description for video, audio tracks and subtitles. It contains</para>
    /// <para>id, name (description string) and pointer to next record.</para>
    /// </summary>
    public unsafe partial class LibvlcTrackDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_id;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal global::System.IntPtr p_next;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcTrackDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcTrackDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcTrackDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcTrackDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcTrackDescriptionT __CreateInstance(global::libvlc.LibvlcTrackDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcTrackDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcTrackDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcTrackDescriptionT.__Internal));
            *(global::libvlc.LibvlcTrackDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcTrackDescriptionT(global::libvlc.LibvlcTrackDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcTrackDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcTrackDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int IId
        {
            get
            {
                return ((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->i_id = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public global::libvlc.LibvlcTrackDescriptionT PNext
        {
            get
            {
                global::libvlc.LibvlcTrackDescriptionT __result0;
                if (((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlc.LibvlcTrackDescriptionT.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LibvlcTitleDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_duration;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal uint i_flags;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcTitleDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcTitleDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcTitleDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcTitleDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcTitleDescriptionT __CreateInstance(global::libvlc.LibvlcTitleDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcTitleDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcTitleDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcTitleDescriptionT.__Internal));
            *(global::libvlc.LibvlcTitleDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcTitleDescriptionT(global::libvlc.LibvlcTitleDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcTitleDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcTitleDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long IDuration
        {
            get
            {
                return ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public uint IFlags
        {
            get
            {
                return ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->i_flags;
            }

            set
            {
                ((global::libvlc.LibvlcTitleDescriptionT.__Internal*) __Instance)->i_flags = value;
            }
        }
    }

    /// <summary>Description for chapters</summary>
    public unsafe partial class LibvlcChapterDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_time_offset;

            [FieldOffset(8)]
            internal long i_duration;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcChapterDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcChapterDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcChapterDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcChapterDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcChapterDescriptionT __CreateInstance(global::libvlc.LibvlcChapterDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcChapterDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcChapterDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcChapterDescriptionT.__Internal));
            *(global::libvlc.LibvlcChapterDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcChapterDescriptionT(global::libvlc.LibvlcChapterDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcChapterDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcChapterDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long ITimeOffset
        {
            get
            {
                return ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->i_time_offset;
            }

            set
            {
                ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->i_time_offset = value;
            }
        }

        public long IDuration
        {
            get
            {
                return ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcChapterDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>Description for audio output. It contains</para>
    /// <para>name, description and pointer to next record.</para>
    /// </summary>
    public unsafe partial class LibvlcAudioOutputT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_description;

            [FieldOffset(16)]
            internal global::System.IntPtr p_next;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioOutputT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioOutputT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcAudioOutputT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioOutputT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcAudioOutputT __CreateInstance(global::libvlc.LibvlcAudioOutputT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioOutputT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcAudioOutputT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcAudioOutputT.__Internal));
            *(global::libvlc.LibvlcAudioOutputT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcAudioOutputT(global::libvlc.LibvlcAudioOutputT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcAudioOutputT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcAudioOutputT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }

        public global::libvlc.LibvlcAudioOutputT PNext
        {
            get
            {
                global::libvlc.LibvlcAudioOutputT __result0;
                if (((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlc.LibvlcAudioOutputT.NativeToManagedMap.ContainsKey(((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlc.LibvlcAudioOutputT) global::libvlc.LibvlcAudioOutputT.NativeToManagedMap[((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlc.LibvlcAudioOutputT.__CreateInstance(((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputT.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Description for audio output device.</summary>
    public unsafe partial class LibvlcAudioOutputDeviceT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr p_next;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_device;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_description;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioOutputDeviceT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcAudioOutputDeviceT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcAudioOutputDeviceT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioOutputDeviceT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcAudioOutputDeviceT __CreateInstance(global::libvlc.LibvlcAudioOutputDeviceT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcAudioOutputDeviceT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcAudioOutputDeviceT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcAudioOutputDeviceT.__Internal));
            *(global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcAudioOutputDeviceT(global::libvlc.LibvlcAudioOutputDeviceT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcAudioOutputDeviceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcAudioOutputDeviceT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::libvlc.LibvlcAudioOutputDeviceT PNext
        {
            get
            {
                global::libvlc.LibvlcAudioOutputDeviceT __result0;
                if (((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap.ContainsKey(((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlc.LibvlcAudioOutputDeviceT) global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap[((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlc.LibvlcAudioOutputDeviceT.__CreateInstance(((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte* PszDevice
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->psz_device;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->psz_device = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlc.LibvlcAudioOutputDeviceT.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>Viewpoint for video outputs</summary>
    /// <remarks>allocate using libvlc_video_new_viewpoint()</remarks>
    public unsafe partial class LibvlcVideoViewpointT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float f_yaw;

            [FieldOffset(4)]
            internal float f_pitch;

            [FieldOffset(8)]
            internal float f_roll;

            [FieldOffset(12)]
            internal float f_field_of_view;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcVideoViewpointT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcVideoViewpointT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcVideoViewpointT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcVideoViewpointT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcVideoViewpointT __CreateInstance(global::libvlc.LibvlcVideoViewpointT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcVideoViewpointT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcVideoViewpointT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcVideoViewpointT.__Internal));
            *(global::libvlc.LibvlcVideoViewpointT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcVideoViewpointT(global::libvlc.LibvlcVideoViewpointT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcVideoViewpointT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcVideoViewpointT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FYaw
        {
            get
            {
                return ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_yaw;
            }

            set
            {
                ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_yaw = value;
            }
        }

        public float FPitch
        {
            get
            {
                return ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_pitch;
            }

            set
            {
                ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_pitch = value;
            }
        }

        public float FRoll
        {
            get
            {
                return ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_roll;
            }

            set
            {
                ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_roll = value;
            }
        }

        public float FFieldOfView
        {
            get
            {
                return ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_field_of_view;
            }

            set
            {
                ((global::libvlc.LibvlcVideoViewpointT.__Internal*) __Instance)->f_field_of_view = value;
            }
        }
    }

    public unsafe partial class libvlc_media_player
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_new")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerNew(global::System.IntPtr p_libvlc_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_new_from_media")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerNewFromMedia(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_release")]
            internal static extern void LibvlcMediaPlayerRelease(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_retain")]
            internal static extern void LibvlcMediaPlayerRetain(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_media")]
            internal static extern void LibvlcMediaPlayerSetMedia(global::System.IntPtr p_mi, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_media")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetMedia(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerEventManager(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_is_playing")]
            internal static extern int LibvlcMediaPlayerIsPlaying(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_play")]
            internal static extern int LibvlcMediaPlayerPlay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_pause")]
            internal static extern void LibvlcMediaPlayerSetPause(global::System.IntPtr mp, int do_pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_pause")]
            internal static extern void LibvlcMediaPlayerPause(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_stop")]
            internal static extern void LibvlcMediaPlayerStop(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_callbacks")]
            internal static extern void LibvlcVideoSetCallbacks(global::System.IntPtr mp, global::System.IntPtr @lock, global::System.IntPtr unlock, global::System.IntPtr display, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_format")]
            internal static extern void LibvlcVideoSetFormat(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string chroma, uint width, uint height, uint pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_format_callbacks")]
            internal static extern void LibvlcVideoSetFormatCallbacks(global::System.IntPtr mp, global::System.IntPtr setup, global::System.IntPtr cleanup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_nsobject")]
            internal static extern void LibvlcMediaPlayerSetNsobject(global::System.IntPtr p_mi, global::System.IntPtr drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_nsobject")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetNsobject(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_xwindow")]
            internal static extern void LibvlcMediaPlayerSetXwindow(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_xwindow")]
            internal static extern uint LibvlcMediaPlayerGetXwindow(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_hwnd")]
            internal static extern void LibvlcMediaPlayerSetHwnd(global::System.IntPtr p_mi, global::System.IntPtr drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_hwnd")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetHwnd(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_android_context")]
            internal static extern void LibvlcMediaPlayerSetAndroidContext(global::System.IntPtr p_mi, global::System.IntPtr p_awindow_handler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_evas_object")]
            internal static extern int LibvlcMediaPlayerSetEvasObject(global::System.IntPtr p_mi, global::System.IntPtr p_evas_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_callbacks")]
            internal static extern void LibvlcAudioSetCallbacks(global::System.IntPtr mp, global::System.IntPtr play, global::System.IntPtr pause, global::System.IntPtr resume, global::System.IntPtr flush, global::System.IntPtr drain, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_volume_callback")]
            internal static extern void LibvlcAudioSetVolumeCallback(global::System.IntPtr mp, global::System.IntPtr set_volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_format_callbacks")]
            internal static extern void LibvlcAudioSetFormatCallbacks(global::System.IntPtr mp, global::System.IntPtr setup, global::System.IntPtr cleanup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_format")]
            internal static extern void LibvlcAudioSetFormat(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string format, uint rate, uint channels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_length")]
            internal static extern long LibvlcMediaPlayerGetLength(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_time")]
            internal static extern long LibvlcMediaPlayerGetTime(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_time")]
            internal static extern void LibvlcMediaPlayerSetTime(global::System.IntPtr p_mi, long i_time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_position")]
            internal static extern float LibvlcMediaPlayerGetPosition(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_position")]
            internal static extern void LibvlcMediaPlayerSetPosition(global::System.IntPtr p_mi, float f_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_chapter")]
            internal static extern void LibvlcMediaPlayerSetChapter(global::System.IntPtr p_mi, int i_chapter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter")]
            internal static extern int LibvlcMediaPlayerGetChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter_count")]
            internal static extern int LibvlcMediaPlayerGetChapterCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_will_play")]
            internal static extern int LibvlcMediaPlayerWillPlay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter_count_for_title")]
            internal static extern int LibvlcMediaPlayerGetChapterCountForTitle(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_title")]
            internal static extern void LibvlcMediaPlayerSetTitle(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_title")]
            internal static extern int LibvlcMediaPlayerGetTitle(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_title_count")]
            internal static extern int LibvlcMediaPlayerGetTitleCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_previous_chapter")]
            internal static extern void LibvlcMediaPlayerPreviousChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_next_chapter")]
            internal static extern void LibvlcMediaPlayerNextChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_rate")]
            internal static extern float LibvlcMediaPlayerGetRate(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_rate")]
            internal static extern int LibvlcMediaPlayerSetRate(global::System.IntPtr p_mi, float rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_state")]
            internal static extern global::libvlc.LibvlcStateT LibvlcMediaPlayerGetState(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_has_vout")]
            internal static extern uint LibvlcMediaPlayerHasVout(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_is_seekable")]
            internal static extern int LibvlcMediaPlayerIsSeekable(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_can_pause")]
            internal static extern int LibvlcMediaPlayerCanPause(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_program_scrambled")]
            internal static extern int LibvlcMediaPlayerProgramScrambled(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_next_frame")]
            internal static extern void LibvlcMediaPlayerNextFrame(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_navigate")]
            internal static extern void LibvlcMediaPlayerNavigate(global::System.IntPtr p_mi, uint navigate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_video_title_display")]
            internal static extern void LibvlcMediaPlayerSetVideoTitleDisplay(global::System.IntPtr p_mi, global::libvlc.LibvlcPositionT position, uint timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_add_slave")]
            internal static extern int LibvlcMediaPlayerAddSlave(global::System.IntPtr p_mi, global::libvlc.LibvlcMediaSlaveTypeT i_type, [MarshalAs(UnmanagedType.LPStr)] string psz_uri, bool b_select);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_track_description_list_release")]
            internal static extern void LibvlcTrackDescriptionListRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_toggle_fullscreen")]
            internal static extern void LibvlcToggleFullscreen(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_fullscreen")]
            internal static extern void LibvlcSetFullscreen(global::System.IntPtr p_mi, int b_fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_fullscreen")]
            internal static extern int LibvlcGetFullscreen(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_key_input")]
            internal static extern void LibvlcVideoSetKeyInput(global::System.IntPtr p_mi, uint on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_mouse_input")]
            internal static extern void LibvlcVideoSetMouseInput(global::System.IntPtr p_mi, uint on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_size")]
            internal static extern int LibvlcVideoGetSize(global::System.IntPtr p_mi, uint num, uint* px, uint* py);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_cursor")]
            internal static extern int LibvlcVideoGetCursor(global::System.IntPtr p_mi, uint num, int* px, int* py);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_scale")]
            internal static extern float LibvlcVideoGetScale(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_scale")]
            internal static extern void LibvlcVideoSetScale(global::System.IntPtr p_mi, float f_factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_aspect_ratio")]
            internal static extern sbyte* LibvlcVideoGetAspectRatio(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_aspect_ratio")]
            internal static extern void LibvlcVideoSetAspectRatio(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_aspect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_new_viewpoint")]
            internal static extern global::System.IntPtr LibvlcVideoNewViewpoint();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_update_viewpoint")]
            internal static extern int LibvlcVideoUpdateViewpoint(global::System.IntPtr p_mi, global::System.IntPtr p_viewpoint, bool b_absolute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu")]
            internal static extern int LibvlcVideoGetSpu(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_count")]
            internal static extern int LibvlcVideoGetSpuCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetSpuDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_spu")]
            internal static extern int LibvlcVideoSetSpu(global::System.IntPtr p_mi, int i_spu);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_delay")]
            internal static extern long LibvlcVideoGetSpuDelay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_spu_delay")]
            internal static extern int LibvlcVideoSetSpuDelay(global::System.IntPtr p_mi, long i_delay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_full_title_descriptions")]
            internal static extern int LibvlcMediaPlayerGetFullTitleDescriptions(global::System.IntPtr p_mi, global::System.IntPtr titles);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_title_descriptions_release")]
            internal static extern void LibvlcTitleDescriptionsRelease(global::System.IntPtr p_titles, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_full_chapter_descriptions")]
            internal static extern int LibvlcMediaPlayerGetFullChapterDescriptions(global::System.IntPtr p_mi, int i_chapters_of_title, global::System.IntPtr pp_chapters);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_chapter_descriptions_release")]
            internal static extern void LibvlcChapterDescriptionsRelease(global::System.IntPtr p_chapters, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_crop_geometry")]
            internal static extern sbyte* LibvlcVideoGetCropGeometry(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_crop_geometry")]
            internal static extern void LibvlcVideoSetCropGeometry(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_geometry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_teletext")]
            internal static extern int LibvlcVideoGetTeletext(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_teletext")]
            internal static extern void LibvlcVideoSetTeletext(global::System.IntPtr p_mi, int i_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track_count")]
            internal static extern int LibvlcVideoGetTrackCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetTrackDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track")]
            internal static extern int LibvlcVideoGetTrack(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_track")]
            internal static extern int LibvlcVideoSetTrack(global::System.IntPtr p_mi, int i_track);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_take_snapshot")]
            internal static extern int LibvlcVideoTakeSnapshot(global::System.IntPtr p_mi, uint num, [MarshalAs(UnmanagedType.LPStr)] string psz_filepath, uint i_width, uint i_height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_deinterlace")]
            internal static extern void LibvlcVideoSetDeinterlace(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_marquee_int")]
            internal static extern int LibvlcVideoGetMarqueeInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_marquee_string")]
            internal static extern sbyte* LibvlcVideoGetMarqueeString(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_marquee_int")]
            internal static extern void LibvlcVideoSetMarqueeInt(global::System.IntPtr p_mi, uint option, int i_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_marquee_string")]
            internal static extern void LibvlcVideoSetMarqueeString(global::System.IntPtr p_mi, uint option, [MarshalAs(UnmanagedType.LPStr)] string psz_text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_logo_int")]
            internal static extern int LibvlcVideoGetLogoInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_logo_int")]
            internal static extern void LibvlcVideoSetLogoInt(global::System.IntPtr p_mi, uint option, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_logo_string")]
            internal static extern void LibvlcVideoSetLogoString(global::System.IntPtr p_mi, uint option, [MarshalAs(UnmanagedType.LPStr)] string psz_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_adjust_int")]
            internal static extern int LibvlcVideoGetAdjustInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_adjust_int")]
            internal static extern void LibvlcVideoSetAdjustInt(global::System.IntPtr p_mi, uint option, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_adjust_float")]
            internal static extern float LibvlcVideoGetAdjustFloat(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_adjust_float")]
            internal static extern void LibvlcVideoSetAdjustFloat(global::System.IntPtr p_mi, uint option, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioOutputListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_list_release")]
            internal static extern void LibvlcAudioOutputListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_set")]
            internal static extern int LibvlcAudioOutputSet(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_enum")]
            internal static extern global::System.IntPtr LibvlcAudioOutputDeviceEnum(global::System.IntPtr mp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioOutputDeviceListGet(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string aout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_list_release")]
            internal static extern void LibvlcAudioOutputDeviceListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_set")]
            internal static extern void LibvlcAudioOutputDeviceSet(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string module, [MarshalAs(UnmanagedType.LPStr)] string device_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_get")]
            internal static extern sbyte* LibvlcAudioOutputDeviceGet(global::System.IntPtr mp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_toggle_mute")]
            internal static extern void LibvlcAudioToggleMute(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_mute")]
            internal static extern int LibvlcAudioGetMute(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_mute")]
            internal static extern void LibvlcAudioSetMute(global::System.IntPtr p_mi, int status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_volume")]
            internal static extern int LibvlcAudioGetVolume(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_volume")]
            internal static extern int LibvlcAudioSetVolume(global::System.IntPtr p_mi, int i_volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track_count")]
            internal static extern int LibvlcAudioGetTrackCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track_description")]
            internal static extern global::System.IntPtr LibvlcAudioGetTrackDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track")]
            internal static extern int LibvlcAudioGetTrack(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_track")]
            internal static extern int LibvlcAudioSetTrack(global::System.IntPtr p_mi, int i_track);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_channel")]
            internal static extern int LibvlcAudioGetChannel(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_channel")]
            internal static extern int LibvlcAudioSetChannel(global::System.IntPtr p_mi, int channel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_delay")]
            internal static extern long LibvlcAudioGetDelay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_delay")]
            internal static extern int LibvlcAudioSetDelay(global::System.IntPtr p_mi, long i_delay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preset_count")]
            internal static extern uint LibvlcAudioEqualizerGetPresetCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preset_name")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerGetPresetName(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_band_count")]
            internal static extern uint LibvlcAudioEqualizerGetBandCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_band_frequency")]
            internal static extern float LibvlcAudioEqualizerGetBandFrequency(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_new")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerNew();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_new_from_preset")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerNewFromPreset(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_release")]
            internal static extern void LibvlcAudioEqualizerRelease(global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_set_preamp")]
            internal static extern int LibvlcAudioEqualizerSetPreamp(global::System.IntPtr p_equalizer, float f_preamp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preamp")]
            internal static extern float LibvlcAudioEqualizerGetPreamp(global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_set_amp_at_index")]
            internal static extern int LibvlcAudioEqualizerSetAmpAtIndex(global::System.IntPtr p_equalizer, float f_amp, uint u_band);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_amp_at_index")]
            internal static extern float LibvlcAudioEqualizerGetAmpAtIndex(global::System.IntPtr p_equalizer, uint u_band);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_equalizer")]
            internal static extern int LibvlcMediaPlayerSetEqualizer(global::System.IntPtr p_mi, global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_role")]
            internal static extern int LibvlcMediaPlayerGetRole(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_role")]
            internal static extern int LibvlcMediaPlayerSetRole(global::System.IntPtr p_mi, uint role);
        }

        /// <summary>Create an empty Media Player object</summary>
        /// <param name="p_libvlc_instance">
        /// <para>the libvlc instance in which the Media Player</para>
        /// <para>should be created.</para>
        /// </param>
        /// <returns>a new media player object, or NULL on error.</returns>
        public static global::libvlc.LibvlcMediaPlayerT LibvlcMediaPlayerNew(global::libvlc.LibvlcInstanceT p_libvlc_instance)
        {
            var __arg0 = ReferenceEquals(p_libvlc_instance, null) ? global::System.IntPtr.Zero : p_libvlc_instance.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerNew(__arg0);
            global::libvlc.LibvlcMediaPlayerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaPlayerT) global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaPlayerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a Media Player object from a Media</summary>
        /// <param name="p_md">
        /// <para>the media. Afterwards the p_md can be safely</para>
        /// <para>destroyed.</para>
        /// </param>
        /// <returns>a new media player object, or NULL on error.</returns>
        public static global::libvlc.LibvlcMediaPlayerT LibvlcMediaPlayerNewFromMedia(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerNewFromMedia(__arg0);
            global::libvlc.LibvlcMediaPlayerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaPlayerT) global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaPlayerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release a media_player after use</para>
        /// <para>Decrement the reference count of a media player object. If the</para>
        /// <para>reference count is 0, then libvlc_media_player_release() will</para>
        /// <para>release the media player object. If the media player object</para>
        /// <para>has been released, then it should not be used again.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player to free</param>
        public static void LibvlcMediaPlayerRelease(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media player object. Use</para>
        /// <para>libvlc_media_player_release() to decrement reference count.</para>
        /// </summary>
        /// <param name="p_mi">media player object</param>
        public static void LibvlcMediaPlayerRetain(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerRetain(__arg0);
        }

        /// <summary>
        /// <para>Set the media that will be used by the media_player. If any,</para>
        /// <para>previous md will be released.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="p_md">
        /// <para>the Media. Afterwards the p_md can be safely</para>
        /// <para>destroyed.</para>
        /// </param>
        public static void LibvlcMediaPlayerSetMedia(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaPlayerSetMedia(__arg0, __arg1);
        }

        /// <summary>Get the media used by the media_player.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>
        /// <para>the media associated with p_mi, or NULL if no</para>
        /// <para>media is associated</para>
        /// </returns>
        public static global::libvlc.LibvlcMediaT LibvlcMediaPlayerGetMedia(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetMedia(__arg0);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the Event Manager from which the media player send event.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the event manager associated with p_mi</returns>
        public static global::libvlc.LibvlcEventManagerT LibvlcMediaPlayerEventManager(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>is_playing</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>1 if the media player is playing, 0 otherwise</returns>
        public static int LibvlcMediaPlayerIsPlaying(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerIsPlaying(__arg0);
            return __ret;
        }

        /// <summary>Play</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>0 if playback started (and was already started), or -1 on error.</returns>
        public static int LibvlcMediaPlayerPlay(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerPlay(__arg0);
            return __ret;
        }

        /// <summary>Pause or resume (no effect if there is no media)</summary>
        /// <param name="mp">the Media Player</param>
        /// <param name="do_pause">play/resume if zero, pause if non-zero</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static void LibvlcMediaPlayerSetPause(global::libvlc.LibvlcMediaPlayerT mp, int do_pause)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcMediaPlayerSetPause(__arg0, do_pause);
        }

        /// <summary>Toggle pause (no effect if there is no media)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerPause(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerPause(__arg0);
        }

        /// <summary>Stop (no effect if there is no media)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerStop(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerStop(__arg0);
        }

        /// <summary>
        /// <para>Set callbacks and private data to render decoded video to a custom area</para>
        /// <para>in memory.</para>
        /// <para>Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()</para>
        /// <para>to configure the decoded format.</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="lock">callback to lock video memory (must not be NULL)</param>
        /// <param name="unlock">callback to unlock video memory (or NULL if not needed)</param>
        /// <param name="display">callback to display video (or NULL if not needed)</param>
        /// <param name="opaque">private pointer for the three callbacks (as first parameter)</param>
        /// <remarks>
        /// <para>Rendering video into custom memory buffers is considerably less</para>
        /// <para>efficient than rendering in a custom window as normal.</para>
        /// <para>For optimal perfomances, VLC media player renders into a custom window, and</para>
        /// <para>does not use this function and associated callbacks. It ishighly</para>
        /// <para>recommendedthat other LibVLC-based application do likewise.</para>
        /// <para>To embed video in a window, use libvlc_media_player_set_xid() or equivalent</para>
        /// <para>depending on the operating system.</para>
        /// <para>If window embedding does not fit the application use case, then a custom</para>
        /// <para>LibVLC video output display plugin is required to maintain optimal video</para>
        /// <para>rendering performances.</para>
        /// <para>The following limitations affect performance:</para>
        /// <para>- Hardware video decoding acceleration will either be disabled completely,</para>
        /// <para>or require (relatively slow) copy from video/DSP memory to main memory.</para>
        /// <para>- Sub-pictures (subtitles, on-screen display, etc.) must be blent into the</para>
        /// <para>main picture by the CPU instead of the GPU.</para>
        /// <para>- Depending on the video format, pixel format conversion, picture scaling,</para>
        /// <para>cropping and/or picture re-orientation, must be performed by the CPU</para>
        /// <para>instead of the GPU.</para>
        /// <para>- Memory copying is required between LibVLC reference picture buffers and</para>
        /// <para>application buffers (between lock and unlock callbacks).</para>
        /// <para>LibVLC 1.1.1 or later</para>
        /// </remarks>
        public static void LibvlcVideoSetCallbacks(global::libvlc.LibvlcMediaPlayerT mp, global::libvlc.LibvlcVideoLockCb @lock, global::libvlc.LibvlcVideoUnlockCb unlock, global::libvlc.LibvlcVideoDisplayCb display, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = @lock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(@lock);
            var __arg2 = unlock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(unlock);
            var __arg3 = display == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(display);
            __Internal.LibvlcVideoSetCallbacks(__arg0, __arg1, __arg2, __arg3, opaque);
        }

        /// <summary>
        /// <para>Set decoded video chroma and dimensions.</para>
        /// <para>This only works in combination with libvlc_video_set_callbacks(),</para>
        /// <para>and is mutually exclusive with libvlc_video_set_format_callbacks().</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="chroma">
        /// <para>a four-characters string identifying the chroma</para>
        /// <para>(e.g. &quot;RV32&quot; or &quot;YUYV&quot;)</para>
        /// </param>
        /// <param name="width">pixel width</param>
        /// <param name="height">pixel height</param>
        /// <param name="pitch">line pitch (in bytes)</param>
        /// <remarks>
        /// <para>LibVLC 1.1.1 or later</para>
        /// <para>All pixel planes are expected to have the same pitch.</para>
        /// <para>To use the YCbCr color space with chrominance subsampling,</para>
        /// <para>consider using libvlc_video_set_format_callbacks() instead.</para>
        /// </remarks>
        public static void LibvlcVideoSetFormat(global::libvlc.LibvlcMediaPlayerT mp, string chroma, uint width, uint height, uint pitch)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcVideoSetFormat(__arg0, chroma, width, height, pitch);
        }

        /// <summary>
        /// <para>Set decoded video chroma and dimensions. This only works in combination with</para>
        /// <para>libvlc_video_set_callbacks().</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="setup">callback to select the video format (cannot be NULL)</param>
        /// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static void LibvlcVideoSetFormatCallbacks(global::libvlc.LibvlcMediaPlayerT mp, global::libvlc.LibvlcVideoFormatCb setup, global::libvlc.LibvlcVideoCleanupCb cleanup)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
            var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
            __Internal.LibvlcVideoSetFormatCallbacks(__arg0, __arg1, __arg2);
        }

        /// <summary>Set the NSView handler where the media player should render its video output.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="drawable">
        /// <para>the drawable that is either an NSView or an object following</para>
        /// <para>the VLCOpenGLVideoViewEmbedding protocol.</para>
        /// </param>
        /// <remarks>
        /// <para>Use the vout called &quot;macosx&quot;.</para>
        /// <para>The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding</para>
        /// <para>protocol:</para>
        /// <para>Or it can be an NSView object.</para>
        /// <para>If you want to use it along with Qt see the QMacCocoaViewContainer. Then</para>
        /// <para>the following code should work:</para>
        /// <para>You can find a live example in VLCVideoView in VLCKit.framework.</para>
        /// </remarks>
        public static void LibvlcMediaPlayerSetNsobject(global::libvlc.LibvlcMediaPlayerT p_mi, global::System.IntPtr drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetNsobject(__arg0, drawable);
        }

        /// <summary>Get the NSView handler previously set with libvlc_media_player_set_nsobject().</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the NSView handler or 0 if none where set</returns>
        public static global::System.IntPtr LibvlcMediaPlayerGetNsobject(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetNsobject(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set an X Window System drawable where the media player should render its</para>
        /// <para>video output. The call takes effect when the playback starts. If it is</para>
        /// <para>already started, it might need to be stopped before changes apply.</para>
        /// <para>If LibVLC was built without X11 output support, then this function has no</para>
        /// <para>effects.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="drawable">X11 window ID</param>
        /// <remarks>
        /// <para>By default, LibVLC will capture input events on the video rendering area.</para>
        /// <para>Use libvlc_video_set_mouse_input() and libvlc_video_set_key_input() to</para>
        /// <para>disable that and deliver events to the parent window / to the application</para>
        /// <para>instead. By design, the X11 protocol delivers input events to only one</para>
        /// <para>recipient.</para>
        /// <para>The application must call the XInitThreads() function from Xlib before</para>
        /// <para>libvlc_new(), and before any call to XOpenDisplay() directly or via any</para>
        /// <para>other library. Failure to call XInitThreads() will seriously impede LibVLC</para>
        /// <para>performance. Calling XOpenDisplay() before XInitThreads() will eventually</para>
        /// <para>crash the process. That is a limitation of Xlib.</para>
        /// <para>The specified identifier must correspond to an existing Input/Output class</para>
        /// <para>X11 window. Pixmaps arenotcurrently supported. The default X11</para>
        /// <para>server is assumed, i.e. that specified in the DISPLAY environment variable.</para>
        /// <para>LibVLC can deal with invalid X11 handle errors, however some display drivers</para>
        /// <para>(EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle</para>
        /// <para>must remain valid until playback is stopped, otherwise the process may</para>
        /// <para>abort or crash.</para>
        /// <para>No more than one window handle per media player instance can be specified.</para>
        /// <para>If the media has multiple simultaneously active video tracks, extra tracks</para>
        /// <para>will be rendered into external windows beyond the control of the</para>
        /// <para>application.</para>
        /// </remarks>
        public static void LibvlcMediaPlayerSetXwindow(global::libvlc.LibvlcMediaPlayerT p_mi, uint drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetXwindow(__arg0, drawable);
        }

        /// <summary>
        /// <para>Get the X Window System window identifier previously set with</para>
        /// <para>libvlc_media_player_set_xwindow(). Note that this will return the identifier</para>
        /// <para>even if VLC is not currently using it (for instance if it is playing an</para>
        /// <para>audio-only input).</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>an X window ID, or 0 if none where set.</returns>
        public static uint LibvlcMediaPlayerGetXwindow(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetXwindow(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set a Win32/Win64 API window handle (HWND) where the media player should</para>
        /// <para>render its video output. If LibVLC was built without Win32/Win64 API output</para>
        /// <para>support, then this has no effects.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="drawable">windows handle of the drawable</param>
        public static void LibvlcMediaPlayerSetHwnd(global::libvlc.LibvlcMediaPlayerT p_mi, global::System.IntPtr drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetHwnd(__arg0, drawable);
        }

        /// <summary>
        /// <para>Get the Windows API window handle (HWND) previously set with</para>
        /// <para>libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC</para>
        /// <para>is not currently outputting any video to it.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>a window handle or NULL if there are none.</returns>
        public static global::System.IntPtr LibvlcMediaPlayerGetHwnd(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetHwnd(__arg0);
            return __ret;
        }

        /// <summary>Set the android context.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_awindow_handler">
        /// <para>org.videolan.libvlc.AWindow jobject owned by the</para>
        /// <para>org.videolan.libvlc.MediaPlayer class from the libvlc-android project.</para>
        /// </param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaPlayerSetAndroidContext(global::libvlc.LibvlcMediaPlayerT p_mi, global::System.IntPtr p_awindow_handler)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetAndroidContext(__arg0, p_awindow_handler);
        }

        /// <summary>Set the EFL Evas Object.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_evas_object">a valid EFL Evas Object (Evas_Object)</param>
        /// <returns>-1 if an error was detected, 0 otherwise.</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerSetEvasObject(global::libvlc.LibvlcMediaPlayerT p_mi, global::System.IntPtr p_evas_object)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetEvasObject(__arg0, p_evas_object);
            return __ret;
        }

        /// <summary>Sets callbacks and private data for decoded audio.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="play">callback to play audio samples (must not be NULL)</param>
        /// <param name="pause">callback to pause playback (or NULL to ignore)</param>
        /// <param name="resume">callback to resume playback (or NULL to ignore)</param>
        /// <param name="flush">callback to flush audio buffers (or NULL to ignore)</param>
        /// <param name="drain">callback to drain audio buffers (or NULL to ignore)</param>
        /// <param name="opaque">private pointer for the audio callbacks (as first parameter)</param>
        /// <remarks>
        /// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        /// <para>to configure the decoded audio format.</para>
        /// <para>The audio callbacks override any other audio output mechanism.</para>
        /// <para>If the callbacks are set, LibVLC willnotoutput audio in any way.</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetCallbacks(global::libvlc.LibvlcMediaPlayerT mp, global::libvlc.LibvlcAudioPlayCb play, global::libvlc.LibvlcAudioPauseCb pause, global::libvlc.LibvlcAudioResumeCb resume, global::libvlc.LibvlcAudioFlushCb flush, global::libvlc.LibvlcAudioDrainCb drain, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = play == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(play);
            var __arg2 = pause == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pause);
            var __arg3 = resume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(resume);
            var __arg4 = flush == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flush);
            var __arg5 = drain == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(drain);
            __Internal.LibvlcAudioSetCallbacks(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, opaque);
        }

        /// <summary>
        /// <para>Set callbacks and private data for decoded audio. This only works in</para>
        /// <para>combination with libvlc_audio_set_callbacks().</para>
        /// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        /// <para>to configure the decoded audio format.</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="set_volume">
        /// <para>callback to apply audio volume,</para>
        /// <para>or NULL to apply volume in software</para>
        /// </param>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static void LibvlcAudioSetVolumeCallback(global::libvlc.LibvlcMediaPlayerT mp, global::libvlc.LibvlcAudioSetVolumeCb set_volume)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = set_volume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(set_volume);
            __Internal.LibvlcAudioSetVolumeCallback(__arg0, __arg1);
        }

        /// <summary>Sets decoded audio format via callbacks.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="setup">callback to select the audio format (cannot be NULL)</param>
        /// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        /// <remarks>
        /// <para>This only works in combination with libvlc_audio_set_callbacks().</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetFormatCallbacks(global::libvlc.LibvlcMediaPlayerT mp, global::libvlc.LibvlcAudioSetupCb setup, global::libvlc.LibvlcAudioCleanupCb cleanup)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
            var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
            __Internal.LibvlcAudioSetFormatCallbacks(__arg0, __arg1, __arg2);
        }

        /// <summary>Sets a fixed decoded audio format.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="format">
        /// <para>a four-characters string identifying the sample format</para>
        /// <para>(e.g. &quot;S16N&quot; or &quot;FL32&quot;)</para>
        /// </param>
        /// <param name="rate">sample rate (expressed in Hz)</param>
        /// <param name="channels">channels count</param>
        /// <remarks>
        /// <para>This only works in combination with libvlc_audio_set_callbacks(),</para>
        /// <para>and is mutually exclusive with libvlc_audio_set_format_callbacks().</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetFormat(global::libvlc.LibvlcMediaPlayerT mp, string format, uint rate, uint channels)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcAudioSetFormat(__arg0, format, rate, channels);
        }

        /// <summary>Get the current movie length (in ms).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the movie length (in ms), or -1 if there is no media.</returns>
        public static long LibvlcMediaPlayerGetLength(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetLength(__arg0);
            return __ret;
        }

        /// <summary>Get the current movie time (in ms).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the movie time (in ms), or -1 if there is no media.</returns>
        public static long LibvlcMediaPlayerGetTime(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTime(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the movie time (in ms). This has no effect if no media is being played.</para>
        /// <para>Not all formats and protocols support this.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_time">the movie time (in ms).</param>
        public static void LibvlcMediaPlayerSetTime(global::libvlc.LibvlcMediaPlayerT p_mi, long i_time)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetTime(__arg0, i_time);
        }

        /// <summary>Get movie position as percentage between 0.0 and 1.0.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>movie position, or -1. in case of error</returns>
        public static float LibvlcMediaPlayerGetPosition(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetPosition(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set movie position as percentage between 0.0 and 1.0.</para>
        /// <para>This has no effect if playback is not enabled.</para>
        /// <para>This might not work depending on the underlying input format and protocol.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="f_pos">the position</param>
        public static void LibvlcMediaPlayerSetPosition(global::libvlc.LibvlcMediaPlayerT p_mi, float f_pos)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetPosition(__arg0, f_pos);
        }

        /// <summary>Set movie chapter (if applicable).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_chapter">chapter number to play</param>
        public static void LibvlcMediaPlayerSetChapter(global::libvlc.LibvlcMediaPlayerT p_mi, int i_chapter)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetChapter(__arg0, i_chapter);
        }

        /// <summary>Get movie chapter.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>chapter number currently playing, or -1 if there is no media.</returns>
        public static int LibvlcMediaPlayerGetChapter(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapter(__arg0);
            return __ret;
        }

        /// <summary>Get movie chapter count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>number of chapters in movie, or -1.</returns>
        public static int LibvlcMediaPlayerGetChapterCount(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapterCount(__arg0);
            return __ret;
        }

        /// <summary>Is the player able to play</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>boolean</returns>
        public static int LibvlcMediaPlayerWillPlay(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerWillPlay(__arg0);
            return __ret;
        }

        /// <summary>Get title chapter count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_title">title</param>
        /// <returns>number of chapters in title, or -1</returns>
        public static int LibvlcMediaPlayerGetChapterCountForTitle(global::libvlc.LibvlcMediaPlayerT p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapterCountForTitle(__arg0, i_title);
            return __ret;
        }

        /// <summary>Set movie title</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_title">title number to play</param>
        public static void LibvlcMediaPlayerSetTitle(global::libvlc.LibvlcMediaPlayerT p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetTitle(__arg0, i_title);
        }

        /// <summary>Get movie title</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>title number currently playing, or -1</returns>
        public static int LibvlcMediaPlayerGetTitle(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTitle(__arg0);
            return __ret;
        }

        /// <summary>Get movie title count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>title number count, or -1</returns>
        public static int LibvlcMediaPlayerGetTitleCount(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTitleCount(__arg0);
            return __ret;
        }

        /// <summary>Set previous chapter (if applicable)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerPreviousChapter(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerPreviousChapter(__arg0);
        }

        /// <summary>Set next chapter (if applicable)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerNextChapter(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNextChapter(__arg0);
        }

        /// <summary>Get the requested movie play rate.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>movie play rate</returns>
        /// <remarks>
        /// <para>Depending on the underlying media, the requested rate may be</para>
        /// <para>different from the real playback rate.</para>
        /// </remarks>
        public static float LibvlcMediaPlayerGetRate(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetRate(__arg0);
            return __ret;
        }

        /// <summary>Set movie play rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="rate">movie play rate to set</param>
        /// <returns>
        /// <para>-1 if an error was detected, 0 otherwise (but even then, it might</para>
        /// <para>not actually work depending on the underlying media protocol)</para>
        /// </returns>
        public static int LibvlcMediaPlayerSetRate(global::libvlc.LibvlcMediaPlayerT p_mi, float rate)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetRate(__arg0, rate);
            return __ret;
        }

        /// <summary>Get current movie state</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the current state of the media player (playing, paused, ...)</returns>
        /// <remarks>libvlc_state_t</remarks>
        public static global::libvlc.LibvlcStateT LibvlcMediaPlayerGetState(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetState(__arg0);
            return __ret;
        }

        /// <summary>How many video outputs does this media player have?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the number of video outputs</returns>
        public static uint LibvlcMediaPlayerHasVout(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerHasVout(__arg0);
            return __ret;
        }

        /// <summary>Is this media player seekable?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the media player can seek</returns>
        public static int LibvlcMediaPlayerIsSeekable(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerIsSeekable(__arg0);
            return __ret;
        }

        /// <summary>Can this media player be paused?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the media player can pause</returns>
        public static int LibvlcMediaPlayerCanPause(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerCanPause(__arg0);
            return __ret;
        }

        /// <summary>Check if the current program is scrambled</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the current program is scrambled</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static int LibvlcMediaPlayerProgramScrambled(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerProgramScrambled(__arg0);
            return __ret;
        }

        /// <summary>Display the next frame (if supported)</summary>
        /// <param name="p_mi">the media player</param>
        public static void LibvlcMediaPlayerNextFrame(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNextFrame(__arg0);
        }

        /// <summary>Navigate through DVD Menu</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="navigate">the Navigation mode</param>
        /// <remarks>libVLC 2.0.0 or later</remarks>
        public static void LibvlcMediaPlayerNavigate(global::libvlc.LibvlcMediaPlayerT p_mi, uint navigate)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNavigate(__arg0, navigate);
        }

        /// <summary>Set if, and how, the video title will be shown when media is played.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="position">position at which to display the title, or libvlc_position_disable to prevent the title from being displayed</param>
        /// <param name="timeout">title display timeout in milliseconds (ignored if libvlc_position_disable)</param>
        /// <remarks>libVLC 2.1.0 or later</remarks>
        public static void LibvlcMediaPlayerSetVideoTitleDisplay(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcPositionT position, uint timeout)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetVideoTitleDisplay(__arg0, position, timeout);
        }

        /// <summary>Add a slave to the current media player.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_type">subtitle or audio</param>
        /// <param name="psz_uri">Uri of the slave (should contain a valid scheme).</param>
        /// <param name="b_select">True if this slave should be selected when it's loaded</param>
        /// <returns>0 on success, -1 on error.</returns>
        /// <remarks>
        /// <para>If the player is playing, the slave will be added directly. This call</para>
        /// <para>will also update the slave list of the attached libvlc_media_t.</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_slaves_add</para>
        /// </remarks>
        public static int LibvlcMediaPlayerAddSlave(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcMediaSlaveTypeT i_type, string psz_uri, bool b_select)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerAddSlave(__arg0, i_type, psz_uri, b_select);
            return __ret;
        }

        /// <summary>Release (free) libvlc_track_description_t</summary>
        /// <param name="p_track_description">the structure to release</param>
        public static void LibvlcTrackDescriptionListRelease(global::libvlc.LibvlcTrackDescriptionT p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionListRelease(__arg0);
        }

        /// <summary>Toggle fullscreen status on non-embedded video outputs.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>
        /// <para>The same limitations applies to this function</para>
        /// <para>as to libvlc_set_fullscreen().</para>
        /// </remarks>
        public static void LibvlcToggleFullscreen(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcToggleFullscreen(__arg0);
        }

        /// <summary>Enable or disable fullscreen.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="b_fullscreen">boolean for fullscreen status</param>
        /// <remarks>
        /// <para>With most window managers, only a top-level windows can be in</para>
        /// <para>full-screen mode. Hence, this function will not operate properly if</para>
        /// <para>libvlc_media_player_set_xwindow() was used to embed the video in a</para>
        /// <para>non-top-level window. In that case, the embedding window must be reparented</para>
        /// <para>to the root windowbeforefullscreen mode is enabled. You will want</para>
        /// <para>to reparent it back to its normal parent when disabling fullscreen.</para>
        /// </remarks>
        public static void LibvlcSetFullscreen(global::libvlc.LibvlcMediaPlayerT p_mi, int b_fullscreen)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcSetFullscreen(__arg0, b_fullscreen);
        }

        /// <summary>Get current fullscreen status.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the fullscreen status (boolean)</returns>
        public static int LibvlcGetFullscreen(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcGetFullscreen(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Enable or disable key press events handling, according to the LibVLC hotkeys</para>
        /// <para>configuration. By default and for historical reasons, keyboard events are</para>
        /// <para>handled by the LibVLC video widget.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="on">true to handle key press events, false to ignore them.</param>
        /// <remarks>
        /// <para>On X11, there can be only one subscriber for key press and mouse</para>
        /// <para>click events per window. If your application has subscribed to those events</para>
        /// <para>for the X window ID of the video widget, then LibVLC will not be able to</para>
        /// <para>handle key presses and mouse clicks in any case.</para>
        /// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        /// </remarks>
        public static void LibvlcVideoSetKeyInput(global::libvlc.LibvlcMediaPlayerT p_mi, uint on)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetKeyInput(__arg0, on);
        }

        /// <summary>
        /// <para>Enable or disable mouse click events handling. By default, those events are</para>
        /// <para>handled. This is needed for DVD menus to work, as well as a few video</para>
        /// <para>filters such as &quot;puzzle&quot;.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="on">true to handle mouse click events, false to ignore them.</param>
        /// <remarks>
        /// <para>libvlc_video_set_key_input().</para>
        /// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        /// </remarks>
        public static void LibvlcVideoSetMouseInput(global::libvlc.LibvlcMediaPlayerT p_mi, uint on)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMouseInput(__arg0, on);
        }

        /// <summary>Get the pixel dimensions of a video.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="num">number of the video (starting from, and most commonly 0)</param>
        /// <param name="px">pointer to get the pixel width [OUT]</param>
        /// <param name="py">pointer to get the pixel height [OUT]</param>
        /// <returns>0 on success, -1 if the specified video does not exist</returns>
        public static int LibvlcVideoGetSize(global::libvlc.LibvlcMediaPlayerT p_mi, uint num, ref uint px, ref uint py)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            fixed (uint* __refParamPtr2 = &px)
            {
                var __arg2 = __refParamPtr2;
                fixed (uint* __refParamPtr3 = &py)
                {
                    var __arg3 = __refParamPtr3;
                    var __ret = __Internal.LibvlcVideoGetSize(__arg0, num, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the mouse pointer coordinates over a video.</para>
        /// <para>Coordinates are expressed in terms of the decoded video resolution,</para>
        /// <para>notin terms of pixels on the screen/viewport (to get the latter,</para>
        /// <para>you can query your windowing system directly).</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="num">number of the video (starting from, and most commonly 0)</param>
        /// <param name="px">pointer to get the abscissa [OUT]</param>
        /// <param name="py">pointer to get the ordinate [OUT]</param>
        /// <returns>0 on success, -1 if the specified video does not exist</returns>
        /// <remarks>
        /// <para>Either of the coordinates may be negative or larger than the corresponding</para>
        /// <para>dimension of the video, if the cursor is outside the rendering area.</para>
        /// <para>The coordinates may be out-of-date if the pointer is not located</para>
        /// <para>on the video rendering area. LibVLC does not track the pointer if it is</para>
        /// <para>outside of the video widget.</para>
        /// <para>LibVLC does not support multiple pointers (it does of course support</para>
        /// <para>multiple input devices sharing the same pointer) at the moment.</para>
        /// </remarks>
        public static int LibvlcVideoGetCursor(global::libvlc.LibvlcMediaPlayerT p_mi, uint num, ref int px, ref int py)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            fixed (int* __refParamPtr2 = &px)
            {
                var __arg2 = __refParamPtr2;
                fixed (int* __refParamPtr3 = &py)
                {
                    var __arg3 = __refParamPtr3;
                    var __ret = __Internal.LibvlcVideoGetCursor(__arg0, num, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the current video scaling factor.</para>
        /// <para>See also libvlc_video_set_scale().</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>the currently configured zoom factor, or 0. if the video is set</para>
        /// <para>to fit to the output window/drawable automatically.</para>
        /// </returns>
        public static float LibvlcVideoGetScale(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetScale(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the video scaling factor. That is the ratio of the number of pixels on</para>
        /// <para>screen to the number of pixels in the original decoded video in each</para>
        /// <para>dimension. Zero is a special value; it will adjust the video to the output</para>
        /// <para>window/drawable (in windowed mode) or the entire screen.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="f_factor">the scaling factor, or zero</param>
        /// <remarks>Note that not all video outputs support scaling.</remarks>
        public static void LibvlcVideoSetScale(global::libvlc.LibvlcMediaPlayerT p_mi, float f_factor)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetScale(__arg0, f_factor);
        }

        /// <summary>Get current video aspect ratio.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>the video aspect ratio or NULL if unspecified</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        public static sbyte* LibvlcVideoGetAspectRatio(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAspectRatio(__arg0);
            return __ret;
        }

        /// <summary>Set new video aspect ratio.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_aspect">new video aspect-ratio or NULL to reset to default</param>
        /// <remarks>Invalid aspect ratios are ignored.</remarks>
        public static void LibvlcVideoSetAspectRatio(global::libvlc.LibvlcMediaPlayerT p_mi, string psz_aspect)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAspectRatio(__arg0, psz_aspect);
        }

        /// <summary>Create a video viewpoint structure.</summary>
        /// <returns>
        /// <para>video viewpoint or NULL</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static global::libvlc.LibvlcVideoViewpointT LibvlcVideoNewViewpoint()
        {
            var __ret = __Internal.LibvlcVideoNewViewpoint();
            global::libvlc.LibvlcVideoViewpointT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcVideoViewpointT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcVideoViewpointT) global::libvlc.LibvlcVideoViewpointT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcVideoViewpointT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Update the video viewpoint information.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_viewpoint">video viewpoint allocated via libvlc_video_new_viewpoint()</param>
        /// <param name="b_absolute">
        /// <para>if true replace the old viewpoint with the new one. If</para>
        /// <para>false, increase/decrease it.</para>
        /// </param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>It is safe to call this function before the media player is started.</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// <para>the values are set asynchronously, it will be used by the next frame displayed.</para>
        /// </remarks>
        public static int LibvlcVideoUpdateViewpoint(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcVideoViewpointT p_viewpoint, bool b_absolute)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_viewpoint, null) ? global::System.IntPtr.Zero : p_viewpoint.__Instance;
            var __ret = __Internal.LibvlcVideoUpdateViewpoint(__arg0, __arg1, b_absolute);
            return __ret;
        }

        /// <summary>Get current video subtitle.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video subtitle selected, or -1 if none</returns>
        public static int LibvlcVideoGetSpu(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpu(__arg0);
            return __ret;
        }

        /// <summary>Get the number of available video subtitles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the number of available video subtitles</returns>
        public static int LibvlcVideoGetSpuCount(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available video subtitles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available video subtitles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlc.LibvlcTrackDescriptionT LibvlcVideoGetSpuDescription(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuDescription(__arg0);
            global::libvlc.LibvlcTrackDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set new video subtitle.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_spu">video subtitle track to select (i_id from track description)</param>
        /// <returns>0 on success, -1 if out of range</returns>
        public static int LibvlcVideoSetSpu(global::libvlc.LibvlcMediaPlayerT p_mi, int i_spu)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSpu(__arg0, i_spu);
            return __ret;
        }

        /// <summary>
        /// <para>Get the current subtitle delay. Positive values means subtitles are being</para>
        /// <para>displayed later, negative values earlier.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <returns>time (in microseconds) the display of subtitles is being delayed</returns>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static long LibvlcVideoGetSpuDelay(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuDelay(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the subtitle delay. This affects the timing of when the subtitle will</para>
        /// <para>be displayed. Positive values result in subtitles being displayed later,</para>
        /// <para>while negative values will result in subtitles being displayed earlier.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_delay">time (in microseconds) the display of subtitles should be delayed</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>
        /// <para>The subtitle delay will be reset to zero each time the media changes.</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static int LibvlcVideoSetSpuDelay(global::libvlc.LibvlcMediaPlayerT p_mi, long i_delay)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSpuDelay(__arg0, i_delay);
            return __ret;
        }

        /// <summary>Get the full description of available titles</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="titles">
        /// <para>address to store an allocated array of title descriptions</para>
        /// <para>descriptions (must be freed with libvlc_title_descriptions_release()</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of titles (-1 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetFullTitleDescriptions(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcTitleDescriptionT titles)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(titles, null) ? global::System.IntPtr.Zero : titles.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFullTitleDescriptions(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release a title description</summary>
        /// <param name="p_titles">title description array to release</param>
        /// <param name="i_count">number of title descriptions to release</param>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static void LibvlcTitleDescriptionsRelease(global::libvlc.LibvlcTitleDescriptionT p_titles, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_titles, null) ? global::System.IntPtr.Zero : p_titles.__Instance;
            __Internal.LibvlcTitleDescriptionsRelease(__arg0, i_count);
        }

        /// <summary>Get the full description of available chapters</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_chapters_of_title">index of the title to query for chapters (uses current title if set to -1)</param>
        /// <param name="pp_chapters">
        /// <para>address to store an allocated array of chapter descriptions</para>
        /// <para>descriptions (must be freed with libvlc_chapter_descriptions_release()</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of chapters (-1 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetFullChapterDescriptions(global::libvlc.LibvlcMediaPlayerT p_mi, int i_chapters_of_title, global::libvlc.LibvlcChapterDescriptionT pp_chapters)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg2 = ReferenceEquals(pp_chapters, null) ? global::System.IntPtr.Zero : pp_chapters.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFullChapterDescriptions(__arg0, i_chapters_of_title, __arg2);
            return __ret;
        }

        /// <summary>Release a chapter description</summary>
        /// <param name="p_chapters">chapter description array to release</param>
        /// <param name="i_count">number of chapter descriptions to release</param>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static void LibvlcChapterDescriptionsRelease(global::libvlc.LibvlcChapterDescriptionT p_chapters, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_chapters, null) ? global::System.IntPtr.Zero : p_chapters.__Instance;
            __Internal.LibvlcChapterDescriptionsRelease(__arg0, i_count);
        }

        /// <summary>Get current crop filter geometry.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the crop filter geometry or NULL if unset</returns>
        public static sbyte* LibvlcVideoGetCropGeometry(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetCropGeometry(__arg0);
            return __ret;
        }

        /// <summary>Set new crop filter geometry.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_geometry">new crop filter geometry (NULL to unset)</param>
        public static void LibvlcVideoSetCropGeometry(global::libvlc.LibvlcMediaPlayerT p_mi, string psz_geometry)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetCropGeometry(__arg0, psz_geometry);
        }

        /// <summary>Get current teletext page requested or 0 if it's disabled.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the current teletext page requested.</returns>
        /// <remarks>
        /// <para>Teletext is disabled by default, call libvlc_video_set_teletext() to enable</para>
        /// <para>it.</para>
        /// </remarks>
        public static int LibvlcVideoGetTeletext(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTeletext(__arg0);
            return __ret;
        }

        /// <summary>Set new teletext page to retrieve.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_page">
        /// <para>teletex page number requested. This value can be 0 to disable</para>
        /// <para>teletext, a number in the range ]0;1000[ to show the requested page, or a</para>
        /// </param>
        /// <remarks>This function can also be used to send a teletext key.</remarks>
        public static void LibvlcVideoSetTeletext(global::libvlc.LibvlcMediaPlayerT p_mi, int i_page)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetTeletext(__arg0, i_page);
        }

        /// <summary>Get number of available video tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the number of available video tracks (int)</returns>
        public static int LibvlcVideoGetTrackCount(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrackCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available video tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>list with description of available video tracks, or NULL on error.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlc.LibvlcTrackDescriptionT LibvlcVideoGetTrackDescription(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrackDescription(__arg0);
            global::libvlc.LibvlcTrackDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get current video track.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the video track ID (int) or -1 if no active input</returns>
        public static int LibvlcVideoGetTrack(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrack(__arg0);
            return __ret;
        }

        /// <summary>Set video track.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_track">the track ID (i_id field from track description)</param>
        /// <returns>0 on success, -1 if out of range</returns>
        public static int LibvlcVideoSetTrack(global::libvlc.LibvlcMediaPlayerT p_mi, int i_track)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetTrack(__arg0, i_track);
            return __ret;
        }

        /// <summary>Take a snapshot of the current video window.</summary>
        /// <param name="p_mi">media player instance</param>
        /// <param name="num">number of video output (typically 0 for the first/only one)</param>
        /// <param name="psz_filepath">the path where to save the screenshot to</param>
        /// <param name="i_width">the snapshot's width</param>
        /// <param name="i_height">the snapshot's height</param>
        /// <returns>0 on success, -1 if the video was not found</returns>
        /// <remarks>
        /// <para>If i_width AND i_height is 0, original size is used.</para>
        /// <para>If i_width XOR i_height is 0, original aspect-ratio is preserved.</para>
        /// </remarks>
        public static int LibvlcVideoTakeSnapshot(global::libvlc.LibvlcMediaPlayerT p_mi, uint num, string psz_filepath, uint i_width, uint i_height)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoTakeSnapshot(__arg0, num, psz_filepath, i_width, i_height);
            return __ret;
        }

        /// <summary>Enable or disable deinterlace filter</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="psz_mode">type of deinterlace filter, NULL to disable</param>
        public static void LibvlcVideoSetDeinterlace(global::libvlc.LibvlcMediaPlayerT p_mi, string psz_mode)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetDeinterlace(__arg0, psz_mode);
        }

        /// <summary>Get an integer marquee option value</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to get</param>
        /// <remarks>libvlc_video_marquee_int_option_t</remarks>
        public static int LibvlcVideoGetMarqueeInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetMarqueeInt(__arg0, option);
            return __ret;
        }

        /// <summary>Get a string marquee option value</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to get</param>
        /// <remarks>libvlc_video_marquee_string_option_t</remarks>
        public static sbyte* LibvlcVideoGetMarqueeString(global::libvlc.LibvlcMediaPlayerT p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetMarqueeString(__arg0, option);
            return __ret;
        }

        /// <summary>Enable, disable or set an integer marquee option</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to set</param>
        /// <param name="i_val">marq option value</param>
        /// <remarks>
        /// <para>Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)</para>
        /// <para>or disabling (arg 0) the marq filter.</para>
        /// <para>libvlc_video_marquee_int_option_t</para>
        /// </remarks>
        public static void LibvlcVideoSetMarqueeInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, int i_val)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMarqueeInt(__arg0, option, i_val);
        }

        /// <summary>Set a marquee string option</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to set</param>
        /// <param name="psz_text">marq option value</param>
        /// <remarks>libvlc_video_marquee_string_option_t</remarks>
        public static void LibvlcVideoSetMarqueeString(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, string psz_text)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMarqueeString(__arg0, option, psz_text);
        }

        /// <summary>Get integer logo option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to get, values of libvlc_video_logo_option_t</param>
        public static int LibvlcVideoGetLogoInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetLogoInt(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set logo option as integer. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// <para>Passing libvlc_logo_enable as option value has the side effect of</para>
        /// <para>starting (arg !0) or stopping (arg 0) the logo filter.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        /// <param name="value">logo option value</param>
        public static void LibvlcVideoSetLogoInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, int value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetLogoInt(__arg0, option, value);
        }

        /// <summary>
        /// <para>Set logo option as string. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        /// <param name="psz_value">logo option value</param>
        public static void LibvlcVideoSetLogoString(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, string psz_value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetLogoString(__arg0, option, psz_value);
        }

        /// <summary>Get integer adjust option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static int LibvlcVideoGetAdjustInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAdjustInt(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set adjust option as integer. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// <para>Passing libvlc_adjust_enable as option value has the side effect of</para>
        /// <para>starting (arg !0) or stopping (arg 0) the adjust filter.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        /// <param name="value">adjust option value</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static void LibvlcVideoSetAdjustInt(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, int value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAdjustInt(__arg0, option, value);
        }

        /// <summary>Get float adjust option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static float LibvlcVideoGetAdjustFloat(global::libvlc.LibvlcMediaPlayerT p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAdjustFloat(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set adjust option as float. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        /// <param name="value">adjust option value</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static void LibvlcVideoSetAdjustFloat(global::libvlc.LibvlcMediaPlayerT p_mi, uint option, float value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAdjustFloat(__arg0, option, value);
        }

        /// <summary>Gets the list of available audio output modules.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>list of available audio outputs. It must be freed with</returns>
        /// <remarks>
        /// <para>libvlc_audio_output_list_release</para>
        /// <para>libvlc_audio_output_t .</para>
        /// <para>In case of error, NULL is returned.</para>
        /// </remarks>
        public static global::libvlc.LibvlcAudioOutputT LibvlcAudioOutputListGet(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputListGet(__arg0);
            global::libvlc.LibvlcAudioOutputT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcAudioOutputT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcAudioOutputT) global::libvlc.LibvlcAudioOutputT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcAudioOutputT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees the list of available audio output modules.</summary>
        /// <param name="p_list">list with audio outputs for release</param>
        public static void LibvlcAudioOutputListRelease(global::libvlc.LibvlcAudioOutputT p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcAudioOutputListRelease(__arg0);
        }

        /// <summary>Selects an audio output module.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="psz_name">
        /// <para>name of audio output,</para>
        /// <para>use psz_name of</para>
        /// </param>
        /// <returns>0 if function succeeded, -1 on error</returns>
        /// <remarks>
        /// <para>Any change will take be effect only after playback is stopped and</para>
        /// <para>restarted. Audio output cannot be changed while playing.</para>
        /// <para>libvlc_audio_output_t</para>
        /// </remarks>
        public static int LibvlcAudioOutputSet(global::libvlc.LibvlcMediaPlayerT p_mi, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioOutputSet(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Gets a list of potential audio output devices,</summary>
        /// <param name="mp">media player</param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support enumerating devices.</para>
        /// <para>The audio output may be functional even if the list is empty (NULL).</para>
        /// <para>The list may not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.2.0 or later.</para>
        /// </remarks>
        public static global::libvlc.LibvlcAudioOutputDeviceT LibvlcAudioOutputDeviceEnum(global::libvlc.LibvlcMediaPlayerT mp)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceEnum(__arg0);
            global::libvlc.LibvlcAudioOutputDeviceT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcAudioOutputDeviceT) global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcAudioOutputDeviceT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets a list of audio output devices for a given audio output module,</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <param name="aout">
        /// <para>audio output name</para>
        /// <para>(as returned by libvlc_audio_output_list_get())</para>
        /// </param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support this. In particular, an empty (NULL)</para>
        /// <para>list of devices doesnotimply that the specified audio output does</para>
        /// <para>not work.</para>
        /// <para>The list might not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.1.0 or later.</para>
        /// </remarks>
        public static global::libvlc.LibvlcAudioOutputDeviceT LibvlcAudioOutputDeviceListGet(global::libvlc.LibvlcInstanceT p_instance, string aout)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceListGet(__arg0, aout);
            global::libvlc.LibvlcAudioOutputDeviceT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcAudioOutputDeviceT) global::libvlc.LibvlcAudioOutputDeviceT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcAudioOutputDeviceT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees a list of available audio output devices.</summary>
        /// <param name="p_list">list with audio outputs for release</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public static void LibvlcAudioOutputDeviceListRelease(global::libvlc.LibvlcAudioOutputDeviceT p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcAudioOutputDeviceListRelease(__arg0);
        }

        /// <summary>Configures an explicit audio output device.</summary>
        /// <param name="mp">media player</param>
        /// <param name="module">
        /// <para>If NULL, current audio output module.</para>
        /// <para>if non-NULL, name of audio output module</para>
        /// <para>(</para>
        /// </param>
        /// <param name="device_id">device identifier string</param>
        /// <returns>Nothing. Errors are ignored (this is a design bug).</returns>
        /// <remarks>
        /// <para>If the module paramater is NULL, audio output will be moved to the device</para>
        /// <para>specified by the device identifier string immediately. This is the</para>
        /// <para>recommended usage.</para>
        /// <para>A list of adequate potential device strings can be obtained with</para>
        /// <para>libvlc_audio_output_device_enum().</para>
        /// <para>However passing NULL is supported in LibVLC version 2.2.0 and later only;</para>
        /// <para>in earlier versions, this function would have no effects when the module</para>
        /// <para>parameter was NULL.</para>
        /// <para>If the module parameter is not NULL, the device parameter of the</para>
        /// <para>corresponding audio output, if it exists, will be set to the specified</para>
        /// <para>string. Note that some audio output modules do not have such a parameter</para>
        /// <para>(notably MMDevice and PulseAudio).</para>
        /// <para>A list of adequate potential device strings can be obtained with</para>
        /// <para>libvlc_audio_output_device_list_get().</para>
        /// <para>This function does not select the specified audio output plugin.</para>
        /// <para>libvlc_audio_output_set() is used for that purpose.</para>
        /// <para>The syntax for the device parameter depends on the audio output.</para>
        /// <para>Some audio output modules require further parameters (e.g. a channels map</para>
        /// <para>in the case of ALSA).</para>
        /// <para>libvlc_audio_output_t)</para>
        /// </remarks>
        public static void LibvlcAudioOutputDeviceSet(global::libvlc.LibvlcMediaPlayerT mp, string module, string device_id)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcAudioOutputDeviceSet(__arg0, module, device_id);
        }

        /// <summary>Get the current audio output device identifier.</summary>
        /// <param name="mp">media player</param>
        /// <returns>
        /// <para>the current audio output device identifier</para>
        /// <para>NULL if no device is selected or in case of error</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        /// <remarks>
        /// <para>This complements libvlc_audio_output_device_set().</para>
        /// <para>The initial value for the current audio output device identifier</para>
        /// <para>may not be set or may be some unknown value. A LibVLC application should</para>
        /// <para>compare this value against the known device identifiers (e.g. those that</para>
        /// <para>were previously retrieved by a call to libvlc_audio_output_device_enum or</para>
        /// <para>libvlc_audio_output_device_list_get) to find the current audio output device.</para>
        /// <para>It is possible that the selected audio output device changes (an external</para>
        /// <para>change) without a call to libvlc_audio_output_device_set. That may make this</para>
        /// <para>method unsuitable to use if a LibVLC application is attempting to track</para>
        /// <para>dynamic audio device changes as they happen.</para>
        /// <para>LibVLC 3.0.0 or later.</para>
        /// </remarks>
        public static sbyte* LibvlcAudioOutputDeviceGet(global::libvlc.LibvlcMediaPlayerT mp)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceGet(__arg0);
            return __ret;
        }

        /// <summary>Toggle mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <remarks>
        /// <para>Toggling mute atomically is not always possible: On some platforms,</para>
        /// <para>other processes can mute the VLC audio playback stream asynchronously. Thus,</para>
        /// <para>there is a small race condition where toggling will not work.</para>
        /// <para>See also the limitations of libvlc_audio_set_mute().</para>
        /// </remarks>
        public static void LibvlcAudioToggleMute(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcAudioToggleMute(__arg0);
        }

        /// <summary>Get current mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the mute status (boolean) if defined, -1 if undefined/unapplicable</returns>
        public static int LibvlcAudioGetMute(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetMute(__arg0);
            return __ret;
        }

        /// <summary>Set mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="status">If status is true then mute, otherwise unmute</param>
        /// <remarks>
        /// <para>This function does not always work. If there are no active audio</para>
        /// <para>playback stream, the mute status might not be available. If digital</para>
        /// <para>pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also</para>
        /// <para>some audio output plugins do not support muting at all.</para>
        /// <para>To force silent playback, disable all audio tracks. This is more</para>
        /// <para>efficient and reliable than mute.</para>
        /// </remarks>
        public static void LibvlcAudioSetMute(global::libvlc.LibvlcMediaPlayerT p_mi, int status)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcAudioSetMute(__arg0, status);
        }

        /// <summary>Get current software audio volume.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>the software volume in percents</para>
        /// <para>(0 = mute, 100 = nominal / 0dB)</para>
        /// </returns>
        public static int LibvlcAudioGetVolume(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetVolume(__arg0);
            return __ret;
        }

        /// <summary>Set current software audio volume.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_volume">the volume in percents (0 = mute, 100 = 0dB)</param>
        /// <returns>0 if the volume was set, -1 if it was out of range</returns>
        public static int LibvlcAudioSetVolume(global::libvlc.LibvlcMediaPlayerT p_mi, int i_volume)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetVolume(__arg0, i_volume);
            return __ret;
        }

        /// <summary>Get number of available audio tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the number of available audio tracks (int), or -1 if unavailable</returns>
        public static int LibvlcAudioGetTrackCount(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrackCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available audio tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>list with description of available audio tracks, or NULL.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlc.LibvlcTrackDescriptionT LibvlcAudioGetTrackDescription(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrackDescription(__arg0);
            global::libvlc.LibvlcTrackDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get current audio track.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio track ID or -1 if no active input.</returns>
        public static int LibvlcAudioGetTrack(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrack(__arg0);
            return __ret;
        }

        /// <summary>Set current audio track.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_track">the track ID (i_id field from track description)</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcAudioSetTrack(global::libvlc.LibvlcMediaPlayerT p_mi, int i_track)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetTrack(__arg0, i_track);
            return __ret;
        }

        /// <summary>Get current audio channel.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio channel</returns>
        /// <remarks>libvlc_audio_output_channel_t</remarks>
        public static int LibvlcAudioGetChannel(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetChannel(__arg0);
            return __ret;
        }

        /// <summary>Set current audio channel.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="channel">the audio channel,</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>libvlc_audio_output_channel_t</remarks>
        public static int LibvlcAudioSetChannel(global::libvlc.LibvlcMediaPlayerT p_mi, int channel)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetChannel(__arg0, channel);
            return __ret;
        }

        /// <summary>Get current audio delay.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio delay (microseconds)</returns>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static long LibvlcAudioGetDelay(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetDelay(__arg0);
            return __ret;
        }

        /// <summary>Set current audio delay. The audio delay will be reset to zero each time the media changes.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_delay">the audio delay (microseconds)</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static int LibvlcAudioSetDelay(global::libvlc.LibvlcMediaPlayerT p_mi, long i_delay)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetDelay(__arg0, i_delay);
            return __ret;
        }

        /// <summary>Get the number of equalizer presets.</summary>
        /// <returns>number of presets</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static uint LibvlcAudioEqualizerGetPresetCount()
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetPresetCount();
            return __ret;
        }

        /// <summary>Get the name of a particular equalizer preset.</summary>
        /// <param name="u_index">index of the preset, counting from zero</param>
        /// <returns>preset name, or NULL if there is no such preset</returns>
        /// <remarks>
        /// <para>This name can be used, for example, to prepare a preset label or menu in a user</para>
        /// <para>interface.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static string LibvlcAudioEqualizerGetPresetName(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetPresetName(u_index);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the number of distinct frequency bands for an equalizer.</summary>
        /// <returns>number of frequency bands</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static uint LibvlcAudioEqualizerGetBandCount()
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetBandCount();
            return __ret;
        }

        /// <summary>Get a particular equalizer band frequency.</summary>
        /// <param name="u_index">index of the band, counting from zero</param>
        /// <returns>equalizer band frequency (Hz), or -1 if there is no such band</returns>
        /// <remarks>
        /// <para>This value can be used, for example, to create a label for an equalizer band control</para>
        /// <para>in a user interface.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static float LibvlcAudioEqualizerGetBandFrequency(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetBandFrequency(u_index);
            return __ret;
        }

        /// <summary>Create a new default equalizer, with all frequency values zeroed.</summary>
        /// <returns>opaque equalizer handle, or NULL on error</returns>
        /// <remarks>
        /// <para>The new equalizer can subsequently be applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The returned handle should be freed via libvlc_audio_equalizer_release() when</para>
        /// <para>it is no longer needed.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcEqualizerT LibvlcAudioEqualizerNew()
        {
            var __ret = __Internal.LibvlcAudioEqualizerNew();
            global::libvlc.LibvlcEqualizerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEqualizerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEqualizerT) global::libvlc.LibvlcEqualizerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEqualizerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a new equalizer, with initial frequency values copied from an existing</para>
        /// <para>preset.</para>
        /// </summary>
        /// <param name="u_index">index of the preset, counting from zero</param>
        /// <returns>opaque equalizer handle, or NULL on error</returns>
        /// <remarks>
        /// <para>The new equalizer can subsequently be applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The returned handle should be freed via libvlc_audio_equalizer_release() when</para>
        /// <para>it is no longer needed.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcEqualizerT LibvlcAudioEqualizerNewFromPreset(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerNewFromPreset(u_index);
            global::libvlc.LibvlcEqualizerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEqualizerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEqualizerT) global::libvlc.LibvlcEqualizerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEqualizerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release a previously created equalizer instance.</summary>
        /// <param name="p_equalizer">opaque equalizer handle, or NULL</param>
        /// <remarks>
        /// <para>The equalizer was previously created by using libvlc_audio_equalizer_new() or</para>
        /// <para>libvlc_audio_equalizer_new_from_preset().</para>
        /// <para>It is safe to invoke this method with a NULL p_equalizer parameter for no effect.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioEqualizerRelease(global::libvlc.LibvlcEqualizerT p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            __Internal.LibvlcAudioEqualizerRelease(__arg0);
        }

        /// <summary>Set a new pre-amplification value for an equalizer.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="f_preamp">preamp value (-20.0 to 20.0 Hz)</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The new equalizer settings are subsequently applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The supplied amplification value will be clamped to the -20.0 to +20.0 range.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcAudioEqualizerSetPreamp(global::libvlc.LibvlcEqualizerT p_equalizer, float f_preamp)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerSetPreamp(__arg0, f_preamp);
            return __ret;
        }

        /// <summary>Get the current pre-amplification value from an equalizer.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <returns>preamp value (Hz)</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static float LibvlcAudioEqualizerGetPreamp(global::libvlc.LibvlcEqualizerT p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerGetPreamp(__arg0);
            return __ret;
        }

        /// <summary>Set a new amplification value for a particular equalizer frequency band.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="f_amp">amplification value (-20.0 to 20.0 Hz)</param>
        /// <param name="u_band">index, counting from zero, of the frequency band to set</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The new equalizer settings are subsequently applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The supplied amplification value will be clamped to the -20.0 to +20.0 range.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcAudioEqualizerSetAmpAtIndex(global::libvlc.LibvlcEqualizerT p_equalizer, float f_amp, uint u_band)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerSetAmpAtIndex(__arg0, f_amp, u_band);
            return __ret;
        }

        /// <summary>Get the amplification value for a particular equalizer frequency band.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="u_band">index, counting from zero, of the frequency band to get</param>
        /// <returns>amplification value (Hz); NaN if there is no such frequency band</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static float LibvlcAudioEqualizerGetAmpAtIndex(global::libvlc.LibvlcEqualizerT p_equalizer, uint u_band)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerGetAmpAtIndex(__arg0, u_band);
            return __ret;
        }

        /// <summary>Apply new equalizer settings to a media player.</summary>
        /// <param name="p_mi">opaque media player handle</param>
        /// <param name="p_equalizer">opaque equalizer handle, or NULL to disable the equalizer for this media player</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The equalizer is first created by invoking libvlc_audio_equalizer_new() or</para>
        /// <para>libvlc_audio_equalizer_new_from_preset().</para>
        /// <para>It is possible to apply new equalizer settings to a media player whether the media</para>
        /// <para>player is currently playing media or not.</para>
        /// <para>Invoking this method will immediately apply the new equalizer settings to the audio</para>
        /// <para>output of the currently playing media if there is any.</para>
        /// <para>If there is no currently playing media, the new equalizer settings will be applied</para>
        /// <para>later if and when new media is played.</para>
        /// <para>Equalizer settings will automatically be applied to subsequently played media.</para>
        /// <para>To disable the equalizer for a media player invoke this method passing NULL for the</para>
        /// <para>p_equalizer parameter.</para>
        /// <para>The media player does not keep a reference to the supplied equalizer so it is safe</para>
        /// <para>for an application to release the equalizer reference any time after this method</para>
        /// <para>returns.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaPlayerSetEqualizer(global::libvlc.LibvlcMediaPlayerT p_mi, global::libvlc.LibvlcEqualizerT p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetEqualizer(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Gets the media role.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the media player role (</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetRole(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetRole(__arg0);
            return __ret;
        }

        /// <summary>Sets the media role.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="role">the media player role (</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcMediaPlayerSetRole(global::libvlc.LibvlcMediaPlayerT p_mi, uint role)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetRole(__arg0, role);
            return __ret;
        }
    }

    /// <summary>A LibVLC media list holds multiple</summary>
    /// <remarks>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media list (playlist) external API</para>
    /// </remarks>
    public unsafe partial class libvlc_media_list
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_new")]
            internal static extern global::System.IntPtr LibvlcMediaListNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_release")]
            internal static extern void LibvlcMediaListRelease(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_retain")]
            internal static extern void LibvlcMediaListRetain(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_set_media")]
            internal static extern void LibvlcMediaListSetMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_media")]
            internal static extern global::System.IntPtr LibvlcMediaListMedia(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_add_media")]
            internal static extern int LibvlcMediaListAddMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_insert_media")]
            internal static extern int LibvlcMediaListInsertMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_remove_index")]
            internal static extern int LibvlcMediaListRemoveIndex(global::System.IntPtr p_ml, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_count")]
            internal static extern int LibvlcMediaListCount(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_item_at_index")]
            internal static extern global::System.IntPtr LibvlcMediaListItemAtIndex(global::System.IntPtr p_ml, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_index_of_item")]
            internal static extern int LibvlcMediaListIndexOfItem(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_is_readonly")]
            internal static extern int LibvlcMediaListIsReadonly(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_lock")]
            internal static extern void LibvlcMediaListLock(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_unlock")]
            internal static extern void LibvlcMediaListUnlock(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaListEventManager(global::System.IntPtr p_ml);
        }

        /// <summary>Create an empty media list.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>empty media list, or NULL on error</returns>
        public static global::libvlc.LibvlcMediaListT LibvlcMediaListNew(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaListNew(__arg0);
            global::libvlc.LibvlcMediaListT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaListT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaListT) global::libvlc.LibvlcMediaListT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaListT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release media list created with libvlc_media_list_new().</summary>
        /// <param name="p_ml">a media list created with libvlc_media_list_new()</param>
        public static void LibvlcMediaListRelease(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListRelease(__arg0);
        }

        /// <summary>Retain reference to a media list</summary>
        /// <param name="p_ml">a media list created with libvlc_media_list_new()</param>
        public static void LibvlcMediaListRetain(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListRetain(__arg0);
        }

        /// <summary>
        /// <para>Associate media instance with this media list instance.</para>
        /// <para>If another media instance was present it will be released.</para>
        /// <para>The libvlc_media_list_lock should NOT be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">media instance to add</param>
        public static void LibvlcMediaListSetMedia(global::libvlc.LibvlcMediaListT p_ml, global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaListSetMedia(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Get media instance from this media list instance. This action will increase</para>
        /// <para>the refcount on the media instance.</para>
        /// <para>The libvlc_media_list_lock should NOT be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>media instance</returns>
        public static global::libvlc.LibvlcMediaT LibvlcMediaListMedia(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListMedia(__arg0);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Add media instance to media list</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">a media instance</param>
        /// <returns>0 on success, -1 if the media list is read-only</returns>
        public static int LibvlcMediaListAddMedia(global::libvlc.LibvlcMediaListT p_ml, global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListAddMedia(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Insert media instance in media list on a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">a media instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>0 on success, -1 if the media list is read-only</returns>
        public static int LibvlcMediaListInsertMedia(global::libvlc.LibvlcMediaListT p_ml, global::libvlc.LibvlcMediaT p_md, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListInsertMedia(__arg0, __arg1, i_pos);
            return __ret;
        }

        /// <summary>
        /// <para>Remove media instance from media list on a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>0 on success, -1 if the list is read-only or the item was not found</returns>
        public static int LibvlcMediaListRemoveIndex(global::libvlc.LibvlcMediaListT p_ml, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListRemoveIndex(__arg0, i_pos);
            return __ret;
        }

        /// <summary>
        /// <para>Get count on media list items</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>number of items in media list</returns>
        public static int LibvlcMediaListCount(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>List media instance in media list at a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>
        /// <para>media instance at position i_pos, or NULL if not found.</para>
        /// <para>In case of success, libvlc_media_retain() is called to increase the refcount</para>
        /// <para>on the media.</para>
        /// </returns>
        public static global::libvlc.LibvlcMediaT LibvlcMediaListItemAtIndex(global::libvlc.LibvlcMediaListT p_ml, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListItemAtIndex(__arg0, i_pos);
            global::libvlc.LibvlcMediaT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaT) global::libvlc.LibvlcMediaT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Find index position of List media instance in media list.</para>
        /// <para>Warning: the function will return the first matched position.</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">media instance</param>
        /// <returns>position of media instance or -1 if media not found</returns>
        public static int LibvlcMediaListIndexOfItem(global::libvlc.LibvlcMediaListT p_ml, global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListIndexOfItem(__arg0, __arg1);
            return __ret;
        }

        /// <summary>This indicates if this media list is read-only from a user point of view</summary>
        /// <param name="p_ml">media list instance</param>
        /// <returns>1 on readonly, 0 on readwrite</returns>
        public static int LibvlcMediaListIsReadonly(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListIsReadonly(__arg0);
            return __ret;
        }

        /// <summary>Get lock on media list items</summary>
        /// <param name="p_ml">a media list instance</param>
        public static void LibvlcMediaListLock(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListLock(__arg0);
        }

        /// <summary>
        /// <para>Release lock on media list items</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        public static void LibvlcMediaListUnlock(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListUnlock(__arg0);
        }

        /// <summary>
        /// <para>Get libvlc_event_manager from this media list instance.</para>
        /// <para>The p_event_manager is immutable, so you don't have to hold the lock</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>libvlc_event_manager</returns>
        public static global::libvlc.LibvlcEventManagerT LibvlcMediaListEventManager(global::libvlc.LibvlcMediaListT p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>Defines playback modes for playlist.</summary>
    public enum LibvlcPlaybackModeT
    {
        LibvlcPlaybackModeDefault = 0,
        LibvlcPlaybackModeLoop = 1,
        LibvlcPlaybackModeRepeat = 2
    }

    /// <summary>The LibVLC media list player plays a</summary>
    /// <remarks>
    /// <para>in a certain order.</para>
    /// <para>This is required to especially support playlist files.</para>
    /// <para>The normal</para>
    /// <para>single media, and does not handle playlist files properly.</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media list player external API</para>
    /// </remarks>
    public unsafe partial class LibvlcMediaListPlayerT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaListPlayerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaListPlayerT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaListPlayerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaListPlayerT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaListPlayerT __CreateInstance(global::libvlc.LibvlcMediaListPlayerT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaListPlayerT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaListPlayerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaListPlayerT.__Internal));
            *(global::libvlc.LibvlcMediaListPlayerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaListPlayerT(global::libvlc.LibvlcMediaListPlayerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaListPlayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class libvlc_media_list_player
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_new")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_release")]
            internal static extern void LibvlcMediaListPlayerRelease(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_retain")]
            internal static extern void LibvlcMediaListPlayerRetain(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerEventManager(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_media_player")]
            internal static extern void LibvlcMediaListPlayerSetMediaPlayer(global::System.IntPtr p_mlp, global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_get_media_player")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerGetMediaPlayer(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_media_list")]
            internal static extern void LibvlcMediaListPlayerSetMediaList(global::System.IntPtr p_mlp, global::System.IntPtr p_mlist);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play")]
            internal static extern void LibvlcMediaListPlayerPlay(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_pause")]
            internal static extern void LibvlcMediaListPlayerPause(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_is_playing")]
            internal static extern int LibvlcMediaListPlayerIsPlaying(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_get_state")]
            internal static extern global::libvlc.LibvlcStateT LibvlcMediaListPlayerGetState(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play_item_at_index")]
            internal static extern int LibvlcMediaListPlayerPlayItemAtIndex(global::System.IntPtr p_mlp, int i_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play_item")]
            internal static extern int LibvlcMediaListPlayerPlayItem(global::System.IntPtr p_mlp, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_stop")]
            internal static extern void LibvlcMediaListPlayerStop(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_next")]
            internal static extern int LibvlcMediaListPlayerNext(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_previous")]
            internal static extern int LibvlcMediaListPlayerPrevious(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_playback_mode")]
            internal static extern void LibvlcMediaListPlayerSetPlaybackMode(global::System.IntPtr p_mlp, global::libvlc.LibvlcPlaybackModeT e_mode);
        }

        /// <summary>Create new media_list_player.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>media list player instance or NULL on error</returns>
        public static global::libvlc.LibvlcMediaListPlayerT LibvlcMediaListPlayerNew(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerNew(__arg0);
            global::libvlc.LibvlcMediaListPlayerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaListPlayerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaListPlayerT) global::libvlc.LibvlcMediaListPlayerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaListPlayerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release a media_list_player after use</para>
        /// <para>Decrement the reference count of a media player object. If the</para>
        /// <para>reference count is 0, then libvlc_media_list_player_release() will</para>
        /// <para>release the media player object. If the media player object</para>
        /// <para>has been released, then it should not be used again.</para>
        /// </summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerRelease(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media player list object. Use</para>
        /// <para>libvlc_media_list_player_release() to decrement reference count.</para>
        /// </summary>
        /// <param name="p_mlp">media player list object</param>
        public static void LibvlcMediaListPlayerRetain(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerRetain(__arg0);
        }

        /// <summary>Return the event manager of this media_list_player.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>the event manager</returns>
        public static global::libvlc.LibvlcEventManagerT LibvlcMediaListPlayerEventManager(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Replace media player in media_list_player with this instance.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_mi">media player instance</param>
        public static void LibvlcMediaListPlayerSetMediaPlayer(global::libvlc.LibvlcMediaListPlayerT p_mlp, global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaListPlayerSetMediaPlayer(__arg0, __arg1);
        }

        /// <summary>Get media player of the media_list_player instance.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>media player instance</returns>
        /// <remarks>the caller is responsible for releasing the returned instance</remarks>
        public static global::libvlc.LibvlcMediaPlayerT LibvlcMediaListPlayerGetMediaPlayer(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerGetMediaPlayer(__arg0);
            global::libvlc.LibvlcMediaPlayerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaPlayerT) global::libvlc.LibvlcMediaPlayerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaPlayerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set the media list associated with the player</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_mlist">list of media</param>
        public static void LibvlcMediaListPlayerSetMediaList(global::libvlc.LibvlcMediaListPlayerT p_mlp, global::libvlc.LibvlcMediaListT p_mlist)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_mlist, null) ? global::System.IntPtr.Zero : p_mlist.__Instance;
            __Internal.LibvlcMediaListPlayerSetMediaList(__arg0, __arg1);
        }

        /// <summary>Play media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerPlay(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerPlay(__arg0);
        }

        /// <summary>Toggle pause (or resume) media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerPause(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerPause(__arg0);
        }

        /// <summary>Is media list playing?</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>true for playing and false for not playing</returns>
        public static int LibvlcMediaListPlayerIsPlaying(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerIsPlaying(__arg0);
            return __ret;
        }

        /// <summary>Get current libvlc_state of media list player</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>libvlc_state_t for media list player</returns>
        public static global::libvlc.LibvlcStateT LibvlcMediaListPlayerGetState(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerGetState(__arg0);
            return __ret;
        }

        /// <summary>Play media list item at position index</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="i_index">index in media list to play</param>
        /// <returns>0 upon success -1 if the item wasn't found</returns>
        public static int LibvlcMediaListPlayerPlayItemAtIndex(global::libvlc.LibvlcMediaListPlayerT p_mlp, int i_index)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPlayItemAtIndex(__arg0, i_index);
            return __ret;
        }

        /// <summary>Play the given media item</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_md">the media instance</param>
        /// <returns>0 upon success, -1 if the media is not part of the media list</returns>
        public static int LibvlcMediaListPlayerPlayItem(global::libvlc.LibvlcMediaListPlayerT p_mlp, global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPlayItem(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Stop playing media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerStop(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerStop(__arg0);
        }

        /// <summary>Play next item from media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>0 upon success -1 if there is no next item</returns>
        public static int LibvlcMediaListPlayerNext(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerNext(__arg0);
            return __ret;
        }

        /// <summary>Play previous item from media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>0 upon success -1 if there is no previous item</returns>
        public static int LibvlcMediaListPlayerPrevious(global::libvlc.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPrevious(__arg0);
            return __ret;
        }

        /// <summary>Sets the playback mode for the playlist</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="e_mode">playback mode specification</param>
        public static void LibvlcMediaListPlayerSetPlaybackMode(global::libvlc.LibvlcMediaListPlayerT p_mlp, global::libvlc.LibvlcPlaybackModeT e_mode)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerSetPlaybackMode(__arg0, e_mode);
        }
    }

    /// <summary>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media library external API</para>
    /// </summary>
    public unsafe partial class LibvlcMediaLibraryT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaLibraryT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaLibraryT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaLibraryT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaLibraryT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaLibraryT __CreateInstance(global::libvlc.LibvlcMediaLibraryT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaLibraryT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaLibraryT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaLibraryT.__Internal));
            *(global::libvlc.LibvlcMediaLibraryT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaLibraryT(global::libvlc.LibvlcMediaLibraryT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaLibraryT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class libvlc_media_library
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_new")]
            internal static extern global::System.IntPtr LibvlcMediaLibraryNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_release")]
            internal static extern void LibvlcMediaLibraryRelease(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_retain")]
            internal static extern void LibvlcMediaLibraryRetain(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_load")]
            internal static extern int LibvlcMediaLibraryLoad(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_media_list")]
            internal static extern global::System.IntPtr LibvlcMediaLibraryMediaList(global::System.IntPtr p_mlib);
        }

        /// <summary>Create an new Media Library object</summary>
        /// <param name="p_instance">the libvlc instance</param>
        /// <returns>a new object or NULL on error</returns>
        public static global::libvlc.LibvlcMediaLibraryT LibvlcMediaLibraryNew(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryNew(__arg0);
            global::libvlc.LibvlcMediaLibraryT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaLibraryT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaLibraryT) global::libvlc.LibvlcMediaLibraryT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaLibraryT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release media library object. This functions decrements the</para>
        /// <para>reference count of the media library object. If it reaches 0,</para>
        /// <para>then the object will be released.</para>
        /// </summary>
        /// <param name="p_mlib">media library object</param>
        public static void LibvlcMediaLibraryRelease(global::libvlc.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            __Internal.LibvlcMediaLibraryRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media library object. This function will</para>
        /// <para>increment the reference counting for this object. Use</para>
        /// <para>libvlc_media_library_release() to decrement the reference count.</para>
        /// </summary>
        /// <param name="p_mlib">media library object</param>
        public static void LibvlcMediaLibraryRetain(global::libvlc.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            __Internal.LibvlcMediaLibraryRetain(__arg0);
        }

        /// <summary>Load media library.</summary>
        /// <param name="p_mlib">media library object</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcMediaLibraryLoad(global::libvlc.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryLoad(__arg0);
            return __ret;
        }

        /// <summary>Get media library subitems.</summary>
        /// <param name="p_mlib">media library object</param>
        /// <returns>media list subitems</returns>
        public static global::libvlc.LibvlcMediaListT LibvlcMediaLibraryMediaList(global::libvlc.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryMediaList(__arg0);
            global::libvlc.LibvlcMediaListT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaListT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaListT) global::libvlc.LibvlcMediaListT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaListT.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>Category of a media discoverer</summary>
    /// <remarks>libvlc_media_discoverer_list_get()</remarks>
    public enum LibvlcMediaDiscovererCategoryT
    {
        /// <summary>devices, like portable music player</summary>
        LibvlcMediaDiscovererDevices = 0,
        /// <summary>LAN/WAN services, like Upnp, SMB, or SAP</summary>
        LibvlcMediaDiscovererLan = 1,
        /// <summary>Podcasts</summary>
        LibvlcMediaDiscovererPodcasts = 2,
        /// <summary>Local directories, like Video, Music or Pictures directories</summary>
        LibvlcMediaDiscovererLocaldirs = 3
    }

    /// <summary>
    /// <para>LibVLC media discovery finds available media via various means.</para>
    /// <para>This corresponds to the service discovery functionality in VLC media player.</para>
    /// <para>Different plugins find potential medias locally (e.g. user media directory),</para>
    /// <para>from peripherals (e.g. video capture device), on the local network</para>
    /// <para>(e.g. SAP) or on the Internet (e.g. Internet radios).</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media discovery external API</para>
    /// </summary>
    public unsafe partial class LibvlcMediaDiscovererT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaDiscovererT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaDiscovererT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaDiscovererT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaDiscovererT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaDiscovererT __CreateInstance(global::libvlc.LibvlcMediaDiscovererT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaDiscovererT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaDiscovererT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaDiscovererT.__Internal));
            *(global::libvlc.LibvlcMediaDiscovererT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaDiscovererT(global::libvlc.LibvlcMediaDiscovererT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaDiscovererT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Media discoverer description</summary>
    /// <remarks>libvlc_media_discoverer_list_get()</remarks>
    public unsafe partial class LibvlcMediaDiscovererDescriptionT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_longname;

            [FieldOffset(16)]
            internal global::libvlc.LibvlcMediaDiscovererCategoryT i_cat;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaDiscovererDescriptionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcMediaDiscovererDescriptionT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcMediaDiscovererDescriptionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaDiscovererDescriptionT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcMediaDiscovererDescriptionT __CreateInstance(global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcMediaDiscovererDescriptionT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal));
            *(global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaDiscovererDescriptionT(global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaDiscovererDescriptionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcMediaDiscovererDescriptionT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public global::libvlc.LibvlcMediaDiscovererCategoryT ICat
        {
            get
            {
                return ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->i_cat;
            }

            set
            {
                ((global::libvlc.LibvlcMediaDiscovererDescriptionT.__Internal*) __Instance)->i_cat = value;
            }
        }
    }

    public unsafe partial class libvlc_media_discoverer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_new")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNew(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_start")]
            internal static extern int LibvlcMediaDiscovererStart(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_stop")]
            internal static extern void LibvlcMediaDiscovererStop(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_release")]
            internal static extern void LibvlcMediaDiscovererRelease(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_media_list")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererMediaList(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_is_running")]
            internal static extern int LibvlcMediaDiscovererIsRunning(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_list_get")]
            internal static extern ulong LibvlcMediaDiscovererListGet(global::System.IntPtr p_inst, global::libvlc.LibvlcMediaDiscovererCategoryT i_cat, global::System.IntPtr ppp_services);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_list_release")]
            internal static extern void LibvlcMediaDiscovererListRelease(global::System.IntPtr pp_services, ulong i_count);
        }

        /// <summary>Create a media discoverer object by name.</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="psz_name">
        /// <para>service name; use libvlc_media_discoverer_list_get() to get</para>
        /// <para>a list of the discoverer names available in this libVLC instance</para>
        /// </param>
        /// <returns>media discover object or NULL in case of error</returns>
        /// <remarks>
        /// <para>After this object is created, you should attach to media_list events in</para>
        /// <para>order to be notified of new items discovered.</para>
        /// <para>You need to call libvlc_media_discoverer_start() in order to start the</para>
        /// <para>discovery.</para>
        /// <para>libvlc_media_discoverer_media_list</para>
        /// <para>libvlc_media_discoverer_event_manager</para>
        /// <para>libvlc_media_discoverer_start</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlc.LibvlcMediaDiscovererT LibvlcMediaDiscovererNew(global::libvlc.LibvlcInstanceT p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererNew(__arg0, psz_name);
            global::libvlc.LibvlcMediaDiscovererT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaDiscovererT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaDiscovererT) global::libvlc.LibvlcMediaDiscovererT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaDiscovererT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start media discovery.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>To stop it, call libvlc_media_discoverer_stop() or</para>
        /// <para>libvlc_media_discoverer_list_release() directly.</para>
        /// <para>libvlc_media_discoverer_stop</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaDiscovererStart(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererStart(__arg0);
            return __ret;
        }

        /// <summary>Stop media discovery.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <remarks>
        /// <para>libvlc_media_discoverer_start</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcMediaDiscovererStop(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            __Internal.LibvlcMediaDiscovererStop(__arg0);
        }

        /// <summary>
        /// <para>Release media discover object. If the reference count reaches 0, then</para>
        /// <para>the object will be released.</para>
        /// </summary>
        /// <param name="p_mdis">media service discover object</param>
        public static void LibvlcMediaDiscovererRelease(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            __Internal.LibvlcMediaDiscovererRelease(__arg0);
        }

        /// <summary>Get media service discover media list.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>list of media items</returns>
        public static global::libvlc.LibvlcMediaListT LibvlcMediaDiscovererMediaList(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererMediaList(__arg0);
            global::libvlc.LibvlcMediaListT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaListT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaListT) global::libvlc.LibvlcMediaListT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaListT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Query if media service discover object is running.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>true if running, false if not</returns>
        public static int LibvlcMediaDiscovererIsRunning(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererIsRunning(__arg0);
            return __ret;
        }

        /// <summary>Get media discoverer services by category</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="i_cat">category of services to fetch</param>
        /// <param name="ppp_services">
        /// <para>address to store an allocated array of media discoverer</para>
        /// <para>services (must be freed with libvlc_media_discoverer_list_release() by</para>
        /// <para>the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of media discoverer services (0 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static ulong LibvlcMediaDiscovererListGet(global::libvlc.LibvlcInstanceT p_inst, global::libvlc.LibvlcMediaDiscovererCategoryT i_cat, global::libvlc.LibvlcMediaDiscovererDescriptionT ppp_services)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __arg2 = ReferenceEquals(ppp_services, null) ? global::System.IntPtr.Zero : ppp_services.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererListGet(__arg0, i_cat, __arg2);
            return __ret;
        }

        /// <summary>Release an array of media discoverer services</summary>
        /// <param name="pp_services">array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_discoverer_list_get()</para>
        /// </remarks>
        public static void LibvlcMediaDiscovererListRelease(global::libvlc.LibvlcMediaDiscovererDescriptionT pp_services, ulong i_count)
        {
            var __arg0 = ReferenceEquals(pp_services, null) ? global::System.IntPtr.Zero : pp_services.__Instance;
            __Internal.LibvlcMediaDiscovererListRelease(__arg0, i_count);
        }
    }

    /// <summary>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC dialog external API</para>
    /// </summary>
    public enum LibvlcDialogQuestionType
    {
        LIBVLC_DIALOG_QUESTION_NORMAL = 0,
        LIBVLC_DIALOG_QUESTION_WARNING = 1,
        LIBVLC_DIALOG_QUESTION_CRITICAL = 2
    }

    public unsafe partial class LibvlcDialogId
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcDialogId> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcDialogId>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcDialogId __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcDialogId(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcDialogId __CreateInstance(global::libvlc.LibvlcDialogId.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcDialogId(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcDialogId.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcDialogId.__Internal));
            *(global::libvlc.LibvlcDialogId.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcDialogId(global::libvlc.LibvlcDialogId.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcDialogId(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Dialog callbacks to be implemented</summary>
    public unsafe partial class LibvlcDialogCbs : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr pf_display_error;

            [FieldOffset(8)]
            internal global::System.IntPtr pf_display_login;

            [FieldOffset(16)]
            internal global::System.IntPtr pf_display_question;

            [FieldOffset(24)]
            internal global::System.IntPtr pf_display_progress;

            [FieldOffset(32)]
            internal global::System.IntPtr pf_cancel;

            [FieldOffset(40)]
            internal global::System.IntPtr pf_update_progress;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcDialogCbs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcDialogCbs>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcDialogCbs __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcDialogCbs(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcDialogCbs __CreateInstance(global::libvlc.LibvlcDialogCbs.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcDialogCbs(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcDialogCbs.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcDialogCbs.__Internal));
            *(global::libvlc.LibvlcDialogCbs.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcDialogCbs(global::libvlc.LibvlcDialogCbs.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcDialogCbs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcDialogCbs __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class libvlc_dialog
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_set_callbacks")]
            internal static extern void LibvlcDialogSetCallbacks(global::System.IntPtr p_instance, global::System.IntPtr p_cbs, global::System.IntPtr p_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_set_context")]
            internal static extern void LibvlcDialogSetContext(global::System.IntPtr p_id, global::System.IntPtr p_context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_get_context")]
            internal static extern global::System.IntPtr LibvlcDialogGetContext(global::System.IntPtr p_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_post_login")]
            internal static extern int LibvlcDialogPostLogin(global::System.IntPtr p_id, [MarshalAs(UnmanagedType.LPStr)] string psz_username, [MarshalAs(UnmanagedType.LPStr)] string psz_password, bool b_store);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_post_action")]
            internal static extern int LibvlcDialogPostAction(global::System.IntPtr p_id, int i_action);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_dismiss")]
            internal static extern int LibvlcDialogDismiss(global::System.IntPtr p_id);
        }

        /// <summary>Register callbacks in order to handle VLC dialogs</summary>
        /// <param name="p_cbs">a pointer to callbacks, or NULL to unregister callbacks.</param>
        /// <param name="p_data">opaque pointer for the callback</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcDialogSetCallbacks(global::libvlc.LibvlcInstanceT p_instance, global::libvlc.LibvlcDialogCbs p_cbs, global::System.IntPtr p_data)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __arg1 = ReferenceEquals(p_cbs, null) ? global::System.IntPtr.Zero : p_cbs.__Instance;
            __Internal.LibvlcDialogSetCallbacks(__arg0, __arg1, p_data);
        }

        /// <summary>Associate an opaque pointer with the dialog id</summary>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcDialogSetContext(global::libvlc.LibvlcDialogId p_id, global::System.IntPtr p_context)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            __Internal.LibvlcDialogSetContext(__arg0, p_context);
        }

        /// <summary>Return the opaque pointer associated with the dialog id</summary>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static global::System.IntPtr LibvlcDialogGetContext(global::libvlc.LibvlcDialogId p_id)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogGetContext(__arg0);
            return __ret;
        }

        /// <summary>Post a login answer</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <param name="psz_username">valid and non empty string</param>
        /// <param name="psz_password">valid string (can be empty)</param>
        /// <param name="b_store">if true, store the credentials</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_display_login</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogPostLogin(global::libvlc.LibvlcDialogId p_id, string psz_username, string psz_password, bool b_store)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogPostLogin(__arg0, psz_username, psz_password, b_store);
            return __ret;
        }

        /// <summary>Post a question answer</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <param name="i_action">1 for action1, 2 for action2</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_display_question</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogPostAction(global::libvlc.LibvlcDialogId p_id, int i_action)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogPostAction(__arg0, i_action);
            return __ret;
        }

        /// <summary>Dismiss a dialog</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_cancel</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogDismiss(global::libvlc.LibvlcDialogId p_id)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogDismiss(__arg0);
            return __ret;
        }
    }

    public unsafe partial class libvlc_vlm
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_release")]
            internal static extern void LibvlcVlmRelease(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_broadcast")]
            internal static extern int LibvlcVlmAddBroadcast(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_vod")]
            internal static extern int LibvlcVlmAddVod(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, int i_options, sbyte** ppsz_options, int b_enabled, [MarshalAs(UnmanagedType.LPStr)] string psz_mux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_del_media")]
            internal static extern int LibvlcVlmDelMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_enabled")]
            internal static extern int LibvlcVlmSetEnabled(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int b_enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_output")]
            internal static extern int LibvlcVlmSetOutput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_input")]
            internal static extern int LibvlcVlmSetInput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_input")]
            internal static extern int LibvlcVlmAddInput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_loop")]
            internal static extern int LibvlcVlmSetLoop(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_mux")]
            internal static extern int LibvlcVlmSetMux(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_mux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_change_media")]
            internal static extern int LibvlcVlmChangeMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_play_media")]
            internal static extern int LibvlcVlmPlayMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_stop_media")]
            internal static extern int LibvlcVlmStopMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_pause_media")]
            internal static extern int LibvlcVlmPauseMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_seek_media")]
            internal static extern int LibvlcVlmSeekMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, float f_percentage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_show_media")]
            internal static extern global::System.IntPtr LibvlcVlmShowMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_position")]
            internal static extern float LibvlcVlmGetMediaInstancePosition(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_time")]
            internal static extern int LibvlcVlmGetMediaInstanceTime(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_length")]
            internal static extern int LibvlcVlmGetMediaInstanceLength(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_rate")]
            internal static extern int LibvlcVlmGetMediaInstanceRate(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_event_manager")]
            internal static extern global::System.IntPtr LibvlcVlmGetEventManager(global::System.IntPtr p_instance);
        }

        /// <summary>Release the vlm instance related to the given libvlc_instance_t</summary>
        /// <param name="p_instance">the instance</param>
        public static void LibvlcVlmRelease(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcVlmRelease(__arg0);
        }

        /// <summary>Add a broadcast, with one input.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new broadcast</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new broadcast</param>
        /// <param name="b_loop">Should this broadcast be played in loop ?</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddBroadcast(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_input, string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddBroadcast(__arg0, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop);
            return __ret;
        }

        /// <summary>Add a vod, with one input.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new vod media</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new vod</param>
        /// <param name="psz_mux">the muxer of the vod media</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddVod(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_input, int i_options, sbyte** ppsz_options, int b_enabled, string psz_mux)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddVod(__arg0, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux);
            return __ret;
        }

        /// <summary>Delete a media (VOD or broadcast).</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to delete</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmDelMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmDelMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Enable or disable a media (VOD or broadcast).</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="b_enabled">the new status</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetEnabled(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int b_enabled)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetEnabled(__arg0, psz_name, b_enabled);
            return __ret;
        }

        /// <summary>Set the output for a media.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetOutput(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetOutput(__arg0, psz_name, psz_output);
            return __ret;
        }

        /// <summary>
        /// <para>Set a media's input MRL. This will delete all existing inputs and</para>
        /// <para>add the specified one.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_input">the input MRL</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetInput(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_input)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetInput(__arg0, psz_name, psz_input);
            return __ret;
        }

        /// <summary>Add a media's input MRL. This will add the specified one.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_input">the input MRL</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddInput(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_input)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddInput(__arg0, psz_name, psz_input);
            return __ret;
        }

        /// <summary>Set a media's loop status.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="b_loop">the new status</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetLoop(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetLoop(__arg0, psz_name, b_loop);
            return __ret;
        }

        /// <summary>Set a media's vod muxer.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_mux">the new muxer</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetMux(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_mux)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetMux(__arg0, psz_name, psz_mux);
            return __ret;
        }

        /// <summary>
        /// <para>Edit the parameters of a media. This will delete all existing inputs and</para>
        /// <para>add the specified one.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new broadcast</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new broadcast</param>
        /// <param name="b_loop">Should this broadcast be played in loop ?</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmChangeMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name, string psz_input, string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmChangeMedia(__arg0, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop);
            return __ret;
        }

        /// <summary>Play the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmPlayMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmPlayMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Stop the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmStopMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmStopMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Pause the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmPauseMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmPauseMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Seek in the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <param name="f_percentage">the percentage to seek to</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSeekMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name, float f_percentage)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSeekMedia(__arg0, psz_name, f_percentage);
            return __ret;
        }

        /// <summary>
        /// <para>Return information about the named media as a JSON</para>
        /// <para>string representation.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">
        /// <para>the name of the media,</para>
        /// <para>if the name is an empty string, all media is described</para>
        /// </param>
        /// <returns>string with information about named media, or NULL on error</returns>
        /// <remarks>
        /// <para>This function is mainly intended for debugging use,</para>
        /// <para>if you want programmatic access to the state of</para>
        /// <para>a vlm_media_instance_t, please use the corresponding</para>
        /// <para>libvlc_vlm_get_media_instance_xxx -functions.</para>
        /// <para>Currently there are no such functions available for</para>
        /// <para>vlm_media_t though.</para>
        /// </remarks>
        public static string LibvlcVlmShowMedia(global::libvlc.LibvlcInstanceT p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmShowMedia(__arg0, psz_name);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get vlm_media instance position by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>position as float or -1. on error</returns>
        public static float LibvlcVlmGetMediaInstancePosition(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstancePosition(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance time by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>time as integer or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceTime(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceTime(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance length by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>length of media item or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceLength(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceLength(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance playback rate by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>playback rate or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceRate(global::libvlc.LibvlcInstanceT p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceRate(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>
        /// <para>Get libvlc_event_manager from a vlm media.</para>
        /// <para>The p_event_manager is immutable, so you don't have to hold the lock</para>
        /// </summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <returns>libvlc_event_manager</returns>
        public static global::libvlc.LibvlcEventManagerT LibvlcVlmGetEventManager(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>This structure is opaque. It represents a libvlc log iterator</summary>
    public unsafe partial class LibvlcLogIteratorT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcLogIteratorT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcLogIteratorT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcLogIteratorT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcLogIteratorT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcLogIteratorT __CreateInstance(global::libvlc.LibvlcLogIteratorT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcLogIteratorT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcLogIteratorT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcLogIteratorT.__Internal));
            *(global::libvlc.LibvlcLogIteratorT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcLogIteratorT(global::libvlc.LibvlcLogIteratorT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcLogIteratorT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcLogMessageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_severity;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_type;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_header;

            [FieldOffset(32)]
            internal global::System.IntPtr psz_message;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcLogMessageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlc.LibvlcLogMessageT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlc.LibvlcLogMessageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcLogMessageT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlc.LibvlcLogMessageT __CreateInstance(global::libvlc.LibvlcLogMessageT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlc.LibvlcLogMessageT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlc.LibvlcLogMessageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlc.LibvlcLogMessageT.__Internal));
            *(global::libvlc.LibvlcLogMessageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcLogMessageT(global::libvlc.LibvlcLogMessageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcLogMessageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlc.LibvlcLogMessageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ISeverity
        {
            get
            {
                return ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->i_severity;
            }

            set
            {
                ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->i_severity = value;
            }
        }

        public string PszType
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_type);
            }

            set
            {
                ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_type = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszName
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_name);
            }

            set
            {
                ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_name = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszHeader
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_header);
            }

            set
            {
                ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_header = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszMessage
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_message);
            }

            set
            {
                ((global::libvlc.LibvlcLogMessageT.__Internal*) __Instance)->psz_message = Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class deprecated
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_fps")]
            internal static extern float LibvlcMediaPlayerGetFps(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_agl")]
            internal static extern void LibvlcMediaPlayerSetAgl(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_agl")]
            internal static extern uint LibvlcMediaPlayerGetAgl(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_track_description_release")]
            internal static extern void LibvlcTrackDescriptionRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_height")]
            internal static extern int LibvlcVideoGetHeight(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_width")]
            internal static extern int LibvlcVideoGetWidth(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_title_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetTitleDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_chapter_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetChapterDescription(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_subtitle_file")]
            internal static extern int LibvlcVideoSetSubtitleFile(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_subtitle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_toggle_teletext")]
            internal static extern void LibvlcToggleTeletext(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_count")]
            internal static extern int LibvlcAudioOutputDeviceCount(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_longname")]
            internal static extern sbyte* LibvlcAudioOutputDeviceLongname(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_id")]
            internal static extern sbyte* LibvlcAudioOutputDeviceId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_get_device_type")]
            internal static extern int LibvlcAudioOutputGetDeviceType(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_set_device_type")]
            internal static extern void LibvlcAudioOutputSetDeviceType(global::System.IntPtr p_mp, int device_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse")]
            internal static extern void LibvlcMediaParse(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_async")]
            internal static extern void LibvlcMediaParseAsync(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_is_parsed")]
            internal static extern int LibvlcMediaIsParsed(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_tracks_info")]
            internal static extern int LibvlcMediaGetTracksInfo(global::System.IntPtr p_md, global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_add_file_content")]
            internal static extern int LibvlcMediaListAddFileContent(global::System.IntPtr p_ml, [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_new_from_name")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNewFromName(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_localized_name")]
            internal static extern sbyte* LibvlcMediaDiscovererLocalizedName(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererEventManager(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_wait")]
            internal static extern void LibvlcWait(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_log_verbosity")]
            internal static extern uint LibvlcGetLogVerbosity(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_log_verbosity")]
            internal static extern void LibvlcSetLogVerbosity(global::System.IntPtr p_instance, uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_open")]
            internal static extern global::System.IntPtr LibvlcLogOpen(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_close")]
            internal static extern void LibvlcLogClose(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_count")]
            internal static extern uint LibvlcLogCount(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_clear")]
            internal static extern void LibvlcLogClear(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_iterator")]
            internal static extern global::System.IntPtr LibvlcLogGetIterator(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_free")]
            internal static extern void LibvlcLogIteratorFree(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_has_next")]
            internal static extern int LibvlcLogIteratorHasNext(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_next")]
            internal static extern global::System.IntPtr LibvlcLogIteratorNext(global::System.IntPtr p_iter, global::System.IntPtr p_buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_playlist_play")]
            internal static extern void LibvlcPlaylistPlay(global::System.IntPtr p_instance, int i_id, int i_options, sbyte** ppsz_options);
        }

        /// <summary>Get movie fps rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>frames per second (fps) for this playing movie, or 0 if unspecified</returns>
        /// <remarks>
        /// <para>This function is provided for backward compatibility. It cannot deal with</para>
        /// <para>multiple video tracks. In LibVLC versions prior to 3.0, it would also fail</para>
        /// <para>if the file format did not convey the frame rate explicitly.</para>
        /// <para>Consider using libvlc_media_tracks_get() instead.</para>
        /// </remarks>
        public static float LibvlcMediaPlayerGetFps(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFps(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_media_player_set_nsobject() instead</remarks>
        public static void LibvlcMediaPlayerSetAgl(global::libvlc.LibvlcMediaPlayerT p_mi, uint drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetAgl(__arg0, drawable);
        }

        /// <remarks>Use libvlc_media_player_get_nsobject() instead</remarks>
        public static uint LibvlcMediaPlayerGetAgl(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetAgl(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_track_description_list_release() instead</remarks>
        public static void LibvlcTrackDescriptionRelease(global::libvlc.LibvlcTrackDescriptionT p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionRelease(__arg0);
        }

        /// <summary>Get current video height.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel height or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetHeight(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetHeight(__arg0);
            return __ret;
        }

        /// <summary>Get current video width.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel width or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetWidth(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetWidth(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available titles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available titles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlc.LibvlcTrackDescriptionT LibvlcVideoGetTitleDescription(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTitleDescription(__arg0);
            global::libvlc.LibvlcTrackDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the description of available chapters for specific title.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_title">selected title</param>
        /// <returns>
        /// <para>list containing description of available chapter for title i_title.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlc.LibvlcTrackDescriptionT LibvlcVideoGetChapterDescription(global::libvlc.LibvlcMediaPlayerT p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetChapterDescription(__arg0, i_title);
            global::libvlc.LibvlcTrackDescriptionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcTrackDescriptionT) global::libvlc.LibvlcTrackDescriptionT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcTrackDescriptionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set new video subtitle file.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_subtitle">new video subtitle file</param>
        /// <returns>the success status (boolean)</returns>
        /// <remarks>Use libvlc_media_player_add_slave() instead.</remarks>
        public static int LibvlcVideoSetSubtitleFile(global::libvlc.LibvlcMediaPlayerT p_mi, string psz_subtitle)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSubtitleFile(__arg0, psz_subtitle);
            return __ret;
        }

        /// <summary>Toggle teletext transparent status on video output.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>use libvlc_video_set_teletext() instead.</remarks>
        public static void LibvlcToggleTeletext(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcToggleTeletext(__arg0);
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always 0.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static int LibvlcAudioOutputDeviceCount(global::libvlc.LibvlcInstanceT p_instance, string psz_audio_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceCount(__arg0, psz_audio_output);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceLongname(global::libvlc.LibvlcInstanceT p_instance, string psz_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceLongname(__arg0, psz_output, i_device);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceId(global::libvlc.LibvlcInstanceT p_instance, string psz_audio_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceId(__arg0, psz_audio_output, i_device);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        /// <returns>always -1.</returns>
        public static int LibvlcAudioOutputGetDeviceType(global::libvlc.LibvlcMediaPlayerT p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioOutputGetDeviceType(__arg0);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        public static void LibvlcAudioOutputSetDeviceType(global::libvlc.LibvlcMediaPlayerT p_mp, int device_type)
        {
            var __arg0 = ReferenceEquals(p_mp, null) ? global::System.IntPtr.Zero : p_mp.__Instance;
            __Internal.LibvlcAudioOutputSetDeviceType(__arg0, device_type);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is synchronous.</para>
        /// <para>This function could block indefinitely.</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParse(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParse(__arg0);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is the asynchronous of libvlc_media_parse().</para>
        /// <para>To track when this is over you can listen to libvlc_MediaParsedChanged</para>
        /// <para>event. However if the media was already parsed you will not receive this</para>
        /// <para>event.</para>
        /// <para>You can't be sure to receive the libvlc_MediaParsedChanged</para>
        /// <para>event (you can wait indefinitely for this event).</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParseAsync(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParseAsync(__arg0);
        }

        /// <summary>Return true is the media descriptor object is parsed</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>true if media object has been parsed otherwise it returns false</returns>
        /// <remarks>
        /// <para>This can return true in case of failure.</para>
        /// <para>Use libvlc_media_get_parsed_status() instead</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// </remarks>
        public static int LibvlcMediaIsParsed(global::libvlc.LibvlcMediaT p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaIsParsed(__arg0);
            return __ret;
        }

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>Use libvlc_media_tracks_get() instead</para>
        /// </remarks>
        public static int LibvlcMediaGetTracksInfo(global::libvlc.LibvlcMediaT p_md, global::libvlc.LibvlcMediaTrackInfoT tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaGetTracksInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>@{</summary>
        public static int LibvlcMediaListAddFileContent(global::libvlc.LibvlcMediaListT p_ml, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListAddFileContent(__arg0, psz_uri);
            return __ret;
        }

        /// <remarks>Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start().</remarks>
        public static global::libvlc.LibvlcMediaDiscovererT LibvlcMediaDiscovererNewFromName(global::libvlc.LibvlcInstanceT p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererNewFromName(__arg0, psz_name);
            global::libvlc.LibvlcMediaDiscovererT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcMediaDiscovererT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcMediaDiscovererT) global::libvlc.LibvlcMediaDiscovererT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcMediaDiscovererT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media service discover object its localized name.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>localized name or NULL if the media_discoverer is not started</returns>
        /// <remarks>
        /// <para>Useless, use libvlc_media_discoverer_list_get() to get the</para>
        /// <para>longname of the service discovery.</para>
        /// </remarks>
        public static sbyte* LibvlcMediaDiscovererLocalizedName(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererLocalizedName(__arg0);
            return __ret;
        }

        /// <summary>Get event manager from media service discover object.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>event manager object.</returns>
        /// <remarks>
        /// <para>Useless, media_discoverer events are only triggered when calling</para>
        /// <para>libvlc_media_discoverer_start() and libvlc_media_discoverer_stop().</para>
        /// </remarks>
        public static global::libvlc.LibvlcEventManagerT LibvlcMediaDiscovererEventManager(global::libvlc.LibvlcMediaDiscovererT p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererEventManager(__arg0);
            global::libvlc.LibvlcEventManagerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcEventManagerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcEventManagerT) global::libvlc.LibvlcEventManagerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcEventManagerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Waits until an interface causes the instance to exit.</para>
        /// <para>You should start at least one interface first, using libvlc_add_intf().</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <remarks>
        /// <para>This function wastes one thread doing basically nothing.</para>
        /// <para>libvlc_set_exit_handler() should be used instead.</para>
        /// </remarks>
        public static void LibvlcWait(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcWait(__arg0);
        }

        /// <summary>
        /// <para>Always returns minus one.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <returns>always -1</returns>
        public static uint LibvlcGetLogVerbosity(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcGetLogVerbosity(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <param name="level">ignored</param>
        public static void LibvlcSetLogVerbosity(global::libvlc.LibvlcInstanceT p_instance, uint level)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetLogVerbosity(__arg0, level);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>an unique pointer or NULL on error</returns>
        public static global::libvlc.VlcLogT LibvlcLogOpen(global::libvlc.LibvlcInstanceT p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcLogOpen(__arg0);
            global::libvlc.VlcLogT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.VlcLogT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.VlcLogT) global::libvlc.VlcLogT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.VlcLogT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_open().</summary>
        /// <param name="p_log">libvlc log instance or NULL</param>
        public static void LibvlcLogClose(global::libvlc.VlcLogT p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClose(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>always zero</returns>
        public static uint LibvlcLogCount(global::libvlc.VlcLogT p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        public static void LibvlcLogClear(global::libvlc.VlcLogT p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClear(__arg0);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>an unique pointer or NULL on error or if the parameter was NULL</returns>
        public static global::libvlc.LibvlcLogIteratorT LibvlcLogGetIterator(global::libvlc.VlcLogT p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogGetIterator(__arg0);
            global::libvlc.LibvlcLogIteratorT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcLogIteratorT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcLogIteratorT) global::libvlc.LibvlcLogIteratorT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcLogIteratorT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_get_iterator().</summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        public static void LibvlcLogIteratorFree(global::libvlc.LibvlcLogIteratorT p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            __Internal.LibvlcLogIteratorFree(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">ignored</param>
        /// <returns>always zero</returns>
        public static int LibvlcLogIteratorHasNext(global::libvlc.LibvlcLogIteratorT p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.LibvlcLogIteratorHasNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Always returns NULL.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        /// <param name="p_buf">ignored</param>
        /// <returns>always NULL</returns>
        public static global::libvlc.LibvlcLogMessageT LibvlcLogIteratorNext(global::libvlc.LibvlcLogIteratorT p_iter, global::libvlc.LibvlcLogMessageT p_buf)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __arg1 = ReferenceEquals(p_buf, null) ? global::System.IntPtr.Zero : p_buf.__Instance;
            var __ret = __Internal.LibvlcLogIteratorNext(__arg0, __arg1);
            global::libvlc.LibvlcLogMessageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlc.LibvlcLogMessageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlc.LibvlcLogMessageT) global::libvlc.LibvlcLogMessageT.NativeToManagedMap[__ret];
            else __result0 = global::libvlc.LibvlcLogMessageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start playing (if there is any item in the playlist).</summary>
        /// <param name="p_instance">the playlist instance</param>
        /// <param name="i_id">
        /// <para>the item to play. If this is a negative number, the next</para>
        /// <para>item will be selected. Otherwise, the item with the given ID will be</para>
        /// <para>played</para>
        /// </param>
        /// <param name="i_options">the number of options to add to the item</param>
        /// <param name="ppsz_options">the options to add to the item</param>
        /// <remarks>
        /// <para>Additionnal playlist item options can be specified for addition to the</para>
        /// <para>item before it is played.</para>
        /// </remarks>
        public static void LibvlcPlaylistPlay(global::libvlc.LibvlcInstanceT p_instance, int i_id, int i_options, sbyte** ppsz_options)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcPlaylistPlay(__arg0, i_id, i_options, ppsz_options);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr _0);
    }
}
