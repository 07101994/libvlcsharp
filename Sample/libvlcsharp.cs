// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libvlcsharp
{
    /// <summary>Logging messages level.</summary>
    /// <remarks>Future LibVLC versions may define new levels.</remarks>
    public enum LogLevel
    {
        /// <summary>Debug message</summary>
        Debug = 0,
        /// <summary>Important informational message</summary>
        Notice = 2,
        /// <summary>Warning (potential error) message</summary>
        Warning = 3,
        /// <summary>Error message</summary>
        Error = 4
    }

    /// <summary>This structure is opaque. It represents a libvlc instance</summary>
    /// <summary>
    /// <para>Event manager that belongs to a libvlc object, and from whom events can</para>
    /// <para>be received.</para>
    /// </summary>
    /// <summary>Type of a LibVLC event.</summary>
    /// <summary>Callback function notification</summary>
    /// <param name="p_event">the event triggering the callback</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcCallbackT(global::System.IntPtr p_event, global::System.IntPtr p_data);

    public unsafe partial class Instance
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Instance> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Instance>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.Instance __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Instance(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.Instance __CreateInstance(global::libvlcsharp.Instance.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Instance(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.Instance.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.Instance.__Internal));
            *(global::libvlcsharp.Instance.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Instance(global::libvlcsharp.Instance.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Instance(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class EventManager
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.EventManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.EventManager>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.EventManager __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.EventManager(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.EventManager __CreateInstance(global::libvlcsharp.EventManager.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.EventManager(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.EventManager.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.EventManager.__Internal));
            *(global::libvlcsharp.EventManager.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private EventManager(global::libvlcsharp.EventManager.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Log
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Log(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.Log __CreateInstance(global::libvlcsharp.Log.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.Log.__Internal));
            *(global::libvlcsharp.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::libvlcsharp.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Description of a module.</summary>
    public unsafe partial class ModuleDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_shortname;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_longname;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_help;

            [FieldOffset(32)]
            internal global::System.IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_module_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ModuleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ModuleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.ModuleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ModuleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.ModuleDescription __CreateInstance(global::libvlcsharp.ModuleDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ModuleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.ModuleDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.__Internal));
            *(global::libvlcsharp.ModuleDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleDescription(global::libvlcsharp.ModuleDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ModuleDescription(global::libvlcsharp.ModuleDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.ModuleDescription.__Internal*) __Instance) = *((global::libvlcsharp.ModuleDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.ModuleDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszShortname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_shortname;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_shortname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszHelp
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_help;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->psz_help = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.ModuleDescription PNext
        {
            get
            {
                global::libvlcsharp.ModuleDescription __result0;
                if (((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlcsharp.ModuleDescription.NativeToManagedMap.ContainsKey(((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlcsharp.ModuleDescription) global::libvlcsharp.ModuleDescription.NativeToManagedMap[((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlcsharp.ModuleDescription.__CreateInstance(((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class libvlc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_errmsg")]
            internal static extern global::System.IntPtr LibvlcErrmsg();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clearerr")]
            internal static extern void LibvlcClearerr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_printerr")]
            internal static extern global::System.IntPtr LibvlcPrinterr([MarshalAs(UnmanagedType.LPStr)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_new")]
            internal static extern global::System.IntPtr LibvlcNew(int argc, sbyte** argv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_release")]
            internal static extern void LibvlcRelease(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_retain")]
            internal static extern void LibvlcRetain(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_add_intf")]
            internal static extern int LibvlcAddIntf(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_exit_handler")]
            internal static extern void LibvlcSetExitHandler(global::System.IntPtr p_instance, global::System.IntPtr cb, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_user_agent")]
            internal static extern void LibvlcSetUserAgent(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string http);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_app_id")]
            internal static extern void LibvlcSetAppId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string id, [MarshalAs(UnmanagedType.LPStr)] string version, [MarshalAs(UnmanagedType.LPStr)] string icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_version")]
            internal static extern global::System.IntPtr LibvlcGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_compiler")]
            internal static extern global::System.IntPtr LibvlcGetCompiler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_changeset")]
            internal static extern global::System.IntPtr LibvlcGetChangeset();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_free")]
            internal static extern void LibvlcFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_attach")]
            internal static extern int LibvlcEventAttach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_detach")]
            internal static extern void LibvlcEventDetach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr p_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_type_name")]
            internal static extern global::System.IntPtr LibvlcEventTypeName(int event_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_context")]
            internal static extern void LibvlcLogGetContext(global::System.IntPtr ctx, sbyte** module, sbyte** file, uint* line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_object")]
            internal static extern void LibvlcLogGetObject(global::System.IntPtr ctx, sbyte** name, sbyte** header, ulong* id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_unset")]
            internal static extern void LibvlcLogUnset(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_set_file")]
            internal static extern void LibvlcLogSetFile(global::System.IntPtr p_instance, global::System.IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_module_description_list_release")]
            internal static extern void LibvlcModuleDescriptionListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_filter_list_get")]
            internal static extern global::System.IntPtr LibvlcVideoFilterListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clock")]
            internal static extern long LibvlcClock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?libvlc_delay@@YA_J_J@Z")]
            internal static extern long LibvlcDelay(long pts);
        }

        /// <summary>
        /// <para>A human-readable error message for the last LibVLC error in the calling</para>
        /// <para>thread. The resulting string is valid until another error occurs (at least</para>
        /// <para>until the next LibVLC call).</para>
        /// </summary>
        /// <remarks>This will be NULL if there was no error.</remarks>
        public static string LibvlcErrmsg()
        {
            var __ret = __Internal.LibvlcErrmsg();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Clears the LibVLC error status for the current thread. This is optional.</para>
        /// <para>By default, the error status is automatically overridden when a new error</para>
        /// <para>occurs, and destroyed when the thread exits.</para>
        /// </summary>
        public static void LibvlcClearerr()
        {
            __Internal.LibvlcClearerr();
        }

        /// <summary>
        /// <para>Sets the LibVLC error status and message for the current thread.</para>
        /// <para>Any previous error is overridden.</para>
        /// </summary>
        /// <param name="fmt">the format string</param>
        /// <param name="args">the arguments</param>
        /// <returns>a nul terminated string in any case</returns>
        public static string LibvlcPrinterr(string fmt)
        {
            var __ret = __Internal.LibvlcPrinterr(fmt);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Create and initialize a libvlc instance.</para>
        /// <para>This functions accept a list of &quot;command line&quot; arguments similar to the</para>
        /// <para>main(). These arguments affect the LibVLC instance default configuration.</para>
        /// </summary>
        /// <param name="argc">the number of arguments (should be 0)</param>
        /// <param name="argv">list of arguments (should be NULL)</param>
        /// <returns>the libvlc instance or NULL in case of error</returns>
        /// <remarks>
        /// <para>LibVLC may create threads. Therefore, any thread-unsafe process</para>
        /// <para>initialization must be performed before calling libvlc_new(). In particular</para>
        /// <para>and where applicable:</para>
        /// <para>- setlocale() and textdomain(),</para>
        /// <para>- setenv(), unsetenv() and putenv(),</para>
        /// <para>- with the X11 display system, XInitThreads()</para>
        /// <para>(see also libvlc_media_player_set_xwindow()) and</para>
        /// <para>- on Microsoft Windows, SetErrorMode().</para>
        /// <para>- sigprocmask() shall never be invoked; pthread_sigmask() can be used.</para>
        /// <para>On POSIX systems, the SIGCHLD signalmust notbe ignored, i.e. the</para>
        /// <para>signal handler must set to SIG_DFL or a function pointer, not SIG_IGN.</para>
        /// <para>Also while LibVLC is active, the wait() function shall not be called, and</para>
        /// <para>any call to waitpid() shall use a strictly positive value for the first</para>
        /// <para>parameter (i.e. the PID). Failure to follow those rules may lead to a</para>
        /// <para>deadlock or a busy loop.</para>
        /// <para>Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked,</para>
        /// <para>even if it is not, in principles, necessary, e.g.:</para>
        /// <para>On Microsoft Windows Vista/2008, the process error mode</para>
        /// <para>SEM_FAILCRITICALERRORS flagmustbe set before using LibVLC.</para>
        /// <para>On later versions, that is optional and unnecessary.</para>
        /// <para>Also on Microsoft Windows (Vista and any later version), setting the default</para>
        /// <para>DLL directories to SYSTEM32 exclusively is strongly recommended for</para>
        /// <para>security reasons:</para>
        /// <para>Arguments are meant to be passed from the command line to LibVLC, just like</para>
        /// <para>VLC media player does. The list of valid arguments depends on the LibVLC</para>
        /// <para>version, the operating system and platform, and set of available LibVLC</para>
        /// <para>plugins. Invalid or unsupported arguments will cause the function to fail</para>
        /// <para>(i.e. return NULL). Also, some arguments may alter the behaviour or</para>
        /// <para>otherwise interfere with other LibVLC functions.</para>
        /// <para>There is absolutely no warranty or promise of forward, backward and</para>
        /// <para>cross-platform compatibility with regards to libvlc_new() arguments.</para>
        /// <para>We recommend that you do not use them, other than when debugging.</para>
        /// </remarks>
        public static global::libvlcsharp.Instance LibvlcNew(int argc, sbyte** argv)
        {
            var __ret = __Internal.LibvlcNew(argc, argv);
            global::libvlcsharp.Instance __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Instance.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Instance) global::libvlcsharp.Instance.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Instance.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Decrement the reference count of a libvlc instance, and destroy it</para>
        /// <para>if it reaches zero.</para>
        /// </summary>
        /// <param name="p_instance">the instance to destroy</param>
        public static void LibvlcRelease(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRelease(__arg0);
        }

        /// <summary>
        /// <para>Increments the reference count of a libvlc instance.</para>
        /// <para>The initial reference count is 1 after libvlc_new() returns.</para>
        /// </summary>
        /// <param name="p_instance">the instance to reference</param>
        public static void LibvlcRetain(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcRetain(__arg0);
        }

        /// <summary>Try to start a user interface for the libvlc instance.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="name">interface name, or NULL for default</param>
        /// <returns>0 on success, -1 on error.</returns>
        public static int LibvlcAddIntf(global::libvlcsharp.Instance p_instance, string name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAddIntf(__arg0, name);
            return __ret;
        }

        /// <summary>
        /// <para>Registers a callback for the LibVLC exit event. This is mostly useful if</para>
        /// <para>the VLC playlist and/or at least one interface are started with</para>
        /// <para>libvlc_playlist_play() or libvlc_add_intf() respectively.</para>
        /// <para>Typically, this function will wake up your application main loop (from</para>
        /// <para>another thread).</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="cb">
        /// <para>callback to invoke when LibVLC wants to exit,</para>
        /// <para>or NULL to disable the exit handler (as by default)</para>
        /// </param>
        /// <param name="opaque">data pointer for the callback</param>
        /// <remarks>
        /// <para>This function should be called before the playlist or interface are</para>
        /// <para>started. Otherwise, there is a small race condition: the exit event could</para>
        /// <para>be raised before the handler is registered.</para>
        /// <para>This function and libvlc_wait() cannot be used at the same time.</para>
        /// </remarks>
        public static void LibvlcSetExitHandler(global::libvlcsharp.Instance p_instance, global::libvlcsharp.Delegates.Action_IntPtr cb, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LibvlcSetExitHandler(__arg0, __arg1, opaque);
        }

        /// <summary>
        /// <para>Sets the application name. LibVLC passes this as the user agent string</para>
        /// <para>when a protocol requires it.</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="name">human-readable application name, e.g. &quot;FooBar player 1.2.3&quot;</param>
        /// <param name="http">HTTP User Agent, e.g. &quot;FooBar/1.2.3 Python/2.6.0&quot;</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static void LibvlcSetUserAgent(global::libvlcsharp.Instance p_instance, string name, string http)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetUserAgent(__arg0, name, http);
        }

        /// <summary>
        /// <para>Sets some meta-information about the application.</para>
        /// <para>See also libvlc_set_user_agent().</para>
        /// </summary>
        /// <param name="p_instance">LibVLC instance</param>
        /// <param name="id">Java-style application identifier, e.g. &quot;com.acme.foobar&quot;</param>
        /// <param name="version">application version numbers, e.g. &quot;1.2.3&quot;</param>
        /// <param name="icon">application icon name, e.g. &quot;foobar&quot;</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public static void LibvlcSetAppId(global::libvlcsharp.Instance p_instance, string id, string version, string icon)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetAppId(__arg0, id, version, icon);
        }

        /// <summary>Retrieve libvlc version.</summary>
        /// <returns>a string containing the libvlc version</returns>
        /// <remarks>Example: &quot;1.1.0-git The Luggage&quot;</remarks>
        public static string LibvlcGetVersion()
        {
            var __ret = __Internal.LibvlcGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc compiler version.</summary>
        /// <returns>a string containing the libvlc compiler version</returns>
        /// <remarks>Example: &quot;gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)&quot;</remarks>
        public static string LibvlcGetCompiler()
        {
            var __ret = __Internal.LibvlcGetCompiler();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc changeset.</summary>
        /// <returns>a string containing the libvlc changeset</returns>
        /// <remarks>Example: &quot;aa9bce0bc4&quot;</remarks>
        public static string LibvlcGetChangeset()
        {
            var __ret = __Internal.LibvlcGetChangeset();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Frees an heap allocation returned by a LibVLC function.</para>
        /// <para>If you know you're using the same underlying C run-time as the LibVLC</para>
        /// <para>implementation, then you can call ANSI C free() directly instead.</para>
        /// </summary>
        /// <param name="ptr">the pointer</param>
        public static void LibvlcFree(global::System.IntPtr ptr)
        {
            __Internal.LibvlcFree(ptr);
        }

        /// <summary>Register for an event notification.</summary>
        /// <param name="p_event_manager">
        /// <para>the event manager to which you want to attach to.</para>
        /// <para>Generally it is obtained by vlc_my_object_event_manager() where</para>
        /// <para>my_object is the object you want to listen to.</para>
        /// </param>
        /// <param name="i_event_type">the desired event to which we want to listen</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="user_data">user provided data to carry with the event</param>
        /// <returns>0 on success, ENOMEM on error</returns>
        public static int LibvlcEventAttach(global::libvlcsharp.EventManager p_event_manager, int i_event_type, global::libvlcsharp.LibvlcCallbackT f_callback, global::System.IntPtr user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            var __ret = __Internal.LibvlcEventAttach(__arg0, i_event_type, __arg2, user_data);
            return __ret;
        }

        /// <summary>Unregister an event notification.</summary>
        /// <param name="p_event_manager">the event manager</param>
        /// <param name="i_event_type">the desired event to which we want to unregister</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="p_user_data">user provided data to carry with the event</param>
        public static void LibvlcEventDetach(global::libvlcsharp.EventManager p_event_manager, int i_event_type, global::libvlcsharp.LibvlcCallbackT f_callback, global::System.IntPtr p_user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            __Internal.LibvlcEventDetach(__arg0, i_event_type, __arg2, p_user_data);
        }

        /// <summary>Get an event's type name.</summary>
        /// <param name="event_type">the desired event</param>
        public static string LibvlcEventTypeName(int event_type)
        {
            var __ret = __Internal.LibvlcEventTypeName(event_type);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Gets log message debug infos.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="module">module name storage (or NULL) [OUT]</param>
        /// <param name="file">source code file name storage (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves self-debug information about a log message:</para>
        /// <para>- the name of the VLC module emitting the message,</para>
        /// <para>- the name of the source code module (i.e. file) and</para>
        /// <para>- the line number within the source code module.</para>
        /// <para>The returned module name and file name will be NULL if unknown.</para>
        /// <para>The returned line number will similarly be zero if unknown.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetContext(global::libvlcsharp.Log ctx, sbyte** module, sbyte** file, ref uint line)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (uint* __refParamPtr3 = &line)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetContext(__arg0, module, file, __arg3);
            }
        }

        /// <summary>Gets log message info.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="name">object name storage (or NULL) [OUT]</param>
        /// <param name="header">object header (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves meta-information about a log message:</para>
        /// <para>- the type name of the VLC object emitting the message,</para>
        /// <para>- the object header if any, and</para>
        /// <para>- a temporaly-unique object identifier.</para>
        /// <para>This information is mainly meant formanualtroubleshooting.</para>
        /// <para>The returned type name may be &quot;generic&quot; if unknown, but it cannot be NULL.</para>
        /// <para>The returned header will be NULL if unset; in current versions, the header</para>
        /// <para>is used to distinguish for VLM inputs.</para>
        /// <para>The returned object ID will be zero if the message is not associated with</para>
        /// <para>any VLC object.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetObject(global::libvlcsharp.Log ctx, sbyte** name, sbyte** header, ref ulong id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __refParamPtr3 = &id)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetObject(__arg0, name, header, __arg3);
            }
        }

        /// <summary>Unsets the logging callback.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <remarks>
        /// <para>This function deregisters the logging callback for a LibVLC instance.</para>
        /// <para>This is rarely needed as the callback is implicitly unset when the instance</para>
        /// <para>is destroyed.</para>
        /// <para>This function will wait for any pending callbacks invocation to</para>
        /// <para>complete (causing a deadlock if called from within the callback).</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogUnset(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogUnset(__arg0);
        }

        /// <summary>Sets up logging to a file.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <param name="stream">
        /// <para>FILE pointer opened for writing</para>
        /// <para>(the FILE pointer must remain valid until libvlc_log_unset())</para>
        /// </param>
        /// <remarks>LibVLC 2.1.0 or later</remarks>
        public static void LibvlcLogSetFile(global::libvlcsharp.Instance p_instance, global::System.IntPtr stream)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcLogSetFile(__arg0, stream);
        }

        /// <summary>Release a list of module descriptions.</summary>
        /// <param name="p_list">the list to be released</param>
        public static void LibvlcModuleDescriptionListRelease(global::libvlcsharp.ModuleDescription p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcModuleDescriptionListRelease(__arg0);
        }

        /// <summary>Returns a list of audio filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::libvlcsharp.ModuleDescription LibvlcAudioFilterListGet(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioFilterListGet(__arg0);
            global::libvlcsharp.ModuleDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.ModuleDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.ModuleDescription) global::libvlcsharp.ModuleDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.ModuleDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Returns a list of video filters that are available.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public static global::libvlcsharp.ModuleDescription LibvlcVideoFilterListGet(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVideoFilterListGet(__arg0);
            global::libvlcsharp.ModuleDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.ModuleDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.ModuleDescription) global::libvlcsharp.ModuleDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.ModuleDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Return the current time as defined by LibVLC. The unit is the microsecond.</para>
        /// <para>Time increases monotonically (regardless of time zone changes and RTC</para>
        /// <para>adjustements).</para>
        /// <para>The origin is arbitrary but consistent across the whole system</para>
        /// <para>(e.g. the system uptim, the time since the system was booted).</para>
        /// </summary>
        /// <remarks>On systems that support it, the POSIX monotonic clock is used.</remarks>
        public static long LibvlcClock()
        {
            var __ret = __Internal.LibvlcClock();
            return __ret;
        }

        /// <summary>Return the delay (in microseconds) until a certain timestamp.</summary>
        /// <param name="pts">timestamp</param>
        /// <returns>
        /// <para>negative if timestamp is in the past,</para>
        /// <para>positive if it is in the future</para>
        /// </returns>
        public static long LibvlcDelay(long pts)
        {
            var __ret = __Internal.LibvlcDelay(pts);
            return __ret;
        }
    }

    /// <summary>
    /// <para>LibVLC renderer discoverer finds available renderers available on the local</para>
    /// <para>network</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC renderer discoverer external API</para>
    /// </summary>
    /// <summary>Renderer item</summary>
    /// <remarks>
    /// <para>This struct is passed by a</para>
    /// <para>or deleted.</para>
    /// <para>An item is valid until the</para>
    /// <para>is called with the same pointer.</para>
    /// <para>libvlc_renderer_discoverer_event_manager()</para>
    /// </remarks>
    public unsafe partial class RendererItem
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererItem>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.RendererItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererItem(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.RendererItem __CreateInstance(global::libvlcsharp.RendererItem.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererItem(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.RendererItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.RendererItem.__Internal));
            *(global::libvlcsharp.RendererItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererItem(global::libvlcsharp.RendererItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class RendererDiscoverer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererDiscoverer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererDiscoverer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.RendererDiscoverer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererDiscoverer(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.RendererDiscoverer __CreateInstance(global::libvlcsharp.RendererDiscoverer.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererDiscoverer(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.RendererDiscoverer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.RendererDiscoverer.__Internal));
            *(global::libvlcsharp.RendererDiscoverer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererDiscoverer(global::libvlcsharp.RendererDiscoverer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDiscoverer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Renderer discoverer description</summary>
    /// <remarks>libvlc_renderer_discoverer_list_get()</remarks>
    public unsafe partial class RendererDiscovererDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_longname;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_rd_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererDiscovererDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.RendererDiscovererDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.RendererDiscovererDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererDiscovererDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.RendererDiscovererDescription __CreateInstance(global::libvlcsharp.RendererDiscovererDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.RendererDiscovererDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.RendererDiscovererDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.RendererDiscovererDescription.__Internal));
            *(global::libvlcsharp.RendererDiscovererDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererDiscovererDescription(global::libvlcsharp.RendererDiscovererDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDiscovererDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RendererDiscovererDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.RendererDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RendererDiscovererDescription(global::libvlcsharp.RendererDiscovererDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.RendererDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.RendererDiscovererDescription.__Internal*) __Instance) = *((global::libvlcsharp.RendererDiscovererDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.RendererDiscovererDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.RendererDiscovererDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.RendererDiscovererDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.RendererDiscovererDescription.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlcsharp.RendererDiscovererDescription.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class libvlc_renderer_discoverer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_name")]
            internal static extern global::System.IntPtr LibvlcRendererItemName(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_type")]
            internal static extern global::System.IntPtr LibvlcRendererItemType(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_icon_uri")]
            internal static extern global::System.IntPtr LibvlcRendererItemIconUri(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_flags")]
            internal static extern int LibvlcRendererItemFlags(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_new")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererNew(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_release")]
            internal static extern void LibvlcRendererDiscovererRelease(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_start")]
            internal static extern int LibvlcRendererDiscovererStart(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_stop")]
            internal static extern void LibvlcRendererDiscovererStop(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererEventManager(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_get")]
            internal static extern ulong LibvlcRendererDiscovererListGet(global::System.IntPtr p_inst, global::System.IntPtr ppp_services);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_release")]
            internal static extern void LibvlcRendererDiscovererListRelease(global::System.IntPtr pp_services, ulong i_count);
        }

        /// <summary>Get the human readable name of a renderer item</summary>
        /// <returns>the name of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemName(global::libvlcsharp.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Get the type (not translated) of a renderer item. For now, the type can only</para>
        /// <para>be &quot;chromecast&quot; (&quot;upnp&quot;, &quot;airplay&quot; may come later).</para>
        /// </summary>
        /// <returns>the type of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemType(global::libvlcsharp.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemType(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the icon uri of a renderer item</summary>
        /// <returns>the uri of the item's icon (can be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemIconUri(global::libvlcsharp.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemIconUri(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the flags of a renderer item</summary>
        /// <returns>bitwise flag: capabilities of the renderer, see</returns>
        /// <remarks>
        /// <para>LIBVLC_RENDERER_CAN_AUDIO</para>
        /// <para>LIBVLC_RENDERER_CAN_VIDEO</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererItemFlags(global::libvlcsharp.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemFlags(__arg0);
            return __ret;
        }

        /// <summary>Create a renderer discoverer object by name</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="psz_name">
        /// <para>service name; use libvlc_renderer_discoverer_list_get() to</para>
        /// <para>get a list of the discoverer names available in this libVLC instance</para>
        /// </param>
        /// <returns>media discover object or NULL in case of error</returns>
        /// <remarks>
        /// <para>After this object is created, you should attach to events in order to be</para>
        /// <para>notified of the discoverer events.</para>
        /// <para>You need to call libvlc_renderer_discoverer_start() in order to start the</para>
        /// <para>discovery.</para>
        /// <para>libvlc_renderer_discoverer_event_manager()</para>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.RendererDiscoverer LibvlcRendererDiscovererNew(global::libvlcsharp.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererNew(__arg0, psz_name);
            global::libvlcsharp.RendererDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.RendererDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.RendererDiscoverer) global::libvlcsharp.RendererDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.RendererDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release a renderer discoverer object</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static void LibvlcRendererDiscovererRelease(global::libvlcsharp.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererRelease(__arg0);
        }

        /// <summary>Start renderer discovery</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>To stop it, call libvlc_renderer_discoverer_stop() or</para>
        /// <para>libvlc_renderer_discoverer_release() directly.</para>
        /// <para>libvlc_renderer_discoverer_stop()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererDiscovererStart(global::libvlcsharp.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererStart(__arg0);
            return __ret;
        }

        /// <summary>Stop renderer discovery.</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererStop(global::libvlcsharp.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererStop(__arg0);
        }

        /// <summary>Get the event manager of the renderer discoverer</summary>
        /// <returns>a valid event manager (can't fail)</returns>
        /// <remarks>
        /// <para>The possible events to attach are</para>
        /// <para>and</para>
        /// <para>The</para>
        /// <para>VLC, users should take care of copying this struct for their internal usage.</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_added.item</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_removed.item</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.EventManager LibvlcRendererDiscovererEventManager(global::libvlcsharp.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media discoverer services</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="ppp_services">
        /// <para>address to store an allocated array of renderer</para>
        /// <para>discoverer services (must be freed with libvlc_renderer_list_release() by</para>
        /// <para>the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of media discoverer services (0 on error)</returns>
        /// <remarks>
        /// <para>libvlc_renderer_list_release()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static ulong LibvlcRendererDiscovererListGet(global::libvlcsharp.Instance p_inst, global::libvlcsharp.RendererDiscovererDescription ppp_services)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __arg1 = ReferenceEquals(ppp_services, null) ? global::System.IntPtr.Zero : ppp_services.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererListGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release an array of media discoverer services</summary>
        /// <param name="pp_services">array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_list_get()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererListRelease(global::libvlcsharp.RendererDiscovererDescription pp_services, ulong i_count)
        {
            var __arg0 = ReferenceEquals(pp_services, null) ? global::System.IntPtr.Zero : pp_services.__Instance;
            __Internal.LibvlcRendererDiscovererListRelease(__arg0, i_count);
        }
    }

    /// <summary>Meta data types</summary>
    public enum MetadataType
    {
        Title = 0,
        Artist = 1,
        Genre = 2,
        Copyright = 3,
        Album = 4,
        TrackNumber = 5,
        Description = 6,
        Rating = 7,
        Date = 8,
        Setting = 9,
        URL = 10,
        Language = 11,
        NowPlaying = 12,
        Publisher = 13,
        EncodedBy = 14,
        ArtworkURL = 15,
        TrackID = 16,
        TrackTotal = 17,
        Director = 18,
        Season = 19,
        Episode = 20,
        ShowName = 21,
        Actors = 22,
        AlbumArtist = 23,
        DiscNumber = 24,
        DiscTotal = 25
    }

    public enum TrackType
    {
        Unknown = -1,
        Audio = 0,
        Video = 1,
        Text = 2
    }

    /// <summary>Note the order of libvlc_state_t enum must match exactly the order of</summary>
    /// <remarks>
    /// <para>mediacontrol_PlayerStatus,</para>
    /// <para>input_state_e enums,</para>
    /// <para>and VideoLAN.LibVLC.State (at bindings/cil/src/media.cs).</para>
    /// <para>Expected states by web plugins are:</para>
    /// <para>IDLE/CLOSE=0, OPENING=1, PLAYING=3, PAUSED=4,</para>
    /// <para>STOPPING=5, ENDED=6, ERROR=7</para>
    /// </remarks>
    public enum VLCState
    {
        NothingSpecial = 0,
        Opening = 1,
        Buffering = 2,
        Playing = 3,
        Paused = 4,
        Stopped = 5,
        Ended = 6,
        Error = 7
    }

    [Flags]
    public enum MediaOption
    {
        Trusted = 2,
        Unique = 256
    }

    public enum VideoOrientation
    {
        /// <summary>Normal. Top line represents top, left column left.</summary>
        TopLeft = 0,
        /// <summary>Flipped horizontally</summary>
        TopRight = 1,
        /// <summary>Flipped vertically</summary>
        BottomLeft = 2,
        /// <summary>Rotated 180 degrees</summary>
        BottomRight = 3,
        /// <summary>Transposed</summary>
        LeftTop = 4,
        /// <summary>Rotated 90 degrees clockwise (or 270 anti-clockwise)</summary>
        LeftBottom = 5,
        /// <summary>Rotated 90 degrees anti-clockwise</summary>
        RightTop = 6,
        /// <summary>Anti-transposed</summary>
        RightBottom = 7
    }

    [Flags]
    public enum VideoProjection
    {
        Rectangular = 0,
        /// <summary>360 spherical</summary>
        Equirectangular = 1,
        CubemapLayoutStandard = 256
    }

    /// <summary>Media type</summary>
    /// <remarks>libvlc_media_get_type</remarks>
    public enum MediaType
    {
        Unknown = 0,
        File = 1,
        Directory = 2,
        Disc = 3,
        Stream = 4,
        Playlist = 5
    }

    /// <summary>Parse flags used by libvlc_media_parse_with_options()</summary>
    /// <remarks>libvlc_media_parse_with_options</remarks>
    [Flags]
    public enum MediaParseOptions
    {
        /// <summary>Parse media if it's a local file</summary>
        ParseLocal = 0,
        /// <summary>Parse media even if it's a network file</summary>
        ParseNetwork = 1,
        /// <summary>Fetch meta and covert art using local resources</summary>
        FetchLocal = 2,
        /// <summary>Fetch meta and covert art using network resources</summary>
        FetchNetwork = 4,
        /// <summary>
        /// <para>Interact with the user (via libvlc_dialog_cbs) when preparsing this item</para>
        /// <para>(and not its sub items). Set this flag in order to receive a callback</para>
        /// <para>when the input is asking for credentials.</para>
        /// </summary>
        DoInteract = 8
    }

    /// <summary>
    /// <para>Parse status used sent by libvlc_media_parse_with_options() or returned by</para>
    /// <para>libvlc_media_get_parsed_status()</para>
    /// </summary>
    /// <remarks>
    /// <para>libvlc_media_parse_with_options</para>
    /// <para>libvlc_media_get_parsed_status</para>
    /// </remarks>
    public enum MediaParsedStatus
    {
        Skipped = 1,
        Failed = 2,
        Timeout = 3,
        Done = 4
    }

    /// <summary>Type of a media slave: subtitle or audio.</summary>
    public enum MediaSlaveType
    {
        Subtitle = 0,
        Audio = 1
    }

    /// <summary>
    /// <para>It consists of a media location and various optional meta data.</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media item/descriptor external API</para>
    /// </summary>
    /// <summary>Callback prototype to open a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_media_new_callbacks()</param>
    /// <param name="datap">storage space for a private data pointer [OUT]</param>
    /// <param name="sizep">byte length of the bitstream or UINT64_MAX if unknown [OUT]</param>
    /// <returns>
    /// <para>0 on success, non-zero on error. In case of failure, the other</para>
    /// <para>callbacks will not be invoked and any value stored in *datap and *sizep is</para>
    /// <para>discarded.</para>
    /// </returns>
    /// <remarks>
    /// <para>The same media item can be opened multiple times. Each time, this callback</para>
    /// <para>is invoked. It should allocate and initialize any instance-specific</para>
    /// <para>resources, then store them in *datap. The instance resources can be freed</para>
    /// <para>in the</para>
    /// <para>For convenience, *datap is initially NULL and *sizep is initially 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcMediaOpenCb(global::System.IntPtr opaque, void** datap, ulong* sizep);

    /// <summary>Callback prototype to read data from a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <param name="buf">start address of the buffer to read data into</param>
    /// <param name="len">bytes length of the buffer</param>
    /// <returns>
    /// <para>strictly positive number of bytes read, 0 on end-of-stream,</para>
    /// <para>or -1 on non-recoverable error</para>
    /// </returns>
    /// <remarks>
    /// <para>callback</para>
    /// <para>If no data is immediately available, then the callback should sleep.</para>
    /// <para>The application is responsible for avoiding deadlock situations.</para>
    /// <para>In particular, the callback should return an error if playback is stopped;</para>
    /// <para>if it does not return, then libvlc_media_player_stop() will never return.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate long LibvlcMediaReadCb(global::System.IntPtr opaque, byte* buf, ulong len);

    /// <summary>Callback prototype to seek a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <param name="offset">absolute byte offset to seek to</param>
    /// <returns>0 on success, -1 on error.</returns>
    /// <remarks>callback</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcMediaSeekCb(global::System.IntPtr opaque, ulong offset);

    /// <summary>Callback prototype to close a custom bitstream input media.</summary>
    /// <param name="opaque">private pointer as set by the</param>
    /// <remarks>callback</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcMediaCloseCb(global::System.IntPtr opaque);

    public unsafe partial class Media
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Media> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Media>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.Media __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Media(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.Media __CreateInstance(global::libvlcsharp.Media.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Media(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.Media.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.Media.__Internal));
            *(global::libvlcsharp.Media.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Media(global::libvlcsharp.Media.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Media(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class MediaList
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaList>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaList(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaList __CreateInstance(global::libvlcsharp.MediaList.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaList(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaList.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaList.__Internal));
            *(global::libvlcsharp.MediaList.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaList(global::libvlcsharp.MediaList.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class MediaStats : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 60)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_read_bytes;

            [FieldOffset(4)]
            internal float f_input_bitrate;

            [FieldOffset(8)]
            internal int i_demux_read_bytes;

            [FieldOffset(12)]
            internal float f_demux_bitrate;

            [FieldOffset(16)]
            internal int i_demux_corrupted;

            [FieldOffset(20)]
            internal int i_demux_discontinuity;

            [FieldOffset(24)]
            internal int i_decoded_video;

            [FieldOffset(28)]
            internal int i_decoded_audio;

            [FieldOffset(32)]
            internal int i_displayed_pictures;

            [FieldOffset(36)]
            internal int i_lost_pictures;

            [FieldOffset(40)]
            internal int i_played_abuffers;

            [FieldOffset(44)]
            internal int i_lost_abuffers;

            [FieldOffset(48)]
            internal int i_sent_packets;

            [FieldOffset(52)]
            internal int i_sent_bytes;

            [FieldOffset(56)]
            internal float f_send_bitrate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_media_stats_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaStats> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaStats>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaStats __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaStats(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaStats __CreateInstance(global::libvlcsharp.MediaStats.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaStats(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaStats.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaStats.__Internal));
            *(global::libvlcsharp.MediaStats.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaStats(global::libvlcsharp.MediaStats.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MediaStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaStats.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MediaStats(global::libvlcsharp.MediaStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaStats.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.MediaStats.__Internal*) __Instance) = *((global::libvlcsharp.MediaStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.MediaStats __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int IReadBytes
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_read_bytes;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_read_bytes = value;
            }
        }

        public float FInputBitrate
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_input_bitrate;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_input_bitrate = value;
            }
        }

        public int IDemuxReadBytes
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_read_bytes;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_read_bytes = value;
            }
        }

        public float FDemuxBitrate
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_demux_bitrate;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_demux_bitrate = value;
            }
        }

        public int IDemuxCorrupted
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_corrupted;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_corrupted = value;
            }
        }

        public int IDemuxDiscontinuity
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_discontinuity;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_demux_discontinuity = value;
            }
        }

        public int IDecodedVideo
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_decoded_video;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_decoded_video = value;
            }
        }

        public int IDecodedAudio
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_decoded_audio;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_decoded_audio = value;
            }
        }

        public int IDisplayedPictures
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_displayed_pictures;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_displayed_pictures = value;
            }
        }

        public int ILostPictures
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_lost_pictures;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_lost_pictures = value;
            }
        }

        public int IPlayedAbuffers
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_played_abuffers;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_played_abuffers = value;
            }
        }

        public int ILostAbuffers
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_lost_abuffers;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_lost_abuffers = value;
            }
        }

        public int ISentPackets
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_sent_packets;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_sent_packets = value;
            }
        }

        public int ISentBytes
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_sent_bytes;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->i_sent_bytes = value;
            }
        }

        public float FSendBitrate
        {
            get
            {
                return ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_send_bitrate;
            }

            set
            {
                ((global::libvlcsharp.MediaStats.__Internal*) __Instance)->f_send_bitrate = value;
            }
        }
    }

    public unsafe partial class MediaTrackInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_codec;

            [FieldOffset(4)]
            internal int i_id;

            [FieldOffset(8)]
            internal global::libvlcsharp.TrackType i_type;

            [FieldOffset(12)]
            internal int i_profile;

            [FieldOffset(16)]
            internal int i_level;

            [FieldOffset(20)]
            internal global::libvlcsharp.MediaTrackInfo._.__Internal u;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_media_track_info_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::libvlcsharp.MediaTrackInfo._.__.__Internal audio;

                [FieldOffset(0)]
                internal global::libvlcsharp.MediaTrackInfo._.___.__Internal video;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint i_channels;

                    [FieldOffset(4)]
                    internal uint i_rate;
                }
            }

            public unsafe partial class ___
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint i_height;

                    [FieldOffset(4)]
                    internal uint i_width;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaTrackInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaTrackInfo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaTrackInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaTrackInfo(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaTrackInfo __CreateInstance(global::libvlcsharp.MediaTrackInfo.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaTrackInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaTrackInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrackInfo.__Internal));
            *(global::libvlcsharp.MediaTrackInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaTrackInfo(global::libvlcsharp.MediaTrackInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaTrackInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MediaTrackInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrackInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MediaTrackInfo(global::libvlcsharp.MediaTrackInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrackInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance) = *((global::libvlcsharp.MediaTrackInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.MediaTrackInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ICodec
        {
            get
            {
                return ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_codec;
            }

            set
            {
                ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_codec = value;
            }
        }

        public int IId
        {
            get
            {
                return ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_id = value;
            }
        }

        public global::libvlcsharp.TrackType IType
        {
            get
            {
                return ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_type = value;
            }
        }

        public int IProfile
        {
            get
            {
                return ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_profile;
            }

            set
            {
                ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_profile = value;
            }
        }

        public int ILevel
        {
            get
            {
                return ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_level;
            }

            set
            {
                ((global::libvlcsharp.MediaTrackInfo.__Internal*) __Instance)->i_level = value;
            }
        }
    }

    public unsafe partial class AudioTrack : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_channels;

            [FieldOffset(4)]
            internal uint i_rate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_audio_track_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioTrack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioTrack>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.AudioTrack __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioTrack(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.AudioTrack __CreateInstance(global::libvlcsharp.AudioTrack.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioTrack(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.AudioTrack.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioTrack.__Internal));
            *(global::libvlcsharp.AudioTrack.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioTrack(global::libvlcsharp.AudioTrack.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioTrack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioTrack()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioTrack(global::libvlcsharp.AudioTrack _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.AudioTrack.__Internal*) __Instance) = *((global::libvlcsharp.AudioTrack.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.AudioTrack __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint IChannels
        {
            get
            {
                return ((global::libvlcsharp.AudioTrack.__Internal*) __Instance)->i_channels;
            }

            set
            {
                ((global::libvlcsharp.AudioTrack.__Internal*) __Instance)->i_channels = value;
            }
        }

        public uint IRate
        {
            get
            {
                return ((global::libvlcsharp.AudioTrack.__Internal*) __Instance)->i_rate;
            }

            set
            {
                ((global::libvlcsharp.AudioTrack.__Internal*) __Instance)->i_rate = value;
            }
        }
    }

    public unsafe partial class VideoTrack : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_height;

            [FieldOffset(4)]
            internal uint i_width;

            [FieldOffset(8)]
            internal uint i_sar_num;

            [FieldOffset(12)]
            internal uint i_sar_den;

            [FieldOffset(16)]
            internal uint i_frame_rate_num;

            [FieldOffset(20)]
            internal uint i_frame_rate_den;

            [FieldOffset(24)]
            internal global::libvlcsharp.VideoOrientation i_orientation;

            [FieldOffset(28)]
            internal global::libvlcsharp.VideoProjection i_projection;

            [FieldOffset(32)]
            internal global::libvlcsharp.VideoTrack._.__Internal pose;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_video_track_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial class _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal float f_yaw_degrees;

                [FieldOffset(4)]
                internal float f_pitch_degrees;

                [FieldOffset(8)]
                internal float f_roll_degrees;

                [FieldOffset(12)]
                internal float f_fov_degrees;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.VideoTrack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.VideoTrack>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.VideoTrack __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.VideoTrack(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.VideoTrack __CreateInstance(global::libvlcsharp.VideoTrack.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.VideoTrack(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.VideoTrack.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoTrack.__Internal));
            *(global::libvlcsharp.VideoTrack.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VideoTrack(global::libvlcsharp.VideoTrack.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VideoTrack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VideoTrack()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VideoTrack(global::libvlcsharp.VideoTrack _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.VideoTrack.__Internal*) __Instance) = *((global::libvlcsharp.VideoTrack.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.VideoTrack __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint IHeight
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_height;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_height = value;
            }
        }

        public uint IWidth
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_width;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_width = value;
            }
        }

        public uint ISarNum
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_sar_num;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_sar_num = value;
            }
        }

        public uint ISarDen
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_sar_den;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_sar_den = value;
            }
        }

        public uint IFrameRateNum
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_frame_rate_num;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_frame_rate_num = value;
            }
        }

        public uint IFrameRateDen
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_frame_rate_den;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_frame_rate_den = value;
            }
        }

        public global::libvlcsharp.VideoOrientation IOrientation
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_orientation;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_orientation = value;
            }
        }

        public global::libvlcsharp.VideoProjection IProjection
        {
            get
            {
                return ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_projection;
            }

            set
            {
                ((global::libvlcsharp.VideoTrack.__Internal*) __Instance)->i_projection = value;
            }
        }
    }

    public unsafe partial class SubtitleTrack : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_encoding;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_subtitle_track_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.SubtitleTrack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.SubtitleTrack>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.SubtitleTrack __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.SubtitleTrack(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.SubtitleTrack __CreateInstance(global::libvlcsharp.SubtitleTrack.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.SubtitleTrack(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.SubtitleTrack.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.SubtitleTrack.__Internal));
            *(global::libvlcsharp.SubtitleTrack.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SubtitleTrack(global::libvlcsharp.SubtitleTrack.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SubtitleTrack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SubtitleTrack()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.SubtitleTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SubtitleTrack(global::libvlcsharp.SubtitleTrack _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.SubtitleTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.SubtitleTrack.__Internal*) __Instance) = *((global::libvlcsharp.SubtitleTrack.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.SubtitleTrack __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszEncoding
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.SubtitleTrack.__Internal*) __Instance)->psz_encoding;
            }

            set
            {
                ((global::libvlcsharp.SubtitleTrack.__Internal*) __Instance)->psz_encoding = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class MediaTrack : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint i_codec;

            [FieldOffset(4)]
            internal uint i_original_fourcc;

            [FieldOffset(8)]
            internal int i_id;

            [FieldOffset(12)]
            internal global::libvlcsharp.TrackType i_type;

            [FieldOffset(16)]
            internal int i_profile;

            [FieldOffset(20)]
            internal int i_level;

            [FieldOffset(24)]
            internal global::libvlcsharp.MediaTrack._.__Internal _;

            [FieldOffset(32)]
            internal uint i_bitrate;

            [FieldOffset(40)]
            internal global::System.IntPtr psz_language;

            [FieldOffset(48)]
            internal global::System.IntPtr psz_description;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_media_track_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::System.IntPtr audio;

                [FieldOffset(0)]
                internal global::System.IntPtr video;

                [FieldOffset(0)]
                internal global::System.IntPtr subtitle;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaTrack> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaTrack>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaTrack __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaTrack(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaTrack __CreateInstance(global::libvlcsharp.MediaTrack.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaTrack(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaTrack.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrack.__Internal));
            *(global::libvlcsharp.MediaTrack.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaTrack(global::libvlcsharp.MediaTrack.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaTrack(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MediaTrack()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MediaTrack(global::libvlcsharp.MediaTrack _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaTrack.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.MediaTrack.__Internal*) __Instance) = *((global::libvlcsharp.MediaTrack.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.MediaTrack __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ICodec
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_codec;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_codec = value;
            }
        }

        public uint IOriginalFourcc
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_original_fourcc;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_original_fourcc = value;
            }
        }

        public int IId
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_id = value;
            }
        }

        public global::libvlcsharp.TrackType IType
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_type = value;
            }
        }

        public int IProfile
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_profile;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_profile = value;
            }
        }

        public int ILevel
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_level;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_level = value;
            }
        }

        public uint IBitrate
        {
            get
            {
                return ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_bitrate;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->i_bitrate = value;
            }
        }

        public sbyte* PszLanguage
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->psz_language;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->psz_language = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlcsharp.MediaTrack.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>A slave of a libvlc_media_t</summary>
    /// <remarks>libvlc_media_slaves_get</remarks>
    public unsafe partial class MediaSlave : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_uri;

            [FieldOffset(8)]
            internal global::libvlcsharp.MediaSlaveType i_type;

            [FieldOffset(12)]
            internal uint i_priority;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_media_slave_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaSlave> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaSlave>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaSlave __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaSlave(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaSlave __CreateInstance(global::libvlcsharp.MediaSlave.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaSlave(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaSlave.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaSlave.__Internal));
            *(global::libvlcsharp.MediaSlave.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaSlave(global::libvlcsharp.MediaSlave.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaSlave(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MediaSlave()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaSlave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MediaSlave(global::libvlcsharp.MediaSlave _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaSlave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.MediaSlave.__Internal*) __Instance) = *((global::libvlcsharp.MediaSlave.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.MediaSlave __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszUri
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->psz_uri;
            }

            set
            {
                ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->psz_uri = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.MediaSlaveType IType
        {
            get
            {
                return ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->i_type;
            }

            set
            {
                ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->i_type = value;
            }
        }

        public uint IPriority
        {
            get
            {
                return ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->i_priority;
            }

            set
            {
                ((global::libvlcsharp.MediaSlave.__Internal*) __Instance)->i_priority = value;
            }
        }
    }

    public unsafe partial class libvlc_media
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_location")]
            internal static extern global::System.IntPtr LibvlcMediaNewLocation(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_mrl);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_path")]
            internal static extern global::System.IntPtr LibvlcMediaNewPath(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_fd")]
            internal static extern global::System.IntPtr LibvlcMediaNewFd(global::System.IntPtr p_instance, int fd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_callbacks")]
            internal static extern global::System.IntPtr LibvlcMediaNewCallbacks(global::System.IntPtr instance, global::System.IntPtr open_cb, global::System.IntPtr read_cb, global::System.IntPtr seek_cb, global::System.IntPtr close_cb, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_new_as_node")]
            internal static extern global::System.IntPtr LibvlcMediaNewAsNode(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_add_option")]
            internal static extern void LibvlcMediaAddOption(global::System.IntPtr p_md, [MarshalAs(UnmanagedType.LPStr)] string psz_options);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_add_option_flag")]
            internal static extern void LibvlcMediaAddOptionFlag(global::System.IntPtr p_md, [MarshalAs(UnmanagedType.LPStr)] string psz_options, uint i_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_retain")]
            internal static extern void LibvlcMediaRetain(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_release")]
            internal static extern void LibvlcMediaRelease(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_mrl")]
            internal static extern sbyte* LibvlcMediaGetMrl(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_duplicate")]
            internal static extern global::System.IntPtr LibvlcMediaDuplicate(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_meta")]
            internal static extern sbyte* LibvlcMediaGetMeta(global::System.IntPtr p_md, global::libvlcsharp.MetadataType e_meta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_set_meta")]
            internal static extern void LibvlcMediaSetMeta(global::System.IntPtr p_md, global::libvlcsharp.MetadataType e_meta, [MarshalAs(UnmanagedType.LPStr)] string psz_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_save_meta")]
            internal static extern int LibvlcMediaSaveMeta(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_state")]
            internal static extern global::libvlcsharp.VLCState LibvlcMediaGetState(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_stats")]
            internal static extern int LibvlcMediaGetStats(global::System.IntPtr p_md, global::System.IntPtr p_stats);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_subitems")]
            internal static extern global::System.IntPtr LibvlcMediaSubitems(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaEventManager(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_duration")]
            internal static extern long LibvlcMediaGetDuration(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_with_options")]
            internal static extern int LibvlcMediaParseWithOptions(global::System.IntPtr p_md, global::libvlcsharp.MediaParseOptions parse_flag, int timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_stop")]
            internal static extern void LibvlcMediaParseStop(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_parsed_status")]
            internal static extern global::libvlcsharp.MediaParsedStatus LibvlcMediaGetParsedStatus(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_set_user_data")]
            internal static extern void LibvlcMediaSetUserData(global::System.IntPtr p_md, global::System.IntPtr p_new_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_user_data")]
            internal static extern global::System.IntPtr LibvlcMediaGetUserData(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_tracks_get")]
            internal static extern uint LibvlcMediaTracksGet(global::System.IntPtr p_md, global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_codec_description")]
            internal static extern global::System.IntPtr LibvlcMediaGetCodecDescription(global::libvlcsharp.TrackType i_type, uint i_codec);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_tracks_release")]
            internal static extern void LibvlcMediaTracksRelease(global::System.IntPtr p_tracks, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_type")]
            internal static extern global::libvlcsharp.MediaType LibvlcMediaGetType(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_add")]
            internal static extern int LibvlcMediaSlavesAdd(global::System.IntPtr p_md, global::libvlcsharp.MediaSlaveType i_type, uint i_priority, [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_clear")]
            internal static extern void LibvlcMediaSlavesClear(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_get")]
            internal static extern uint LibvlcMediaSlavesGet(global::System.IntPtr p_md, global::System.IntPtr ppp_slaves);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_slaves_release")]
            internal static extern void LibvlcMediaSlavesRelease(global::System.IntPtr pp_slaves, uint i_count);
        }

        /// <summary>
        /// <para>Create a media with a certain given media resource location,</para>
        /// <para>for instance a valid URL.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_mrl">the media location</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>To refer to a local file with this function,</para>
        /// <para>the file://... URI syntaxmustbe used (see IETF RFC3986).</para>
        /// <para>We recommend using libvlc_media_new_path() instead when dealing with</para>
        /// <para>local files.</para>
        /// <para>libvlc_media_release</para>
        /// </remarks>
        public static global::libvlcsharp.Media LibvlcMediaNewLocation(global::libvlcsharp.Instance p_instance, string psz_mrl)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewLocation(__arg0, psz_mrl);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media for a certain file path.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="path">local filesystem path</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>libvlc_media_release</remarks>
        public static global::libvlcsharp.Media LibvlcMediaNewPath(global::libvlcsharp.Instance p_instance, string path)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewPath(__arg0, path);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a media for an already open file descriptor.</para>
        /// <para>The file descriptor shall be open for reading (or reading and writing).</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="fd">open file descriptor</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>Regular file descriptors, pipe read descriptors and character device</para>
        /// <para>descriptors (including TTYs) are supported on all platforms.</para>
        /// <para>Block device descriptors are supported where available.</para>
        /// <para>Directory descriptors are supported on systems that provide fdopendir().</para>
        /// <para>Sockets are supported on all platforms where they are file descriptors,</para>
        /// <para>i.e. all except Windows.</para>
        /// <para>This library willnotautomatically close the file descriptor</para>
        /// <para>under any circumstance. Nevertheless, a file descriptor can usually only be</para>
        /// <para>rendered once in a media player. To render it a second time, the file</para>
        /// <para>descriptor should probably be rewound to the beginning with lseek().</para>
        /// <para>libvlc_media_release</para>
        /// <para>LibVLC 1.1.5 and later.</para>
        /// </remarks>
        public static global::libvlcsharp.Media LibvlcMediaNewFd(global::libvlcsharp.Instance p_instance, int fd)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewFd(__arg0, fd);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media with custom callbacks to read the data from.</summary>
        /// <param name="instance">LibVLC instance</param>
        /// <param name="open_cb">callback to open the custom bitstream input media</param>
        /// <param name="read_cb">callback to read data (must not be NULL)</param>
        /// <param name="seek_cb">callback to seek, or NULL if seeking is not supported</param>
        /// <param name="close_cb">callback to close the media, or NULL if unnecessary</param>
        /// <param name="opaque">data pointer for the open callback</param>
        /// <returns>the newly created media or NULL on error</returns>
        /// <remarks>
        /// <para>If open_cb is NULL, the opaque pointer will be passed to read_cb,</para>
        /// <para>seek_cb and close_cb, and the stream size will be treated as unknown.</para>
        /// <para>The callbacks may be called asynchronously (from another thread).</para>
        /// <para>A single stream instance need not be reentrant. However the open_cb needs to</para>
        /// <para>be reentrant if the media is used by multiple player instances.</para>
        /// <para>The callbacks may be used until all or any player instances</para>
        /// <para>that were supplied the media item are stopped.</para>
        /// <para>libvlc_media_release</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static global::libvlcsharp.Media LibvlcMediaNewCallbacks(global::libvlcsharp.Instance instance, global::libvlcsharp.LibvlcMediaOpenCb open_cb, global::libvlcsharp.LibvlcMediaReadCb read_cb, global::libvlcsharp.LibvlcMediaSeekCb seek_cb, global::libvlcsharp.LibvlcMediaCloseCb close_cb, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(instance, null) ? global::System.IntPtr.Zero : instance.__Instance;
            var __arg1 = open_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(open_cb);
            var __arg2 = read_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read_cb);
            var __arg3 = seek_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(seek_cb);
            var __arg4 = close_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(close_cb);
            var __ret = __Internal.LibvlcMediaNewCallbacks(__arg0, __arg1, __arg2, __arg3, __arg4, opaque);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a media as an empty node with a given name.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the node</param>
        /// <returns>the new empty media or NULL on error</returns>
        /// <remarks>libvlc_media_release</remarks>
        public static global::libvlcsharp.Media LibvlcMediaNewAsNode(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaNewAsNode(__arg0, psz_name);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Add an option to the media.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="psz_options">the options (as a string)</param>
        /// <remarks>
        /// <para>This option will be used to determine how the media_player will</para>
        /// <para>read the media. This allows to use VLC's advanced</para>
        /// <para>reading/streaming options on a per-media basis.</para>
        /// <para>The options are listed in 'vlc --long-help' from the command line,</para>
        /// <para>e.g. &quot;-sout-all&quot;. Keep in mind that available options and their semantics</para>
        /// <para>vary across LibVLC versions and builds.</para>
        /// <para>Not all options affects libvlc_media_t objects:</para>
        /// <para>Specifically, due to architectural issues most audio and video options,</para>
        /// <para>such as text renderer options, have no effects on an individual media.</para>
        /// <para>These options must be set through libvlc_new() instead.</para>
        /// </remarks>
        public static void LibvlcMediaAddOption(global::libvlcsharp.Media p_md, string psz_options)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaAddOption(__arg0, psz_options);
        }

        /// <summary>Add an option to the media with configurable flags.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="psz_options">the options (as a string)</param>
        /// <param name="i_flags">the flags for this option</param>
        /// <remarks>
        /// <para>This option will be used to determine how the media_player will</para>
        /// <para>read the media. This allows to use VLC's advanced</para>
        /// <para>reading/streaming options on a per-media basis.</para>
        /// <para>The options are detailed in vlc --long-help, for instance</para>
        /// <para>&quot;--sout-all&quot;. Note that all options are not usable on medias:</para>
        /// <para>specifically, due to architectural issues, video-related options</para>
        /// <para>such as text renderer options cannot be set on a single media. They</para>
        /// <para>must be set on the whole libvlc instance instead.</para>
        /// </remarks>
        public static void LibvlcMediaAddOptionFlag(global::libvlcsharp.Media p_md, string psz_options, uint i_flags)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaAddOptionFlag(__arg0, psz_options, i_flags);
        }

        /// <summary>
        /// <para>Retain a reference to a media descriptor object (libvlc_media_t). Use</para>
        /// <para>libvlc_media_release() to decrement the reference count of a</para>
        /// <para>media descriptor object.</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        public static void LibvlcMediaRetain(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaRetain(__arg0);
        }

        /// <summary>
        /// <para>Decrement the reference count of a media descriptor object. If the</para>
        /// <para>reference count is 0, then libvlc_media_release() will release the</para>
        /// <para>media descriptor object. It will send out an libvlc_MediaFreed event</para>
        /// <para>to all listeners. If the media descriptor object has been released it</para>
        /// <para>should not be used again.</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        public static void LibvlcMediaRelease(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaRelease(__arg0);
        }

        /// <summary>Get the media resource locator (mrl) from a media descriptor object</summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>string with mrl of media descriptor object</returns>
        public static sbyte* LibvlcMediaGetMrl(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetMrl(__arg0);
            return __ret;
        }

        /// <summary>Duplicate a media descriptor object.</summary>
        /// <param name="p_md">a media descriptor object.</param>
        public static global::libvlcsharp.Media LibvlcMediaDuplicate(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaDuplicate(__arg0);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Read the meta of the media.</summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="e_meta">the meta to read</param>
        /// <returns>the media's meta</returns>
        /// <remarks>
        /// <para>If the media has not yet been parsed this will return NULL.</para>
        /// <para>libvlc_media_parse</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>libvlc_MediaMetaChanged</para>
        /// </remarks>
        public static sbyte* LibvlcMediaGetMeta(global::libvlcsharp.Media p_md, global::libvlcsharp.MetadataType e_meta)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetMeta(__arg0, e_meta);
            return __ret;
        }

        /// <summary>
        /// <para>Set the meta of the media (this function will not save the meta, call</para>
        /// <para>libvlc_media_save_meta in order to save the meta)</para>
        /// </summary>
        /// <param name="p_md">the media descriptor</param>
        /// <param name="e_meta">the meta to write</param>
        /// <param name="psz_value">the media's meta</param>
        public static void LibvlcMediaSetMeta(global::libvlcsharp.Media p_md, global::libvlcsharp.MetadataType e_meta, string psz_value)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSetMeta(__arg0, e_meta, psz_value);
        }

        /// <summary>Save the meta previously set</summary>
        /// <param name="p_md">the media desriptor</param>
        /// <returns>true if the write operation was successful</returns>
        public static int LibvlcMediaSaveMeta(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSaveMeta(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get current state of media descriptor object. Possible media states are</para>
        /// <para>libvlc_NothingSpecial=0, libvlc_Opening, libvlc_Playing, libvlc_Paused,</para>
        /// <para>libvlc_Stopped, libvlc_Ended, libvlc_Error.</para>
        /// </summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>state of media descriptor object</returns>
        /// <remarks>libvlc_state_t</remarks>
        public static global::libvlcsharp.VLCState LibvlcMediaGetState(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetState(__arg0);
            return __ret;
        }

        /// <summary>Get the current statistics about the media</summary>
        /// <param name="p_md:">media descriptor object</param>
        /// <param name="p_stats:">
        /// <para>structure that contain the statistics about the media</para>
        /// <para>(this structure must be allocated by the caller)</para>
        /// </param>
        /// <returns>true if the statistics are available, false otherwise</returns>
        public static int LibvlcMediaGetStats(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaStats p_stats)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(p_stats, null) ? global::System.IntPtr.Zero : p_stats.__Instance;
            var __ret = __Internal.LibvlcMediaGetStats(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get subitems of media descriptor object. This will increment</para>
        /// <para>the reference count of supplied media descriptor object. Use</para>
        /// <para>libvlc_media_list_release() to decrement the reference counting.</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>list of media descriptor subitems or NULL</returns>
        public static global::libvlcsharp.MediaList LibvlcMediaSubitems(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSubitems(__arg0);
            global::libvlcsharp.MediaList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaList) global::libvlcsharp.MediaList.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaList.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get event manager from media descriptor object.</para>
        /// <para>NOTE: this function doesn't increment reference counting.</para>
        /// </summary>
        /// <param name="p_md">a media descriptor object</param>
        /// <returns>event manager object</returns>
        public static global::libvlcsharp.EventManager LibvlcMediaEventManager(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get duration (in ms) of media descriptor object item.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>duration of media item or -1 on error</returns>
        public static long LibvlcMediaGetDuration(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetDuration(__arg0);
            return __ret;
        }

        /// <summary>Parse the media asynchronously with options.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="parse_flag">parse options:</param>
        /// <param name="timeout">
        /// <para>maximum time allowed to preparse the media. If -1, the</para>
        /// <para>default &quot;preparse-timeout&quot; option will be used as a timeout. If 0, it will</para>
        /// <para>wait indefinitely. If &gt; 0, the timeout will be used (in milliseconds).</para>
        /// </param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>This fetches (local or network) art, meta data and/or tracks information.</para>
        /// <para>This method is the extended version of libvlc_media_parse_with_options().</para>
        /// <para>To track when this is over you can listen to libvlc_MediaParsedChanged</para>
        /// <para>event. However if this functions returns an error, you will not receive any</para>
        /// <para>events.</para>
        /// <para>It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All</para>
        /// <para>these flags can be combined. By default, media is parsed if it's a local</para>
        /// <para>file.</para>
        /// <para>Parsing can be aborted with libvlc_media_parse_stop().</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_tracks_get</para>
        /// <para>libvlc_media_get_parsed_status</para>
        /// <para>libvlc_media_parse_flag_t</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaParseWithOptions(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaParseOptions parse_flag, int timeout)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaParseWithOptions(__arg0, parse_flag, timeout);
            return __ret;
        }

        /// <summary>Stop the parsing of the media</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>When the media parsing is stopped, the libvlc_MediaParsedChanged event will</para>
        /// <para>be sent with the libvlc_media_parsed_status_timeout status.</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcMediaParseStop(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParseStop(__arg0);
        }

        /// <summary>Get Parsed status for media descriptor object.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>a value of the libvlc_media_parsed_status_t enum</returns>
        /// <remarks>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_parsed_status_t</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.MediaParsedStatus LibvlcMediaGetParsedStatus(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetParsedStatus(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets media descriptor's user_data. user_data is specialized data</para>
        /// <para>accessed by the host application, VLC.framework uses it as a pointer to</para>
        /// <para>an native object that references a libvlc_media_t pointer</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="p_new_user_data">pointer to user data</param>
        public static void LibvlcMediaSetUserData(global::libvlcsharp.Media p_md, global::System.IntPtr p_new_user_data)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSetUserData(__arg0, p_new_user_data);
        }

        /// <summary>
        /// <para>Get media descriptor's user_data. user_data is specialized data</para>
        /// <para>accessed by the host application, VLC.framework uses it as a pointer to</para>
        /// <para>an native object that references a libvlc_media_t pointer</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        public static global::System.IntPtr LibvlcMediaGetUserData(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetUserData(__arg0);
            return __ret;
        }

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed with libvlc_media_tracks_release</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams (zero on error)</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>LibVLC 2.1.0 and later.</para>
        /// </remarks>
        public static uint LibvlcMediaTracksGet(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaTrack tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaTracksGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get codec description from media elementary stream</summary>
        /// <param name="i_type">i_type from libvlc_media_track_t</param>
        /// <param name="i_codec">i_codec or i_original_fourcc from libvlc_media_track_t</param>
        /// <returns>codec description</returns>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_track_t</para>
        /// </remarks>
        public static string LibvlcMediaGetCodecDescription(global::libvlcsharp.TrackType i_type, uint i_codec)
        {
            var __ret = __Internal.LibvlcMediaGetCodecDescription(i_type, i_codec);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Release media descriptor's elementary streams description array</summary>
        /// <param name="p_tracks">tracks info array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>LibVLC 2.1.0 and later.</remarks>
        public static void LibvlcMediaTracksRelease(global::libvlcsharp.MediaTrack p_tracks, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_tracks, null) ? global::System.IntPtr.Zero : p_tracks.__Instance;
            __Internal.LibvlcMediaTracksRelease(__arg0, i_count);
        }

        /// <summary>Get the media type of the media descriptor object</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>media type</returns>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_type_t</para>
        /// </remarks>
        public static global::libvlcsharp.MediaType LibvlcMediaGetType(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaGetType(__arg0);
            return __ret;
        }

        /// <summary>Add a slave to the current media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="i_type">subtitle or audio</param>
        /// <param name="i_priority">from 0 (low priority) to 4 (high priority)</param>
        /// <param name="psz_uri">Uri of the slave (should contain a valid scheme).</param>
        /// <returns>0 on success, -1 on error.</returns>
        /// <remarks>
        /// <para>A slave is an external input source that may contains an additional subtitle</para>
        /// <para>track (like a .srt) or an additional audio track (like a .ac3).</para>
        /// <para>This function must be called before the media is parsed (via</para>
        /// <para>libvlc_media_parse_with_options()) or before the media is played (via</para>
        /// <para>libvlc_media_player_play())</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcMediaSlavesAdd(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaSlaveType i_type, uint i_priority, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaSlavesAdd(__arg0, i_type, i_priority, psz_uri);
            return __ret;
        }

        /// <summary>
        /// <para>Clear all slaves previously added by libvlc_media_slaves_add() or</para>
        /// <para>internally.</para>
        /// </summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaSlavesClear(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaSlavesClear(__arg0);
        }

        /// <summary>Get a media descriptor's slave list</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="ppp_slaves">
        /// <para>address to store an allocated array of slaves (must be</para>
        /// <para>freed with libvlc_media_slaves_release()) [OUT]</para>
        /// </param>
        /// <returns>the number of slaves (zero on error)</returns>
        /// <remarks>
        /// <para>The list will contain slaves parsed by VLC or previously added by</para>
        /// <para>libvlc_media_slaves_add(). The typical use case of this function is to save</para>
        /// <para>a list of slave in a database for a later use.</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_slaves_add</para>
        /// </remarks>
        public static uint LibvlcMediaSlavesGet(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaSlave ppp_slaves)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(ppp_slaves, null) ? global::System.IntPtr.Zero : ppp_slaves.__Instance;
            var __ret = __Internal.LibvlcMediaSlavesGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release a media descriptor's slave list</summary>
        /// <param name="pp_slaves">slave array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaSlavesRelease(global::libvlcsharp.MediaSlave pp_slaves, uint i_count)
        {
            var __arg0 = ReferenceEquals(pp_slaves, null) ? global::System.IntPtr.Zero : pp_slaves.__Instance;
            __Internal.LibvlcMediaSlavesRelease(__arg0, i_count);
        }
    }

    /// <summary>Description for titles</summary>
    public enum Title
    {
        Menu = 1,
        Interactive = 2
    }

    /// <summary>Marq options definition</summary>
    public enum VideoMarqueeOption
    {
        Enable = 0,
        Text = 1,
        /// <summary>string argument</summary>
        Color = 2,
        /// <summary>string argument</summary>
        Opacity = 3,
        /// <summary>string argument</summary>
        Position = 4,
        /// <summary>string argument</summary>
        Refresh = 5,
        /// <summary>string argument</summary>
        Size = 6,
        /// <summary>string argument</summary>
        Timeout = 7,
        /// <summary>string argument</summary>
        X = 8,
        /// <summary>string argument</summary>
        Y = 9
    }

    /// <summary>Navigation mode</summary>
    public enum NavigationMode
    {
        Activate = 0,
        Up = 1,
        Down = 2,
        Left = 3,
        Right = 4,
        Popup = 5
    }

    /// <summary>Enumeration of values used to set position (e.g. of video title).</summary>
    public enum Position
    {
        Disable = -1,
        Center = 0,
        Left = 1,
        Right = 2,
        Top = 3,
        TopLeft = 4,
        TopRight = 5,
        Bottom = 6,
        BottomLeft = 7,
        BottomRight = 8
    }

    /// <summary>
    /// <para>Enumeration of teletext keys than can be passed via</para>
    /// <para>libvlc_video_set_teletext()</para>
    /// </summary>
    public enum TeletextKey
    {
        Red = 7471104,
        Green = 6750208,
        Yellow = 7929856,
        Blue = 6422528,
        Index = 6881280
    }

    /// <summary>option values for libvlc_video_{get,set}_logo_{int,string}</summary>
    public enum VideoLogoOption
    {
        Enable = 0,
        /// <summary>string argument, &quot;file,d,t;file,d,t;...&quot;</summary>
        File = 1,
        X = 2,
        Y = 3,
        Delay = 4,
        Repeat = 5,
        Opacity = 6,
        Position = 7
    }

    /// <summary>option values for libvlc_video_{get,set}_adjust_{int,float,bool}</summary>
    public enum VideoAdjustOption
    {
        Enable = 0,
        Contrast = 1,
        Brightness = 2,
        Hue = 3,
        Saturation = 4,
        Gamma = 5
    }

    /// <summary>Audio device types</summary>
    public enum AudioOutputDeviceType
    {
        DeviceError = -1,
        DeviceMono = 1,
        DeviceStereo = 2,
        Device2F2R = 4,
        Device3F2R = 5,
        Device5_1 = 6,
        Device6_1 = 7,
        Device7_1 = 8,
        DeviceSPDIF = 10
    }

    /// <summary>Audio channels</summary>
    public enum AudioOutputChannel
    {
        Error = -1,
        Stereo = 1,
        RStereo = 2,
        Left = 3,
        Right = 4,
        Dolbys = 5
    }

    /// <summary>Media player roles.</summary>
    /// <remarks>
    /// <para>LibVLC 3.0.0 and later.</para>
    /// <para>See</para>
    /// </remarks>
    public enum MediaPlayerRole
    {
        /// <summary>Don't use a media player role</summary>
        None = 0,
        /// <summary>Music (or radio) playback</summary>
        Music = 1,
        /// <summary>Video playback</summary>
        Video = 2,
        /// <summary>Speech, real-time communication</summary>
        Communication = 3,
        /// <summary>Video game</summary>
        Game = 4,
        /// <summary>User interaction feedback</summary>
        LiblvcRoleNotification = 5,
        /// <summary>Embedded animation (e.g. in web page)</summary>
        Animation = 6,
        /// <summary>Audio editting/production</summary>
        Production = 7,
        /// <summary>Accessibility</summary>
        Accessibility = 8,
        Test = 9
    }

    /// <summary>
    /// <para>A LibVLC media player plays one media (usually in a custom drawable).</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC simple media player external API</para>
    /// </summary>
    /// <summary>Opaque equalizer handle.</summary>
    /// <remarks>Equalizer settings can be applied to a media player.</remarks>
    /// <summary>Callback prototype to allocate and lock a picture buffer.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="planes">
    /// <para>start address of the pixel planes (LibVLC allocates the array</para>
    /// <para>of void pointers, this callback must initialize the array) [OUT]</para>
    /// </param>
    /// <returns>
    /// <para>a private pointer for the display and unlock callbacks to identify</para>
    /// <para>the picture buffers</para>
    /// </returns>
    /// <remarks>
    /// <para>Whenever a new video frame needs to be decoded, the lock callback is</para>
    /// <para>invoked. Depending on the video chroma, one or three pixel planes of</para>
    /// <para>adequate dimensions must be returned via the second parameter. Those</para>
    /// <para>planes must be aligned on 32-bytes boundaries.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr LibvlcVideoLockCb(global::System.IntPtr opaque, void** planes);

    /// <summary>Callback prototype to unlock a picture buffer.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="picture">private pointer returned from the</param>
    /// <param name="planes">pixel planes as defined by the</param>
    /// <remarks>
    /// <para>When the video frame decoding is complete, the unlock callback is invoked.</para>
    /// <para>This callback might not be needed at all. It is only an indication that the</para>
    /// <para>application can now read the pixel values if it needs to.</para>
    /// <para>A picture buffer is unlocked after the picture is decoded,</para>
    /// <para>but before the picture is displayed.</para>
    /// <para>callback [IN]</para>
    /// <para>callback (this parameter is only for convenience) [IN]</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoUnlockCb(global::System.IntPtr opaque, global::System.IntPtr picture, void** planes);

    /// <summary>Callback prototype to display a picture.</summary>
    /// <param name="opaque">private pointer as passed to libvlc_video_set_callbacks() [IN]</param>
    /// <param name="picture">private pointer returned from the</param>
    /// <remarks>
    /// <para>When the video frame needs to be shown, as determined by the media playback</para>
    /// <para>clock, the display callback is invoked.</para>
    /// <para>callback [IN]</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoDisplayCb(global::System.IntPtr opaque, global::System.IntPtr picture);

    /// <summary>
    /// <para>Callback prototype to configure picture buffers format.</para>
    /// <para>This callback gets the format of the video as output by the video decoder</para>
    /// <para>and the chain of video filters (if any). It can opt to change any parameter</para>
    /// <para>as it needs. In that case, LibVLC will attempt to convert the video format</para>
    /// <para>(rescaling and chroma conversion) but these operations can be CPU intensive.</para>
    /// </summary>
    /// <param name="opaque">
    /// <para>pointer to the private pointer passed to</para>
    /// <para>libvlc_video_set_callbacks() [IN/OUT]</para>
    /// </param>
    /// <param name="chroma">pointer to the 4 bytes video format identifier [IN/OUT]</param>
    /// <param name="width">pointer to the pixel width [IN/OUT]</param>
    /// <param name="height">pointer to the pixel height [IN/OUT]</param>
    /// <param name="pitches">
    /// <para>table of scanline pitches in bytes for each pixel plane</para>
    /// <para>(the table is allocated by LibVLC) [OUT]</para>
    /// </param>
    /// <param name="lines">table of scanlines count for each plane [OUT]</param>
    /// <returns>the number of picture buffers allocated, 0 indicates failure</returns>
    /// <remarks>
    /// <para>For each pixels plane, the scanline pitch must be bigger than or equal to</para>
    /// <para>the number of bytes per pixel multiplied by the pixel width.</para>
    /// <para>Similarly, the number of scanlines must be bigger than of equal to</para>
    /// <para>the pixel height.</para>
    /// <para>Furthermore, we recommend that pitches and lines be multiple of 32</para>
    /// <para>to not break assumptions that might be held by optimized code</para>
    /// <para>in the video decoders, video filters and/or video converters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate uint LibvlcVideoFormatCb(void** opaque, sbyte* chroma, uint* width, uint* height, uint* pitches, uint* lines);

    /// <summary>Callback prototype to configure picture buffers format.</summary>
    /// <param name="opaque">
    /// <para>private pointer as passed to libvlc_video_set_callbacks()</para>
    /// <para>(and possibly modified by</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcVideoCleanupCb(global::System.IntPtr opaque);

    /// <summary>Callback prototype for audio playback.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="samples">pointer to a table of audio samples to play back [IN]</param>
    /// <param name="count">number of audio samples to play back</param>
    /// <param name="pts">expected play time stamp (see libvlc_delay())</param>
    /// <remarks>
    /// <para>The LibVLC media player decodes and post-processes the audio signal</para>
    /// <para>asynchronously (in an internal thread). Whenever audio samples are ready</para>
    /// <para>to be queued to the output, this callback is invoked.</para>
    /// <para>The number of samples provided per invocation may depend on the file format,</para>
    /// <para>the audio coding algorithm, the decoder plug-in, the post-processing</para>
    /// <para>filters and timing. Application must not assume a certain number of samples.</para>
    /// <para>The exact format of audio samples is determined by libvlc_audio_set_format()</para>
    /// <para>or libvlc_audio_set_format_callbacks() as is the channels layout.</para>
    /// <para>Note that the number of samples is per channel. For instance, if the audio</para>
    /// <para>track sampling rate is 48000&#160;Hz, then 1200&#160;samples represent 25&#160;milliseconds</para>
    /// <para>of audio signal - regardless of the number of audio channels.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioPlayCb(global::System.IntPtr data, global::System.IntPtr samples, uint count, long pts);

    /// <summary>Callback prototype for audio pause.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="pts">time stamp of the pause request (should be elapsed already)</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback to pause audio playback.</para>
    /// <para>The pause callback is never called if the audio is already paused.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioPauseCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio resumption.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="pts">time stamp of the resumption request (should be elapsed already)</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback to resume audio playback after it was</para>
    /// <para>previously paused.</para>
    /// <para>The resume callback is never called if the audio is not paused.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioResumeCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio buffer flush.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>
    /// <para>LibVLC invokes this callback if it needs to discard all pending buffers and</para>
    /// <para>stop playback as soon as possible. This typically occurs when the media is</para>
    /// <para>stopped.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioFlushCb(global::System.IntPtr data, long pts);

    /// <summary>Callback prototype for audio buffer drain.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>
    /// <para>LibVLC may invoke this callback when the decoded audio track is ending.</para>
    /// <para>There will be no further decoded samples for the track, but playback should</para>
    /// <para>nevertheless continue until all already pending buffers are rendered.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioDrainCb(global::System.IntPtr data);

    /// <summary>Callback prototype for audio volume change.</summary>
    /// <param name="data">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <param name="volume">software volume (1. = nominal, 0. = mute)</param>
    /// <param name="mute">muted flag</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioSetVolumeCb(global::System.IntPtr data, float volume, [MarshalAs(UnmanagedType.I1)] bool mute);

    /// <summary>Callback prototype to setup the audio playback.</summary>
    /// <param name="opaque">
    /// <para>pointer to the data pointer passed to</para>
    /// <para>libvlc_audio_set_callbacks() [IN/OUT]</para>
    /// </param>
    /// <param name="format">4 bytes sample format [IN/OUT]</param>
    /// <param name="rate">sample rate [IN/OUT]</param>
    /// <param name="channels">channels count [IN/OUT]</param>
    /// <returns>0 on success, anything else to skip audio playback</returns>
    /// <remarks>This is called when the media player needs to create a new audio output.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int LibvlcAudioSetupCb(void** data, sbyte* format, uint* rate, uint* channels);

    /// <summary>Callback prototype for audio playback cleanup.</summary>
    /// <param name="opaque">data pointer as passed to libvlc_audio_set_callbacks() [IN]</param>
    /// <remarks>This is called when the media player no longer needs an audio output.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void LibvlcAudioCleanupCb(global::System.IntPtr data);

    public unsafe partial class MediaPlayer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaPlayer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaPlayer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaPlayer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaPlayer(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaPlayer __CreateInstance(global::libvlcsharp.MediaPlayer.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaPlayer(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaPlayer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaPlayer.__Internal));
            *(global::libvlcsharp.MediaPlayer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaPlayer(global::libvlcsharp.MediaPlayer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaPlayer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Equalizer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Equalizer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Equalizer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.Equalizer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Equalizer(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.Equalizer __CreateInstance(global::libvlcsharp.Equalizer.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Equalizer(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.Equalizer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.Equalizer.__Internal));
            *(global::libvlcsharp.Equalizer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Equalizer(global::libvlcsharp.Equalizer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Equalizer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>
    /// <para>Description for video, audio tracks and subtitles. It contains</para>
    /// <para>id, name (description string) and pointer to next record.</para>
    /// </summary>
    public unsafe partial class TrackDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_id;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal global::System.IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_track_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.TrackDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.TrackDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.TrackDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.TrackDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.TrackDescription __CreateInstance(global::libvlcsharp.TrackDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.TrackDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.TrackDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TrackDescription.__Internal));
            *(global::libvlcsharp.TrackDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TrackDescription(global::libvlcsharp.TrackDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TrackDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TrackDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TrackDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TrackDescription(global::libvlcsharp.TrackDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TrackDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.TrackDescription.__Internal*) __Instance) = *((global::libvlcsharp.TrackDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.TrackDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int IId
        {
            get
            {
                return ((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->i_id;
            }

            set
            {
                ((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->i_id = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.TrackDescription PNext
        {
            get
            {
                global::libvlcsharp.TrackDescription __result0;
                if (((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlcsharp.TrackDescription.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class TitleDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_duration;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(16)]
            internal uint i_flags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_title_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.TitleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.TitleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.TitleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.TitleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.TitleDescription __CreateInstance(global::libvlcsharp.TitleDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.TitleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.TitleDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TitleDescription.__Internal));
            *(global::libvlcsharp.TitleDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TitleDescription(global::libvlcsharp.TitleDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TitleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TitleDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TitleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TitleDescription(global::libvlcsharp.TitleDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.TitleDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.TitleDescription.__Internal*) __Instance) = *((global::libvlcsharp.TitleDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.TitleDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long IDuration
        {
            get
            {
                return ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public uint IFlags
        {
            get
            {
                return ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->i_flags;
            }

            set
            {
                ((global::libvlcsharp.TitleDescription.__Internal*) __Instance)->i_flags = value;
            }
        }
    }

    /// <summary>Description for chapters</summary>
    public unsafe partial class ChapterDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long i_time_offset;

            [FieldOffset(8)]
            internal long i_duration;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_chapter_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ChapterDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ChapterDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.ChapterDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ChapterDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.ChapterDescription __CreateInstance(global::libvlcsharp.ChapterDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ChapterDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.ChapterDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ChapterDescription.__Internal));
            *(global::libvlcsharp.ChapterDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ChapterDescription(global::libvlcsharp.ChapterDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ChapterDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ChapterDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ChapterDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ChapterDescription(global::libvlcsharp.ChapterDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ChapterDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.ChapterDescription.__Internal*) __Instance) = *((global::libvlcsharp.ChapterDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.ChapterDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long ITimeOffset
        {
            get
            {
                return ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->i_time_offset;
            }

            set
            {
                ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->i_time_offset = value;
            }
        }

        public long IDuration
        {
            get
            {
                return ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->i_duration;
            }

            set
            {
                ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->i_duration = value;
            }
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.ChapterDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>Description for audio output. It contains</para>
    /// <para>name, description and pointer to next record.</para>
    /// </summary>
    public unsafe partial class AudioOutput : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_description;

            [FieldOffset(16)]
            internal global::System.IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_audio_output_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioOutput> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioOutput>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.AudioOutput __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioOutput(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.AudioOutput __CreateInstance(global::libvlcsharp.AudioOutput.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioOutput(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.AudioOutput.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutput.__Internal));
            *(global::libvlcsharp.AudioOutput.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioOutput(global::libvlcsharp.AudioOutput.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioOutput(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioOutput()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutput.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioOutput(global::libvlcsharp.AudioOutput _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutput.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.AudioOutput.__Internal*) __Instance) = *((global::libvlcsharp.AudioOutput.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.AudioOutput __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.AudioOutput PNext
        {
            get
            {
                global::libvlcsharp.AudioOutput __result0;
                if (((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlcsharp.AudioOutput.NativeToManagedMap.ContainsKey(((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlcsharp.AudioOutput) global::libvlcsharp.AudioOutput.NativeToManagedMap[((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlcsharp.AudioOutput.__CreateInstance(((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlcsharp.AudioOutput.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Description for audio output device.</summary>
    public unsafe partial class AudioOutputDevice : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr p_next;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_device;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_description;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_audio_output_device_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioOutputDevice> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.AudioOutputDevice>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.AudioOutputDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioOutputDevice(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.AudioOutputDevice __CreateInstance(global::libvlcsharp.AudioOutputDevice.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.AudioOutputDevice(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.AudioOutputDevice.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutputDevice.__Internal));
            *(global::libvlcsharp.AudioOutputDevice.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioOutputDevice(global::libvlcsharp.AudioOutputDevice.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AudioOutputDevice(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AudioOutputDevice()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutputDevice.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AudioOutputDevice(global::libvlcsharp.AudioOutputDevice _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.AudioOutputDevice.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance) = *((global::libvlcsharp.AudioOutputDevice.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.AudioOutputDevice __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::libvlcsharp.AudioOutputDevice PNext
        {
            get
            {
                global::libvlcsharp.AudioOutputDevice __result0;
                if (((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->p_next == IntPtr.Zero) __result0 = null;
                else if (global::libvlcsharp.AudioOutputDevice.NativeToManagedMap.ContainsKey(((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->p_next))
                    __result0 = (global::libvlcsharp.AudioOutputDevice) global::libvlcsharp.AudioOutputDevice.NativeToManagedMap[((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->p_next];
                else __result0 = global::libvlcsharp.AudioOutputDevice.__CreateInstance(((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte* PszDevice
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->psz_device;
            }

            set
            {
                ((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->psz_device = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszDescription
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->psz_description;
            }

            set
            {
                ((global::libvlcsharp.AudioOutputDevice.__Internal*) __Instance)->psz_description = (global::System.IntPtr) value;
            }
        }
    }

    /// <summary>Viewpoint for video outputs</summary>
    /// <remarks>allocate using libvlc_video_new_viewpoint()</remarks>
    public unsafe partial class VideoViewpoint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float f_yaw;

            [FieldOffset(4)]
            internal float f_pitch;

            [FieldOffset(8)]
            internal float f_roll;

            [FieldOffset(12)]
            internal float f_field_of_view;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_video_viewpoint_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.VideoViewpoint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.VideoViewpoint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.VideoViewpoint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.VideoViewpoint(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.VideoViewpoint __CreateInstance(global::libvlcsharp.VideoViewpoint.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.VideoViewpoint(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.VideoViewpoint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoViewpoint.__Internal));
            *(global::libvlcsharp.VideoViewpoint.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VideoViewpoint(global::libvlcsharp.VideoViewpoint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VideoViewpoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VideoViewpoint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoViewpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VideoViewpoint(global::libvlcsharp.VideoViewpoint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.VideoViewpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance) = *((global::libvlcsharp.VideoViewpoint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.VideoViewpoint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FYaw
        {
            get
            {
                return ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_yaw;
            }

            set
            {
                ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_yaw = value;
            }
        }

        public float FPitch
        {
            get
            {
                return ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_pitch;
            }

            set
            {
                ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_pitch = value;
            }
        }

        public float FRoll
        {
            get
            {
                return ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_roll;
            }

            set
            {
                ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_roll = value;
            }
        }

        public float FFieldOfView
        {
            get
            {
                return ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_field_of_view;
            }

            set
            {
                ((global::libvlcsharp.VideoViewpoint.__Internal*) __Instance)->f_field_of_view = value;
            }
        }
    }

    public unsafe partial class libvlc_media_player
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_new")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerNew(global::System.IntPtr p_libvlc_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_new_from_media")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerNewFromMedia(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_release")]
            internal static extern void LibvlcMediaPlayerRelease(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_retain")]
            internal static extern void LibvlcMediaPlayerRetain(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_media")]
            internal static extern void LibvlcMediaPlayerSetMedia(global::System.IntPtr p_mi, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_media")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetMedia(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerEventManager(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_is_playing")]
            internal static extern int LibvlcMediaPlayerIsPlaying(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_play")]
            internal static extern int LibvlcMediaPlayerPlay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_pause")]
            internal static extern void LibvlcMediaPlayerSetPause(global::System.IntPtr mp, int do_pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_pause")]
            internal static extern void LibvlcMediaPlayerPause(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_stop")]
            internal static extern void LibvlcMediaPlayerStop(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_renderer")]
            internal static extern int LibvlcMediaPlayerSetRenderer(global::System.IntPtr p_mi, global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_callbacks")]
            internal static extern void LibvlcVideoSetCallbacks(global::System.IntPtr mp, global::System.IntPtr @lock, global::System.IntPtr unlock, global::System.IntPtr display, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_format")]
            internal static extern void LibvlcVideoSetFormat(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string chroma, uint width, uint height, uint pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_format_callbacks")]
            internal static extern void LibvlcVideoSetFormatCallbacks(global::System.IntPtr mp, global::System.IntPtr setup, global::System.IntPtr cleanup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_nsobject")]
            internal static extern void LibvlcMediaPlayerSetNsobject(global::System.IntPtr p_mi, global::System.IntPtr drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_nsobject")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetNsobject(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_xwindow")]
            internal static extern void LibvlcMediaPlayerSetXwindow(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_xwindow")]
            internal static extern uint LibvlcMediaPlayerGetXwindow(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_hwnd")]
            internal static extern void LibvlcMediaPlayerSetHwnd(global::System.IntPtr p_mi, global::System.IntPtr drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_hwnd")]
            internal static extern global::System.IntPtr LibvlcMediaPlayerGetHwnd(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_android_context")]
            internal static extern void LibvlcMediaPlayerSetAndroidContext(global::System.IntPtr p_mi, global::System.IntPtr p_awindow_handler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_evas_object")]
            internal static extern int LibvlcMediaPlayerSetEvasObject(global::System.IntPtr p_mi, global::System.IntPtr p_evas_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_callbacks")]
            internal static extern void LibvlcAudioSetCallbacks(global::System.IntPtr mp, global::System.IntPtr play, global::System.IntPtr pause, global::System.IntPtr resume, global::System.IntPtr flush, global::System.IntPtr drain, global::System.IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_volume_callback")]
            internal static extern void LibvlcAudioSetVolumeCallback(global::System.IntPtr mp, global::System.IntPtr set_volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_format_callbacks")]
            internal static extern void LibvlcAudioSetFormatCallbacks(global::System.IntPtr mp, global::System.IntPtr setup, global::System.IntPtr cleanup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_format")]
            internal static extern void LibvlcAudioSetFormat(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string format, uint rate, uint channels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_length")]
            internal static extern long LibvlcMediaPlayerGetLength(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_time")]
            internal static extern long LibvlcMediaPlayerGetTime(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_time")]
            internal static extern void LibvlcMediaPlayerSetTime(global::System.IntPtr p_mi, long i_time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_position")]
            internal static extern float LibvlcMediaPlayerGetPosition(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_position")]
            internal static extern void LibvlcMediaPlayerSetPosition(global::System.IntPtr p_mi, float f_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_chapter")]
            internal static extern void LibvlcMediaPlayerSetChapter(global::System.IntPtr p_mi, int i_chapter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter")]
            internal static extern int LibvlcMediaPlayerGetChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter_count")]
            internal static extern int LibvlcMediaPlayerGetChapterCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_will_play")]
            internal static extern int LibvlcMediaPlayerWillPlay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_chapter_count_for_title")]
            internal static extern int LibvlcMediaPlayerGetChapterCountForTitle(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_title")]
            internal static extern void LibvlcMediaPlayerSetTitle(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_title")]
            internal static extern int LibvlcMediaPlayerGetTitle(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_title_count")]
            internal static extern int LibvlcMediaPlayerGetTitleCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_previous_chapter")]
            internal static extern void LibvlcMediaPlayerPreviousChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_next_chapter")]
            internal static extern void LibvlcMediaPlayerNextChapter(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_rate")]
            internal static extern float LibvlcMediaPlayerGetRate(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_rate")]
            internal static extern int LibvlcMediaPlayerSetRate(global::System.IntPtr p_mi, float rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_state")]
            internal static extern global::libvlcsharp.VLCState LibvlcMediaPlayerGetState(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_has_vout")]
            internal static extern uint LibvlcMediaPlayerHasVout(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_is_seekable")]
            internal static extern int LibvlcMediaPlayerIsSeekable(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_can_pause")]
            internal static extern int LibvlcMediaPlayerCanPause(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_program_scrambled")]
            internal static extern int LibvlcMediaPlayerProgramScrambled(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_next_frame")]
            internal static extern void LibvlcMediaPlayerNextFrame(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_navigate")]
            internal static extern void LibvlcMediaPlayerNavigate(global::System.IntPtr p_mi, uint navigate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_video_title_display")]
            internal static extern void LibvlcMediaPlayerSetVideoTitleDisplay(global::System.IntPtr p_mi, global::libvlcsharp.Position position, uint timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_add_slave")]
            internal static extern int LibvlcMediaPlayerAddSlave(global::System.IntPtr p_mi, global::libvlcsharp.MediaSlaveType i_type, [MarshalAs(UnmanagedType.LPStr)] string psz_uri, bool b_select);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_track_description_list_release")]
            internal static extern void LibvlcTrackDescriptionListRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_toggle_fullscreen")]
            internal static extern void LibvlcToggleFullscreen(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_fullscreen")]
            internal static extern void LibvlcSetFullscreen(global::System.IntPtr p_mi, int b_fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_fullscreen")]
            internal static extern int LibvlcGetFullscreen(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_key_input")]
            internal static extern void LibvlcVideoSetKeyInput(global::System.IntPtr p_mi, uint on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_mouse_input")]
            internal static extern void LibvlcVideoSetMouseInput(global::System.IntPtr p_mi, uint on);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_size")]
            internal static extern int LibvlcVideoGetSize(global::System.IntPtr p_mi, uint num, uint* px, uint* py);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_cursor")]
            internal static extern int LibvlcVideoGetCursor(global::System.IntPtr p_mi, uint num, int* px, int* py);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_scale")]
            internal static extern float LibvlcVideoGetScale(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_scale")]
            internal static extern void LibvlcVideoSetScale(global::System.IntPtr p_mi, float f_factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_aspect_ratio")]
            internal static extern sbyte* LibvlcVideoGetAspectRatio(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_aspect_ratio")]
            internal static extern void LibvlcVideoSetAspectRatio(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_aspect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_new_viewpoint")]
            internal static extern global::System.IntPtr LibvlcVideoNewViewpoint();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_update_viewpoint")]
            internal static extern int LibvlcVideoUpdateViewpoint(global::System.IntPtr p_mi, global::System.IntPtr p_viewpoint, bool b_absolute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu")]
            internal static extern int LibvlcVideoGetSpu(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_count")]
            internal static extern int LibvlcVideoGetSpuCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetSpuDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_spu")]
            internal static extern int LibvlcVideoSetSpu(global::System.IntPtr p_mi, int i_spu);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_spu_delay")]
            internal static extern long LibvlcVideoGetSpuDelay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_spu_delay")]
            internal static extern int LibvlcVideoSetSpuDelay(global::System.IntPtr p_mi, long i_delay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_full_title_descriptions")]
            internal static extern int LibvlcMediaPlayerGetFullTitleDescriptions(global::System.IntPtr p_mi, global::System.IntPtr titles);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_title_descriptions_release")]
            internal static extern void LibvlcTitleDescriptionsRelease(global::System.IntPtr p_titles, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_full_chapter_descriptions")]
            internal static extern int LibvlcMediaPlayerGetFullChapterDescriptions(global::System.IntPtr p_mi, int i_chapters_of_title, global::System.IntPtr pp_chapters);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_chapter_descriptions_release")]
            internal static extern void LibvlcChapterDescriptionsRelease(global::System.IntPtr p_chapters, uint i_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_crop_geometry")]
            internal static extern sbyte* LibvlcVideoGetCropGeometry(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_crop_geometry")]
            internal static extern void LibvlcVideoSetCropGeometry(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_geometry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_teletext")]
            internal static extern int LibvlcVideoGetTeletext(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_teletext")]
            internal static extern void LibvlcVideoSetTeletext(global::System.IntPtr p_mi, int i_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track_count")]
            internal static extern int LibvlcVideoGetTrackCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetTrackDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_track")]
            internal static extern int LibvlcVideoGetTrack(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_track")]
            internal static extern int LibvlcVideoSetTrack(global::System.IntPtr p_mi, int i_track);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_take_snapshot")]
            internal static extern int LibvlcVideoTakeSnapshot(global::System.IntPtr p_mi, uint num, [MarshalAs(UnmanagedType.LPStr)] string psz_filepath, uint i_width, uint i_height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_deinterlace")]
            internal static extern void LibvlcVideoSetDeinterlace(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_marquee_int")]
            internal static extern int LibvlcVideoGetMarqueeInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_marquee_string")]
            internal static extern sbyte* LibvlcVideoGetMarqueeString(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_marquee_int")]
            internal static extern void LibvlcVideoSetMarqueeInt(global::System.IntPtr p_mi, uint option, int i_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_marquee_string")]
            internal static extern void LibvlcVideoSetMarqueeString(global::System.IntPtr p_mi, uint option, [MarshalAs(UnmanagedType.LPStr)] string psz_text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_logo_int")]
            internal static extern int LibvlcVideoGetLogoInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_logo_int")]
            internal static extern void LibvlcVideoSetLogoInt(global::System.IntPtr p_mi, uint option, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_logo_string")]
            internal static extern void LibvlcVideoSetLogoString(global::System.IntPtr p_mi, uint option, [MarshalAs(UnmanagedType.LPStr)] string psz_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_adjust_int")]
            internal static extern int LibvlcVideoGetAdjustInt(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_adjust_int")]
            internal static extern void LibvlcVideoSetAdjustInt(global::System.IntPtr p_mi, uint option, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_adjust_float")]
            internal static extern float LibvlcVideoGetAdjustFloat(global::System.IntPtr p_mi, uint option);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_adjust_float")]
            internal static extern void LibvlcVideoSetAdjustFloat(global::System.IntPtr p_mi, uint option, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioOutputListGet(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_list_release")]
            internal static extern void LibvlcAudioOutputListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_set")]
            internal static extern int LibvlcAudioOutputSet(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_enum")]
            internal static extern global::System.IntPtr LibvlcAudioOutputDeviceEnum(global::System.IntPtr mp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_list_get")]
            internal static extern global::System.IntPtr LibvlcAudioOutputDeviceListGet(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string aout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_list_release")]
            internal static extern void LibvlcAudioOutputDeviceListRelease(global::System.IntPtr p_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_set")]
            internal static extern void LibvlcAudioOutputDeviceSet(global::System.IntPtr mp, [MarshalAs(UnmanagedType.LPStr)] string module, [MarshalAs(UnmanagedType.LPStr)] string device_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_get")]
            internal static extern sbyte* LibvlcAudioOutputDeviceGet(global::System.IntPtr mp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_toggle_mute")]
            internal static extern void LibvlcAudioToggleMute(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_mute")]
            internal static extern int LibvlcAudioGetMute(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_mute")]
            internal static extern void LibvlcAudioSetMute(global::System.IntPtr p_mi, int status);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_volume")]
            internal static extern int LibvlcAudioGetVolume(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_volume")]
            internal static extern int LibvlcAudioSetVolume(global::System.IntPtr p_mi, int i_volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track_count")]
            internal static extern int LibvlcAudioGetTrackCount(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track_description")]
            internal static extern global::System.IntPtr LibvlcAudioGetTrackDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_track")]
            internal static extern int LibvlcAudioGetTrack(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_track")]
            internal static extern int LibvlcAudioSetTrack(global::System.IntPtr p_mi, int i_track);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_channel")]
            internal static extern int LibvlcAudioGetChannel(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_channel")]
            internal static extern int LibvlcAudioSetChannel(global::System.IntPtr p_mi, int channel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_get_delay")]
            internal static extern long LibvlcAudioGetDelay(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_set_delay")]
            internal static extern int LibvlcAudioSetDelay(global::System.IntPtr p_mi, long i_delay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preset_count")]
            internal static extern uint LibvlcAudioEqualizerGetPresetCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preset_name")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerGetPresetName(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_band_count")]
            internal static extern uint LibvlcAudioEqualizerGetBandCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_band_frequency")]
            internal static extern float LibvlcAudioEqualizerGetBandFrequency(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_new")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerNew();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_new_from_preset")]
            internal static extern global::System.IntPtr LibvlcAudioEqualizerNewFromPreset(uint u_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_release")]
            internal static extern void LibvlcAudioEqualizerRelease(global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_set_preamp")]
            internal static extern int LibvlcAudioEqualizerSetPreamp(global::System.IntPtr p_equalizer, float f_preamp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_preamp")]
            internal static extern float LibvlcAudioEqualizerGetPreamp(global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_set_amp_at_index")]
            internal static extern int LibvlcAudioEqualizerSetAmpAtIndex(global::System.IntPtr p_equalizer, float f_amp, uint u_band);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_equalizer_get_amp_at_index")]
            internal static extern float LibvlcAudioEqualizerGetAmpAtIndex(global::System.IntPtr p_equalizer, uint u_band);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_equalizer")]
            internal static extern int LibvlcMediaPlayerSetEqualizer(global::System.IntPtr p_mi, global::System.IntPtr p_equalizer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_role")]
            internal static extern int LibvlcMediaPlayerGetRole(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_role")]
            internal static extern int LibvlcMediaPlayerSetRole(global::System.IntPtr p_mi, uint role);
        }

        /// <summary>Create an empty Media Player object</summary>
        /// <param name="p_libvlc_instance">
        /// <para>the libvlc instance in which the Media Player</para>
        /// <para>should be created.</para>
        /// </param>
        /// <returns>a new media player object, or NULL on error.</returns>
        public static global::libvlcsharp.MediaPlayer LibvlcMediaPlayerNew(global::libvlcsharp.Instance p_libvlc_instance)
        {
            var __arg0 = ReferenceEquals(p_libvlc_instance, null) ? global::System.IntPtr.Zero : p_libvlc_instance.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerNew(__arg0);
            global::libvlcsharp.MediaPlayer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaPlayer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaPlayer) global::libvlcsharp.MediaPlayer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaPlayer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Create a Media Player object from a Media</summary>
        /// <param name="p_md">
        /// <para>the media. Afterwards the p_md can be safely</para>
        /// <para>destroyed.</para>
        /// </param>
        /// <returns>a new media player object, or NULL on error.</returns>
        public static global::libvlcsharp.MediaPlayer LibvlcMediaPlayerNewFromMedia(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerNewFromMedia(__arg0);
            global::libvlcsharp.MediaPlayer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaPlayer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaPlayer) global::libvlcsharp.MediaPlayer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaPlayer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release a media_player after use</para>
        /// <para>Decrement the reference count of a media player object. If the</para>
        /// <para>reference count is 0, then libvlc_media_player_release() will</para>
        /// <para>release the media player object. If the media player object</para>
        /// <para>has been released, then it should not be used again.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player to free</param>
        public static void LibvlcMediaPlayerRelease(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media player object. Use</para>
        /// <para>libvlc_media_player_release() to decrement reference count.</para>
        /// </summary>
        /// <param name="p_mi">media player object</param>
        public static void LibvlcMediaPlayerRetain(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerRetain(__arg0);
        }

        /// <summary>
        /// <para>Set the media that will be used by the media_player. If any,</para>
        /// <para>previous md will be released.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="p_md">
        /// <para>the Media. Afterwards the p_md can be safely</para>
        /// <para>destroyed.</para>
        /// </param>
        public static void LibvlcMediaPlayerSetMedia(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaPlayerSetMedia(__arg0, __arg1);
        }

        /// <summary>Get the media used by the media_player.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>
        /// <para>the media associated with p_mi, or NULL if no</para>
        /// <para>media is associated</para>
        /// </returns>
        public static global::libvlcsharp.Media LibvlcMediaPlayerGetMedia(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetMedia(__arg0);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the Event Manager from which the media player send event.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the event manager associated with p_mi</returns>
        public static global::libvlcsharp.EventManager LibvlcMediaPlayerEventManager(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>is_playing</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>1 if the media player is playing, 0 otherwise</returns>
        public static int LibvlcMediaPlayerIsPlaying(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerIsPlaying(__arg0);
            return __ret;
        }

        /// <summary>Play</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>0 if playback started (and was already started), or -1 on error.</returns>
        public static int LibvlcMediaPlayerPlay(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerPlay(__arg0);
            return __ret;
        }

        /// <summary>Pause or resume (no effect if there is no media)</summary>
        /// <param name="mp">the Media Player</param>
        /// <param name="do_pause">play/resume if zero, pause if non-zero</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static void LibvlcMediaPlayerSetPause(global::libvlcsharp.MediaPlayer mp, int do_pause)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcMediaPlayerSetPause(__arg0, do_pause);
        }

        /// <summary>Toggle pause (no effect if there is no media)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerPause(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerPause(__arg0);
        }

        /// <summary>Stop (no effect if there is no media)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerStop(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerStop(__arg0);
        }

        /// <summary>Set a renderer to the media player</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="p_item">an item discovered by libvlc_renderer_discoverer_start()</param>
        /// <returns>0 on success, -1 on error.</returns>
        /// <remarks>
        /// <para>must be called before the first call of libvlc_media_player_play() to</para>
        /// <para>take effect.</para>
        /// <para>libvlc_renderer_discoverer_new</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaPlayerSetRenderer(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetRenderer(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Set callbacks and private data to render decoded video to a custom area</para>
        /// <para>in memory.</para>
        /// <para>Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()</para>
        /// <para>to configure the decoded format.</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="lock">callback to lock video memory (must not be NULL)</param>
        /// <param name="unlock">callback to unlock video memory (or NULL if not needed)</param>
        /// <param name="display">callback to display video (or NULL if not needed)</param>
        /// <param name="opaque">private pointer for the three callbacks (as first parameter)</param>
        /// <remarks>
        /// <para>Rendering video into custom memory buffers is considerably less</para>
        /// <para>efficient than rendering in a custom window as normal.</para>
        /// <para>For optimal perfomances, VLC media player renders into a custom window, and</para>
        /// <para>does not use this function and associated callbacks. It ishighly</para>
        /// <para>recommendedthat other LibVLC-based application do likewise.</para>
        /// <para>To embed video in a window, use libvlc_media_player_set_xid() or equivalent</para>
        /// <para>depending on the operating system.</para>
        /// <para>If window embedding does not fit the application use case, then a custom</para>
        /// <para>LibVLC video output display plugin is required to maintain optimal video</para>
        /// <para>rendering performances.</para>
        /// <para>The following limitations affect performance:</para>
        /// <para>- Hardware video decoding acceleration will either be disabled completely,</para>
        /// <para>or require (relatively slow) copy from video/DSP memory to main memory.</para>
        /// <para>- Sub-pictures (subtitles, on-screen display, etc.) must be blent into the</para>
        /// <para>main picture by the CPU instead of the GPU.</para>
        /// <para>- Depending on the video format, pixel format conversion, picture scaling,</para>
        /// <para>cropping and/or picture re-orientation, must be performed by the CPU</para>
        /// <para>instead of the GPU.</para>
        /// <para>- Memory copying is required between LibVLC reference picture buffers and</para>
        /// <para>application buffers (between lock and unlock callbacks).</para>
        /// <para>LibVLC 1.1.1 or later</para>
        /// </remarks>
        public static void LibvlcVideoSetCallbacks(global::libvlcsharp.MediaPlayer mp, global::libvlcsharp.LibvlcVideoLockCb @lock, global::libvlcsharp.LibvlcVideoUnlockCb unlock, global::libvlcsharp.LibvlcVideoDisplayCb display, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = @lock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(@lock);
            var __arg2 = unlock == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(unlock);
            var __arg3 = display == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(display);
            __Internal.LibvlcVideoSetCallbacks(__arg0, __arg1, __arg2, __arg3, opaque);
        }

        /// <summary>
        /// <para>Set decoded video chroma and dimensions.</para>
        /// <para>This only works in combination with libvlc_video_set_callbacks(),</para>
        /// <para>and is mutually exclusive with libvlc_video_set_format_callbacks().</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="chroma">
        /// <para>a four-characters string identifying the chroma</para>
        /// <para>(e.g. &quot;RV32&quot; or &quot;YUYV&quot;)</para>
        /// </param>
        /// <param name="width">pixel width</param>
        /// <param name="height">pixel height</param>
        /// <param name="pitch">line pitch (in bytes)</param>
        /// <remarks>
        /// <para>LibVLC 1.1.1 or later</para>
        /// <para>All pixel planes are expected to have the same pitch.</para>
        /// <para>To use the YCbCr color space with chrominance subsampling,</para>
        /// <para>consider using libvlc_video_set_format_callbacks() instead.</para>
        /// </remarks>
        public static void LibvlcVideoSetFormat(global::libvlcsharp.MediaPlayer mp, string chroma, uint width, uint height, uint pitch)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcVideoSetFormat(__arg0, chroma, width, height, pitch);
        }

        /// <summary>
        /// <para>Set decoded video chroma and dimensions. This only works in combination with</para>
        /// <para>libvlc_video_set_callbacks().</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="setup">callback to select the video format (cannot be NULL)</param>
        /// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static void LibvlcVideoSetFormatCallbacks(global::libvlcsharp.MediaPlayer mp, global::libvlcsharp.LibvlcVideoFormatCb setup, global::libvlcsharp.LibvlcVideoCleanupCb cleanup)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
            var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
            __Internal.LibvlcVideoSetFormatCallbacks(__arg0, __arg1, __arg2);
        }

        /// <summary>Set the NSView handler where the media player should render its video output.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="drawable">
        /// <para>the drawable that is either an NSView or an object following</para>
        /// <para>the VLCOpenGLVideoViewEmbedding protocol.</para>
        /// </param>
        /// <remarks>
        /// <para>Use the vout called &quot;macosx&quot;.</para>
        /// <para>The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding</para>
        /// <para>protocol:</para>
        /// <para>Or it can be an NSView object.</para>
        /// <para>If you want to use it along with Qt see the QMacCocoaViewContainer. Then</para>
        /// <para>the following code should work:</para>
        /// <para>You can find a live example in VLCVideoView in VLCKit.framework.</para>
        /// </remarks>
        public static void LibvlcMediaPlayerSetNsobject(global::libvlcsharp.MediaPlayer p_mi, global::System.IntPtr drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetNsobject(__arg0, drawable);
        }

        /// <summary>Get the NSView handler previously set with libvlc_media_player_set_nsobject().</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the NSView handler or 0 if none where set</returns>
        public static global::System.IntPtr LibvlcMediaPlayerGetNsobject(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetNsobject(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set an X Window System drawable where the media player should render its</para>
        /// <para>video output. The call takes effect when the playback starts. If it is</para>
        /// <para>already started, it might need to be stopped before changes apply.</para>
        /// <para>If LibVLC was built without X11 output support, then this function has no</para>
        /// <para>effects.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="drawable">X11 window ID</param>
        /// <remarks>
        /// <para>By default, LibVLC will capture input events on the video rendering area.</para>
        /// <para>Use libvlc_video_set_mouse_input() and libvlc_video_set_key_input() to</para>
        /// <para>disable that and deliver events to the parent window / to the application</para>
        /// <para>instead. By design, the X11 protocol delivers input events to only one</para>
        /// <para>recipient.</para>
        /// <para>The application must call the XInitThreads() function from Xlib before</para>
        /// <para>libvlc_new(), and before any call to XOpenDisplay() directly or via any</para>
        /// <para>other library. Failure to call XInitThreads() will seriously impede LibVLC</para>
        /// <para>performance. Calling XOpenDisplay() before XInitThreads() will eventually</para>
        /// <para>crash the process. That is a limitation of Xlib.</para>
        /// <para>The specified identifier must correspond to an existing Input/Output class</para>
        /// <para>X11 window. Pixmaps arenotcurrently supported. The default X11</para>
        /// <para>server is assumed, i.e. that specified in the DISPLAY environment variable.</para>
        /// <para>LibVLC can deal with invalid X11 handle errors, however some display drivers</para>
        /// <para>(EGL, GLX, VA and/or VDPAU) can unfortunately not. Thus the window handle</para>
        /// <para>must remain valid until playback is stopped, otherwise the process may</para>
        /// <para>abort or crash.</para>
        /// <para>No more than one window handle per media player instance can be specified.</para>
        /// <para>If the media has multiple simultaneously active video tracks, extra tracks</para>
        /// <para>will be rendered into external windows beyond the control of the</para>
        /// <para>application.</para>
        /// </remarks>
        public static void LibvlcMediaPlayerSetXwindow(global::libvlcsharp.MediaPlayer p_mi, uint drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetXwindow(__arg0, drawable);
        }

        /// <summary>
        /// <para>Get the X Window System window identifier previously set with</para>
        /// <para>libvlc_media_player_set_xwindow(). Note that this will return the identifier</para>
        /// <para>even if VLC is not currently using it (for instance if it is playing an</para>
        /// <para>audio-only input).</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>an X window ID, or 0 if none where set.</returns>
        public static uint LibvlcMediaPlayerGetXwindow(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetXwindow(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set a Win32/Win64 API window handle (HWND) where the media player should</para>
        /// <para>render its video output. If LibVLC was built without Win32/Win64 API output</para>
        /// <para>support, then this has no effects.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="drawable">windows handle of the drawable</param>
        public static void LibvlcMediaPlayerSetHwnd(global::libvlcsharp.MediaPlayer p_mi, global::System.IntPtr drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetHwnd(__arg0, drawable);
        }

        /// <summary>
        /// <para>Get the Windows API window handle (HWND) previously set with</para>
        /// <para>libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC</para>
        /// <para>is not currently outputting any video to it.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>a window handle or NULL if there are none.</returns>
        public static global::System.IntPtr LibvlcMediaPlayerGetHwnd(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetHwnd(__arg0);
            return __ret;
        }

        /// <summary>Set the android context.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_awindow_handler">
        /// <para>org.videolan.libvlc.AWindow jobject owned by the</para>
        /// <para>org.videolan.libvlc.MediaPlayer class from the libvlc-android project.</para>
        /// </param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcMediaPlayerSetAndroidContext(global::libvlcsharp.MediaPlayer p_mi, global::System.IntPtr p_awindow_handler)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetAndroidContext(__arg0, p_awindow_handler);
        }

        /// <summary>Set the EFL Evas Object.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_evas_object">a valid EFL Evas Object (Evas_Object)</param>
        /// <returns>-1 if an error was detected, 0 otherwise.</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerSetEvasObject(global::libvlcsharp.MediaPlayer p_mi, global::System.IntPtr p_evas_object)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetEvasObject(__arg0, p_evas_object);
            return __ret;
        }

        /// <summary>Sets callbacks and private data for decoded audio.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="play">callback to play audio samples (must not be NULL)</param>
        /// <param name="pause">callback to pause playback (or NULL to ignore)</param>
        /// <param name="resume">callback to resume playback (or NULL to ignore)</param>
        /// <param name="flush">callback to flush audio buffers (or NULL to ignore)</param>
        /// <param name="drain">callback to drain audio buffers (or NULL to ignore)</param>
        /// <param name="opaque">private pointer for the audio callbacks (as first parameter)</param>
        /// <remarks>
        /// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        /// <para>to configure the decoded audio format.</para>
        /// <para>The audio callbacks override any other audio output mechanism.</para>
        /// <para>If the callbacks are set, LibVLC willnotoutput audio in any way.</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetCallbacks(global::libvlcsharp.MediaPlayer mp, global::libvlcsharp.LibvlcAudioPlayCb play, global::libvlcsharp.LibvlcAudioPauseCb pause, global::libvlcsharp.LibvlcAudioResumeCb resume, global::libvlcsharp.LibvlcAudioFlushCb flush, global::libvlcsharp.LibvlcAudioDrainCb drain, global::System.IntPtr opaque)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = play == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(play);
            var __arg2 = pause == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pause);
            var __arg3 = resume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(resume);
            var __arg4 = flush == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flush);
            var __arg5 = drain == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(drain);
            __Internal.LibvlcAudioSetCallbacks(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, opaque);
        }

        /// <summary>
        /// <para>Set callbacks and private data for decoded audio. This only works in</para>
        /// <para>combination with libvlc_audio_set_callbacks().</para>
        /// <para>Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()</para>
        /// <para>to configure the decoded audio format.</para>
        /// </summary>
        /// <param name="mp">the media player</param>
        /// <param name="set_volume">
        /// <para>callback to apply audio volume,</para>
        /// <para>or NULL to apply volume in software</para>
        /// </param>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static void LibvlcAudioSetVolumeCallback(global::libvlcsharp.MediaPlayer mp, global::libvlcsharp.LibvlcAudioSetVolumeCb set_volume)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = set_volume == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(set_volume);
            __Internal.LibvlcAudioSetVolumeCallback(__arg0, __arg1);
        }

        /// <summary>Sets decoded audio format via callbacks.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="setup">callback to select the audio format (cannot be NULL)</param>
        /// <param name="cleanup">callback to release any allocated resources (or NULL)</param>
        /// <remarks>
        /// <para>This only works in combination with libvlc_audio_set_callbacks().</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetFormatCallbacks(global::libvlcsharp.MediaPlayer mp, global::libvlcsharp.LibvlcAudioSetupCb setup, global::libvlcsharp.LibvlcAudioCleanupCb cleanup)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __arg1 = setup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(setup);
            var __arg2 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
            __Internal.LibvlcAudioSetFormatCallbacks(__arg0, __arg1, __arg2);
        }

        /// <summary>Sets a fixed decoded audio format.</summary>
        /// <param name="mp">the media player</param>
        /// <param name="format">
        /// <para>a four-characters string identifying the sample format</para>
        /// <para>(e.g. &quot;S16N&quot; or &quot;FL32&quot;)</para>
        /// </param>
        /// <param name="rate">sample rate (expressed in Hz)</param>
        /// <param name="channels">channels count</param>
        /// <remarks>
        /// <para>This only works in combination with libvlc_audio_set_callbacks(),</para>
        /// <para>and is mutually exclusive with libvlc_audio_set_format_callbacks().</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioSetFormat(global::libvlcsharp.MediaPlayer mp, string format, uint rate, uint channels)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcAudioSetFormat(__arg0, format, rate, channels);
        }

        /// <summary>Get the current movie length (in ms).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the movie length (in ms), or -1 if there is no media.</returns>
        public static long LibvlcMediaPlayerGetLength(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetLength(__arg0);
            return __ret;
        }

        /// <summary>Get the current movie time (in ms).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the movie time (in ms), or -1 if there is no media.</returns>
        public static long LibvlcMediaPlayerGetTime(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTime(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the movie time (in ms). This has no effect if no media is being played.</para>
        /// <para>Not all formats and protocols support this.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_time">the movie time (in ms).</param>
        public static void LibvlcMediaPlayerSetTime(global::libvlcsharp.MediaPlayer p_mi, long i_time)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetTime(__arg0, i_time);
        }

        /// <summary>Get movie position as percentage between 0.0 and 1.0.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>movie position, or -1. in case of error</returns>
        public static float LibvlcMediaPlayerGetPosition(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetPosition(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set movie position as percentage between 0.0 and 1.0.</para>
        /// <para>This has no effect if playback is not enabled.</para>
        /// <para>This might not work depending on the underlying input format and protocol.</para>
        /// </summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="f_pos">the position</param>
        public static void LibvlcMediaPlayerSetPosition(global::libvlcsharp.MediaPlayer p_mi, float f_pos)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetPosition(__arg0, f_pos);
        }

        /// <summary>Set movie chapter (if applicable).</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_chapter">chapter number to play</param>
        public static void LibvlcMediaPlayerSetChapter(global::libvlcsharp.MediaPlayer p_mi, int i_chapter)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetChapter(__arg0, i_chapter);
        }

        /// <summary>Get movie chapter.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>chapter number currently playing, or -1 if there is no media.</returns>
        public static int LibvlcMediaPlayerGetChapter(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapter(__arg0);
            return __ret;
        }

        /// <summary>Get movie chapter count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>number of chapters in movie, or -1.</returns>
        public static int LibvlcMediaPlayerGetChapterCount(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapterCount(__arg0);
            return __ret;
        }

        /// <summary>Is the player able to play</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>boolean</returns>
        public static int LibvlcMediaPlayerWillPlay(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerWillPlay(__arg0);
            return __ret;
        }

        /// <summary>Get title chapter count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_title">title</param>
        /// <returns>number of chapters in title, or -1</returns>
        public static int LibvlcMediaPlayerGetChapterCountForTitle(global::libvlcsharp.MediaPlayer p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetChapterCountForTitle(__arg0, i_title);
            return __ret;
        }

        /// <summary>Set movie title</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="i_title">title number to play</param>
        public static void LibvlcMediaPlayerSetTitle(global::libvlcsharp.MediaPlayer p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetTitle(__arg0, i_title);
        }

        /// <summary>Get movie title</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>title number currently playing, or -1</returns>
        public static int LibvlcMediaPlayerGetTitle(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTitle(__arg0);
            return __ret;
        }

        /// <summary>Get movie title count</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>title number count, or -1</returns>
        public static int LibvlcMediaPlayerGetTitleCount(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetTitleCount(__arg0);
            return __ret;
        }

        /// <summary>Set previous chapter (if applicable)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerPreviousChapter(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerPreviousChapter(__arg0);
        }

        /// <summary>Set next chapter (if applicable)</summary>
        /// <param name="p_mi">the Media Player</param>
        public static void LibvlcMediaPlayerNextChapter(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNextChapter(__arg0);
        }

        /// <summary>Get the requested movie play rate.</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>movie play rate</returns>
        /// <remarks>
        /// <para>Depending on the underlying media, the requested rate may be</para>
        /// <para>different from the real playback rate.</para>
        /// </remarks>
        public static float LibvlcMediaPlayerGetRate(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetRate(__arg0);
            return __ret;
        }

        /// <summary>Set movie play rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="rate">movie play rate to set</param>
        /// <returns>
        /// <para>-1 if an error was detected, 0 otherwise (but even then, it might</para>
        /// <para>not actually work depending on the underlying media protocol)</para>
        /// </returns>
        public static int LibvlcMediaPlayerSetRate(global::libvlcsharp.MediaPlayer p_mi, float rate)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetRate(__arg0, rate);
            return __ret;
        }

        /// <summary>Get current movie state</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>the current state of the media player (playing, paused, ...)</returns>
        /// <remarks>libvlc_state_t</remarks>
        public static global::libvlcsharp.VLCState LibvlcMediaPlayerGetState(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetState(__arg0);
            return __ret;
        }

        /// <summary>How many video outputs does this media player have?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the number of video outputs</returns>
        public static uint LibvlcMediaPlayerHasVout(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerHasVout(__arg0);
            return __ret;
        }

        /// <summary>Is this media player seekable?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the media player can seek</returns>
        public static int LibvlcMediaPlayerIsSeekable(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerIsSeekable(__arg0);
            return __ret;
        }

        /// <summary>Can this media player be paused?</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the media player can pause</returns>
        public static int LibvlcMediaPlayerCanPause(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerCanPause(__arg0);
            return __ret;
        }

        /// <summary>Check if the current program is scrambled</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>true if the current program is scrambled</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static int LibvlcMediaPlayerProgramScrambled(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerProgramScrambled(__arg0);
            return __ret;
        }

        /// <summary>Display the next frame (if supported)</summary>
        /// <param name="p_mi">the media player</param>
        public static void LibvlcMediaPlayerNextFrame(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNextFrame(__arg0);
        }

        /// <summary>Navigate through DVD Menu</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <param name="navigate">the Navigation mode</param>
        /// <remarks>libVLC 2.0.0 or later</remarks>
        public static void LibvlcMediaPlayerNavigate(global::libvlcsharp.MediaPlayer p_mi, uint navigate)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerNavigate(__arg0, navigate);
        }

        /// <summary>Set if, and how, the video title will be shown when media is played.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="position">position at which to display the title, or libvlc_position_disable to prevent the title from being displayed</param>
        /// <param name="timeout">title display timeout in milliseconds (ignored if libvlc_position_disable)</param>
        /// <remarks>libVLC 2.1.0 or later</remarks>
        public static void LibvlcMediaPlayerSetVideoTitleDisplay(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.Position position, uint timeout)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetVideoTitleDisplay(__arg0, position, timeout);
        }

        /// <summary>Add a slave to the current media player.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_type">subtitle or audio</param>
        /// <param name="psz_uri">Uri of the slave (should contain a valid scheme).</param>
        /// <param name="b_select">True if this slave should be selected when it's loaded</param>
        /// <returns>0 on success, -1 on error.</returns>
        /// <remarks>
        /// <para>If the player is playing, the slave will be added directly. This call</para>
        /// <para>will also update the slave list of the attached libvlc_media_t.</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_slaves_add</para>
        /// </remarks>
        public static int LibvlcMediaPlayerAddSlave(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.MediaSlaveType i_type, string psz_uri, bool b_select)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerAddSlave(__arg0, i_type, psz_uri, b_select);
            return __ret;
        }

        /// <summary>Release (free) libvlc_track_description_t</summary>
        /// <param name="p_track_description">the structure to release</param>
        public static void LibvlcTrackDescriptionListRelease(global::libvlcsharp.TrackDescription p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionListRelease(__arg0);
        }

        /// <summary>Toggle fullscreen status on non-embedded video outputs.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>
        /// <para>The same limitations applies to this function</para>
        /// <para>as to libvlc_set_fullscreen().</para>
        /// </remarks>
        public static void LibvlcToggleFullscreen(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcToggleFullscreen(__arg0);
        }

        /// <summary>Enable or disable fullscreen.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="b_fullscreen">boolean for fullscreen status</param>
        /// <remarks>
        /// <para>With most window managers, only a top-level windows can be in</para>
        /// <para>full-screen mode. Hence, this function will not operate properly if</para>
        /// <para>libvlc_media_player_set_xwindow() was used to embed the video in a</para>
        /// <para>non-top-level window. In that case, the embedding window must be reparented</para>
        /// <para>to the root windowbeforefullscreen mode is enabled. You will want</para>
        /// <para>to reparent it back to its normal parent when disabling fullscreen.</para>
        /// </remarks>
        public static void LibvlcSetFullscreen(global::libvlcsharp.MediaPlayer p_mi, int b_fullscreen)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcSetFullscreen(__arg0, b_fullscreen);
        }

        /// <summary>Get current fullscreen status.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the fullscreen status (boolean)</returns>
        public static int LibvlcGetFullscreen(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcGetFullscreen(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Enable or disable key press events handling, according to the LibVLC hotkeys</para>
        /// <para>configuration. By default and for historical reasons, keyboard events are</para>
        /// <para>handled by the LibVLC video widget.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="on">true to handle key press events, false to ignore them.</param>
        /// <remarks>
        /// <para>On X11, there can be only one subscriber for key press and mouse</para>
        /// <para>click events per window. If your application has subscribed to those events</para>
        /// <para>for the X window ID of the video widget, then LibVLC will not be able to</para>
        /// <para>handle key presses and mouse clicks in any case.</para>
        /// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        /// </remarks>
        public static void LibvlcVideoSetKeyInput(global::libvlcsharp.MediaPlayer p_mi, uint on)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetKeyInput(__arg0, on);
        }

        /// <summary>
        /// <para>Enable or disable mouse click events handling. By default, those events are</para>
        /// <para>handled. This is needed for DVD menus to work, as well as a few video</para>
        /// <para>filters such as &quot;puzzle&quot;.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="on">true to handle mouse click events, false to ignore them.</param>
        /// <remarks>
        /// <para>libvlc_video_set_key_input().</para>
        /// <para>This function is only implemented for X11 and Win32 at the moment.</para>
        /// </remarks>
        public static void LibvlcVideoSetMouseInput(global::libvlcsharp.MediaPlayer p_mi, uint on)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMouseInput(__arg0, on);
        }

        /// <summary>Get the pixel dimensions of a video.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="num">number of the video (starting from, and most commonly 0)</param>
        /// <param name="px">pointer to get the pixel width [OUT]</param>
        /// <param name="py">pointer to get the pixel height [OUT]</param>
        /// <returns>0 on success, -1 if the specified video does not exist</returns>
        public static int LibvlcVideoGetSize(global::libvlcsharp.MediaPlayer p_mi, uint num, ref uint px, ref uint py)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            fixed (uint* __refParamPtr2 = &px)
            {
                var __arg2 = __refParamPtr2;
                fixed (uint* __refParamPtr3 = &py)
                {
                    var __arg3 = __refParamPtr3;
                    var __ret = __Internal.LibvlcVideoGetSize(__arg0, num, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the mouse pointer coordinates over a video.</para>
        /// <para>Coordinates are expressed in terms of the decoded video resolution,</para>
        /// <para>notin terms of pixels on the screen/viewport (to get the latter,</para>
        /// <para>you can query your windowing system directly).</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="num">number of the video (starting from, and most commonly 0)</param>
        /// <param name="px">pointer to get the abscissa [OUT]</param>
        /// <param name="py">pointer to get the ordinate [OUT]</param>
        /// <returns>0 on success, -1 if the specified video does not exist</returns>
        /// <remarks>
        /// <para>Either of the coordinates may be negative or larger than the corresponding</para>
        /// <para>dimension of the video, if the cursor is outside the rendering area.</para>
        /// <para>The coordinates may be out-of-date if the pointer is not located</para>
        /// <para>on the video rendering area. LibVLC does not track the pointer if it is</para>
        /// <para>outside of the video widget.</para>
        /// <para>LibVLC does not support multiple pointers (it does of course support</para>
        /// <para>multiple input devices sharing the same pointer) at the moment.</para>
        /// </remarks>
        public static int LibvlcVideoGetCursor(global::libvlcsharp.MediaPlayer p_mi, uint num, ref int px, ref int py)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            fixed (int* __refParamPtr2 = &px)
            {
                var __arg2 = __refParamPtr2;
                fixed (int* __refParamPtr3 = &py)
                {
                    var __arg3 = __refParamPtr3;
                    var __ret = __Internal.LibvlcVideoGetCursor(__arg0, num, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the current video scaling factor.</para>
        /// <para>See also libvlc_video_set_scale().</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>the currently configured zoom factor, or 0. if the video is set</para>
        /// <para>to fit to the output window/drawable automatically.</para>
        /// </returns>
        public static float LibvlcVideoGetScale(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetScale(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the video scaling factor. That is the ratio of the number of pixels on</para>
        /// <para>screen to the number of pixels in the original decoded video in each</para>
        /// <para>dimension. Zero is a special value; it will adjust the video to the output</para>
        /// <para>window/drawable (in windowed mode) or the entire screen.</para>
        /// </summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="f_factor">the scaling factor, or zero</param>
        /// <remarks>Note that not all video outputs support scaling.</remarks>
        public static void LibvlcVideoSetScale(global::libvlcsharp.MediaPlayer p_mi, float f_factor)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetScale(__arg0, f_factor);
        }

        /// <summary>Get current video aspect ratio.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>the video aspect ratio or NULL if unspecified</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        public static sbyte* LibvlcVideoGetAspectRatio(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAspectRatio(__arg0);
            return __ret;
        }

        /// <summary>Set new video aspect ratio.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_aspect">new video aspect-ratio or NULL to reset to default</param>
        /// <remarks>Invalid aspect ratios are ignored.</remarks>
        public static void LibvlcVideoSetAspectRatio(global::libvlcsharp.MediaPlayer p_mi, string psz_aspect)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAspectRatio(__arg0, psz_aspect);
        }

        /// <summary>Create a video viewpoint structure.</summary>
        /// <returns>
        /// <para>video viewpoint or NULL</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static global::libvlcsharp.VideoViewpoint LibvlcVideoNewViewpoint()
        {
            var __ret = __Internal.LibvlcVideoNewViewpoint();
            global::libvlcsharp.VideoViewpoint __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.VideoViewpoint.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.VideoViewpoint) global::libvlcsharp.VideoViewpoint.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.VideoViewpoint.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Update the video viewpoint information.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="p_viewpoint">video viewpoint allocated via libvlc_video_new_viewpoint()</param>
        /// <param name="b_absolute">
        /// <para>if true replace the old viewpoint with the new one. If</para>
        /// <para>false, increase/decrease it.</para>
        /// </param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>It is safe to call this function before the media player is started.</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// <para>the values are set asynchronously, it will be used by the next frame displayed.</para>
        /// </remarks>
        public static int LibvlcVideoUpdateViewpoint(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.VideoViewpoint p_viewpoint, bool b_absolute)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_viewpoint, null) ? global::System.IntPtr.Zero : p_viewpoint.__Instance;
            var __ret = __Internal.LibvlcVideoUpdateViewpoint(__arg0, __arg1, b_absolute);
            return __ret;
        }

        /// <summary>Get current video subtitle.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video subtitle selected, or -1 if none</returns>
        public static int LibvlcVideoGetSpu(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpu(__arg0);
            return __ret;
        }

        /// <summary>Get the number of available video subtitles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the number of available video subtitles</returns>
        public static int LibvlcVideoGetSpuCount(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available video subtitles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available video subtitles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlcsharp.TrackDescription LibvlcVideoGetSpuDescription(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuDescription(__arg0);
            global::libvlcsharp.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set new video subtitle.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_spu">video subtitle track to select (i_id from track description)</param>
        /// <returns>0 on success, -1 if out of range</returns>
        public static int LibvlcVideoSetSpu(global::libvlcsharp.MediaPlayer p_mi, int i_spu)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSpu(__arg0, i_spu);
            return __ret;
        }

        /// <summary>
        /// <para>Get the current subtitle delay. Positive values means subtitles are being</para>
        /// <para>displayed later, negative values earlier.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <returns>time (in microseconds) the display of subtitles is being delayed</returns>
        /// <remarks>LibVLC 2.0.0 or later</remarks>
        public static long LibvlcVideoGetSpuDelay(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetSpuDelay(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the subtitle delay. This affects the timing of when the subtitle will</para>
        /// <para>be displayed. Positive values result in subtitles being displayed later,</para>
        /// <para>while negative values will result in subtitles being displayed earlier.</para>
        /// </summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_delay">time (in microseconds) the display of subtitles should be delayed</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>
        /// <para>The subtitle delay will be reset to zero each time the media changes.</para>
        /// <para>LibVLC 2.0.0 or later</para>
        /// </remarks>
        public static int LibvlcVideoSetSpuDelay(global::libvlcsharp.MediaPlayer p_mi, long i_delay)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSpuDelay(__arg0, i_delay);
            return __ret;
        }

        /// <summary>Get the full description of available titles</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="titles">
        /// <para>address to store an allocated array of title descriptions</para>
        /// <para>descriptions (must be freed with libvlc_title_descriptions_release()</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of titles (-1 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetFullTitleDescriptions(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.TitleDescription titles)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(titles, null) ? global::System.IntPtr.Zero : titles.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFullTitleDescriptions(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release a title description</summary>
        /// <param name="p_titles">title description array to release</param>
        /// <param name="i_count">number of title descriptions to release</param>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static void LibvlcTitleDescriptionsRelease(global::libvlcsharp.TitleDescription p_titles, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_titles, null) ? global::System.IntPtr.Zero : p_titles.__Instance;
            __Internal.LibvlcTitleDescriptionsRelease(__arg0, i_count);
        }

        /// <summary>Get the full description of available chapters</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_chapters_of_title">index of the title to query for chapters (uses current title if set to -1)</param>
        /// <param name="pp_chapters">
        /// <para>address to store an allocated array of chapter descriptions</para>
        /// <para>descriptions (must be freed with libvlc_chapter_descriptions_release()</para>
        /// <para>by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of chapters (-1 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetFullChapterDescriptions(global::libvlcsharp.MediaPlayer p_mi, int i_chapters_of_title, global::libvlcsharp.ChapterDescription pp_chapters)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg2 = ReferenceEquals(pp_chapters, null) ? global::System.IntPtr.Zero : pp_chapters.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFullChapterDescriptions(__arg0, i_chapters_of_title, __arg2);
            return __ret;
        }

        /// <summary>Release a chapter description</summary>
        /// <param name="p_chapters">chapter description array to release</param>
        /// <param name="i_count">number of chapter descriptions to release</param>
        /// <remarks>LibVLC 3.0.0 and later</remarks>
        public static void LibvlcChapterDescriptionsRelease(global::libvlcsharp.ChapterDescription p_chapters, uint i_count)
        {
            var __arg0 = ReferenceEquals(p_chapters, null) ? global::System.IntPtr.Zero : p_chapters.__Instance;
            __Internal.LibvlcChapterDescriptionsRelease(__arg0, i_count);
        }

        /// <summary>Get current crop filter geometry.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the crop filter geometry or NULL if unset</returns>
        public static sbyte* LibvlcVideoGetCropGeometry(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetCropGeometry(__arg0);
            return __ret;
        }

        /// <summary>Set new crop filter geometry.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_geometry">new crop filter geometry (NULL to unset)</param>
        public static void LibvlcVideoSetCropGeometry(global::libvlcsharp.MediaPlayer p_mi, string psz_geometry)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetCropGeometry(__arg0, psz_geometry);
        }

        /// <summary>Get current teletext page requested or 0 if it's disabled.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the current teletext page requested.</returns>
        /// <remarks>
        /// <para>Teletext is disabled by default, call libvlc_video_set_teletext() to enable</para>
        /// <para>it.</para>
        /// </remarks>
        public static int LibvlcVideoGetTeletext(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTeletext(__arg0);
            return __ret;
        }

        /// <summary>Set new teletext page to retrieve.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_page">
        /// <para>teletex page number requested. This value can be 0 to disable</para>
        /// <para>teletext, a number in the range ]0;1000[ to show the requested page, or a</para>
        /// </param>
        /// <remarks>This function can also be used to send a teletext key.</remarks>
        public static void LibvlcVideoSetTeletext(global::libvlcsharp.MediaPlayer p_mi, int i_page)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetTeletext(__arg0, i_page);
        }

        /// <summary>Get number of available video tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the number of available video tracks (int)</returns>
        public static int LibvlcVideoGetTrackCount(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrackCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available video tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>list with description of available video tracks, or NULL on error.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlcsharp.TrackDescription LibvlcVideoGetTrackDescription(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrackDescription(__arg0);
            global::libvlcsharp.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get current video track.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the video track ID (int) or -1 if no active input</returns>
        public static int LibvlcVideoGetTrack(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTrack(__arg0);
            return __ret;
        }

        /// <summary>Set video track.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_track">the track ID (i_id field from track description)</param>
        /// <returns>0 on success, -1 if out of range</returns>
        public static int LibvlcVideoSetTrack(global::libvlcsharp.MediaPlayer p_mi, int i_track)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetTrack(__arg0, i_track);
            return __ret;
        }

        /// <summary>Take a snapshot of the current video window.</summary>
        /// <param name="p_mi">media player instance</param>
        /// <param name="num">number of video output (typically 0 for the first/only one)</param>
        /// <param name="psz_filepath">the path where to save the screenshot to</param>
        /// <param name="i_width">the snapshot's width</param>
        /// <param name="i_height">the snapshot's height</param>
        /// <returns>0 on success, -1 if the video was not found</returns>
        /// <remarks>
        /// <para>If i_width AND i_height is 0, original size is used.</para>
        /// <para>If i_width XOR i_height is 0, original aspect-ratio is preserved.</para>
        /// </remarks>
        public static int LibvlcVideoTakeSnapshot(global::libvlcsharp.MediaPlayer p_mi, uint num, string psz_filepath, uint i_width, uint i_height)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoTakeSnapshot(__arg0, num, psz_filepath, i_width, i_height);
            return __ret;
        }

        /// <summary>Enable or disable deinterlace filter</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="psz_mode">type of deinterlace filter, NULL to disable</param>
        public static void LibvlcVideoSetDeinterlace(global::libvlcsharp.MediaPlayer p_mi, string psz_mode)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetDeinterlace(__arg0, psz_mode);
        }

        /// <summary>Get an integer marquee option value</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to get</param>
        /// <remarks>libvlc_video_marquee_int_option_t</remarks>
        public static int LibvlcVideoGetMarqueeInt(global::libvlcsharp.MediaPlayer p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetMarqueeInt(__arg0, option);
            return __ret;
        }

        /// <summary>Get a string marquee option value</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to get</param>
        /// <remarks>libvlc_video_marquee_string_option_t</remarks>
        public static sbyte* LibvlcVideoGetMarqueeString(global::libvlcsharp.MediaPlayer p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetMarqueeString(__arg0, option);
            return __ret;
        }

        /// <summary>Enable, disable or set an integer marquee option</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to set</param>
        /// <param name="i_val">marq option value</param>
        /// <remarks>
        /// <para>Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)</para>
        /// <para>or disabling (arg 0) the marq filter.</para>
        /// <para>libvlc_video_marquee_int_option_t</para>
        /// </remarks>
        public static void LibvlcVideoSetMarqueeInt(global::libvlcsharp.MediaPlayer p_mi, uint option, int i_val)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMarqueeInt(__arg0, option, i_val);
        }

        /// <summary>Set a marquee string option</summary>
        /// <param name="p_mi">libvlc media player</param>
        /// <param name="option">marq option to set</param>
        /// <param name="psz_text">marq option value</param>
        /// <remarks>libvlc_video_marquee_string_option_t</remarks>
        public static void LibvlcVideoSetMarqueeString(global::libvlcsharp.MediaPlayer p_mi, uint option, string psz_text)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetMarqueeString(__arg0, option, psz_text);
        }

        /// <summary>Get integer logo option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to get, values of libvlc_video_logo_option_t</param>
        public static int LibvlcVideoGetLogoInt(global::libvlcsharp.MediaPlayer p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetLogoInt(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set logo option as integer. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// <para>Passing libvlc_logo_enable as option value has the side effect of</para>
        /// <para>starting (arg !0) or stopping (arg 0) the logo filter.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        /// <param name="value">logo option value</param>
        public static void LibvlcVideoSetLogoInt(global::libvlcsharp.MediaPlayer p_mi, uint option, int value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetLogoInt(__arg0, option, value);
        }

        /// <summary>
        /// <para>Set logo option as string. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">logo option to set, values of libvlc_video_logo_option_t</param>
        /// <param name="psz_value">logo option value</param>
        public static void LibvlcVideoSetLogoString(global::libvlcsharp.MediaPlayer p_mi, uint option, string psz_value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetLogoString(__arg0, option, psz_value);
        }

        /// <summary>Get integer adjust option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static int LibvlcVideoGetAdjustInt(global::libvlcsharp.MediaPlayer p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAdjustInt(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set adjust option as integer. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// <para>Passing libvlc_adjust_enable as option value has the side effect of</para>
        /// <para>starting (arg !0) or stopping (arg 0) the adjust filter.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        /// <param name="value">adjust option value</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static void LibvlcVideoSetAdjustInt(global::libvlcsharp.MediaPlayer p_mi, uint option, int value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAdjustInt(__arg0, option, value);
        }

        /// <summary>Get float adjust option.</summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adjust option to get, values of libvlc_video_adjust_option_t</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static float LibvlcVideoGetAdjustFloat(global::libvlcsharp.MediaPlayer p_mi, uint option)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetAdjustFloat(__arg0, option);
            return __ret;
        }

        /// <summary>
        /// <para>Set adjust option as float. Options that take a different type value</para>
        /// <para>are ignored.</para>
        /// </summary>
        /// <param name="p_mi">libvlc media player instance</param>
        /// <param name="option">adust option to set, values of libvlc_video_adjust_option_t</param>
        /// <param name="value">adjust option value</param>
        /// <remarks>LibVLC 1.1.1 and later.</remarks>
        public static void LibvlcVideoSetAdjustFloat(global::libvlcsharp.MediaPlayer p_mi, uint option, float value)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcVideoSetAdjustFloat(__arg0, option, value);
        }

        /// <summary>Gets the list of available audio output modules.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>list of available audio outputs. It must be freed with</returns>
        /// <remarks>
        /// <para>libvlc_audio_output_list_release</para>
        /// <para>libvlc_audio_output_t .</para>
        /// <para>In case of error, NULL is returned.</para>
        /// </remarks>
        public static global::libvlcsharp.AudioOutput LibvlcAudioOutputListGet(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputListGet(__arg0);
            global::libvlcsharp.AudioOutput __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.AudioOutput.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.AudioOutput) global::libvlcsharp.AudioOutput.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.AudioOutput.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees the list of available audio output modules.</summary>
        /// <param name="p_list">list with audio outputs for release</param>
        public static void LibvlcAudioOutputListRelease(global::libvlcsharp.AudioOutput p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcAudioOutputListRelease(__arg0);
        }

        /// <summary>Selects an audio output module.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="psz_name">
        /// <para>name of audio output,</para>
        /// <para>use psz_name of</para>
        /// </param>
        /// <returns>0 if function succeeded, -1 on error</returns>
        /// <remarks>
        /// <para>Any change will take be effect only after playback is stopped and</para>
        /// <para>restarted. Audio output cannot be changed while playing.</para>
        /// <para>libvlc_audio_output_t</para>
        /// </remarks>
        public static int LibvlcAudioOutputSet(global::libvlcsharp.MediaPlayer p_mi, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioOutputSet(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Gets a list of potential audio output devices,</summary>
        /// <param name="mp">media player</param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support enumerating devices.</para>
        /// <para>The audio output may be functional even if the list is empty (NULL).</para>
        /// <para>The list may not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.2.0 or later.</para>
        /// </remarks>
        public static global::libvlcsharp.AudioOutputDevice LibvlcAudioOutputDeviceEnum(global::libvlcsharp.MediaPlayer mp)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceEnum(__arg0);
            global::libvlcsharp.AudioOutputDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.AudioOutputDevice.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.AudioOutputDevice) global::libvlcsharp.AudioOutputDevice.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.AudioOutputDevice.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets a list of audio output devices for a given audio output module,</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <param name="aout">
        /// <para>audio output name</para>
        /// <para>(as returned by libvlc_audio_output_list_get())</para>
        /// </param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support this. In particular, an empty (NULL)</para>
        /// <para>list of devices doesnotimply that the specified audio output does</para>
        /// <para>not work.</para>
        /// <para>The list might not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.1.0 or later.</para>
        /// </remarks>
        public static global::libvlcsharp.AudioOutputDevice LibvlcAudioOutputDeviceListGet(global::libvlcsharp.Instance p_instance, string aout)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceListGet(__arg0, aout);
            global::libvlcsharp.AudioOutputDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.AudioOutputDevice.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.AudioOutputDevice) global::libvlcsharp.AudioOutputDevice.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.AudioOutputDevice.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees a list of available audio output devices.</summary>
        /// <param name="p_list">list with audio outputs for release</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public static void LibvlcAudioOutputDeviceListRelease(global::libvlcsharp.AudioOutputDevice p_list)
        {
            var __arg0 = ReferenceEquals(p_list, null) ? global::System.IntPtr.Zero : p_list.__Instance;
            __Internal.LibvlcAudioOutputDeviceListRelease(__arg0);
        }

        /// <summary>Configures an explicit audio output device.</summary>
        /// <param name="mp">media player</param>
        /// <param name="module">
        /// <para>If NULL, current audio output module.</para>
        /// <para>if non-NULL, name of audio output module</para>
        /// <para>(</para>
        /// </param>
        /// <param name="device_id">device identifier string</param>
        /// <returns>Nothing. Errors are ignored (this is a design bug).</returns>
        /// <remarks>
        /// <para>If the module paramater is NULL, audio output will be moved to the device</para>
        /// <para>specified by the device identifier string immediately. This is the</para>
        /// <para>recommended usage.</para>
        /// <para>A list of adequate potential device strings can be obtained with</para>
        /// <para>libvlc_audio_output_device_enum().</para>
        /// <para>However passing NULL is supported in LibVLC version 2.2.0 and later only;</para>
        /// <para>in earlier versions, this function would have no effects when the module</para>
        /// <para>parameter was NULL.</para>
        /// <para>If the module parameter is not NULL, the device parameter of the</para>
        /// <para>corresponding audio output, if it exists, will be set to the specified</para>
        /// <para>string. Note that some audio output modules do not have such a parameter</para>
        /// <para>(notably MMDevice and PulseAudio).</para>
        /// <para>A list of adequate potential device strings can be obtained with</para>
        /// <para>libvlc_audio_output_device_list_get().</para>
        /// <para>This function does not select the specified audio output plugin.</para>
        /// <para>libvlc_audio_output_set() is used for that purpose.</para>
        /// <para>The syntax for the device parameter depends on the audio output.</para>
        /// <para>Some audio output modules require further parameters (e.g. a channels map</para>
        /// <para>in the case of ALSA).</para>
        /// <para>libvlc_audio_output_t)</para>
        /// </remarks>
        public static void LibvlcAudioOutputDeviceSet(global::libvlcsharp.MediaPlayer mp, string module, string device_id)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            __Internal.LibvlcAudioOutputDeviceSet(__arg0, module, device_id);
        }

        /// <summary>Get the current audio output device identifier.</summary>
        /// <param name="mp">media player</param>
        /// <returns>
        /// <para>the current audio output device identifier</para>
        /// <para>NULL if no device is selected or in case of error</para>
        /// <para>(the result must be released with free() or libvlc_free()).</para>
        /// </returns>
        /// <remarks>
        /// <para>This complements libvlc_audio_output_device_set().</para>
        /// <para>The initial value for the current audio output device identifier</para>
        /// <para>may not be set or may be some unknown value. A LibVLC application should</para>
        /// <para>compare this value against the known device identifiers (e.g. those that</para>
        /// <para>were previously retrieved by a call to libvlc_audio_output_device_enum or</para>
        /// <para>libvlc_audio_output_device_list_get) to find the current audio output device.</para>
        /// <para>It is possible that the selected audio output device changes (an external</para>
        /// <para>change) without a call to libvlc_audio_output_device_set. That may make this</para>
        /// <para>method unsuitable to use if a LibVLC application is attempting to track</para>
        /// <para>dynamic audio device changes as they happen.</para>
        /// <para>LibVLC 3.0.0 or later.</para>
        /// </remarks>
        public static sbyte* LibvlcAudioOutputDeviceGet(global::libvlcsharp.MediaPlayer mp)
        {
            var __arg0 = ReferenceEquals(mp, null) ? global::System.IntPtr.Zero : mp.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceGet(__arg0);
            return __ret;
        }

        /// <summary>Toggle mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <remarks>
        /// <para>Toggling mute atomically is not always possible: On some platforms,</para>
        /// <para>other processes can mute the VLC audio playback stream asynchronously. Thus,</para>
        /// <para>there is a small race condition where toggling will not work.</para>
        /// <para>See also the limitations of libvlc_audio_set_mute().</para>
        /// </remarks>
        public static void LibvlcAudioToggleMute(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcAudioToggleMute(__arg0);
        }

        /// <summary>Get current mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the mute status (boolean) if defined, -1 if undefined/unapplicable</returns>
        public static int LibvlcAudioGetMute(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetMute(__arg0);
            return __ret;
        }

        /// <summary>Set mute status.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="status">If status is true then mute, otherwise unmute</param>
        /// <remarks>
        /// <para>This function does not always work. If there are no active audio</para>
        /// <para>playback stream, the mute status might not be available. If digital</para>
        /// <para>pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also</para>
        /// <para>some audio output plugins do not support muting at all.</para>
        /// <para>To force silent playback, disable all audio tracks. This is more</para>
        /// <para>efficient and reliable than mute.</para>
        /// </remarks>
        public static void LibvlcAudioSetMute(global::libvlcsharp.MediaPlayer p_mi, int status)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcAudioSetMute(__arg0, status);
        }

        /// <summary>Get current software audio volume.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>the software volume in percents</para>
        /// <para>(0 = mute, 100 = nominal / 0dB)</para>
        /// </returns>
        public static int LibvlcAudioGetVolume(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetVolume(__arg0);
            return __ret;
        }

        /// <summary>Set current software audio volume.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_volume">the volume in percents (0 = mute, 100 = 0dB)</param>
        /// <returns>0 if the volume was set, -1 if it was out of range</returns>
        public static int LibvlcAudioSetVolume(global::libvlcsharp.MediaPlayer p_mi, int i_volume)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetVolume(__arg0, i_volume);
            return __ret;
        }

        /// <summary>Get number of available audio tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the number of available audio tracks (int), or -1 if unavailable</returns>
        public static int LibvlcAudioGetTrackCount(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrackCount(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available audio tracks.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>
        /// <para>list with description of available audio tracks, or NULL.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlcsharp.TrackDescription LibvlcAudioGetTrackDescription(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrackDescription(__arg0);
            global::libvlcsharp.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get current audio track.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio track ID or -1 if no active input.</returns>
        public static int LibvlcAudioGetTrack(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetTrack(__arg0);
            return __ret;
        }

        /// <summary>Set current audio track.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_track">the track ID (i_id field from track description)</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcAudioSetTrack(global::libvlcsharp.MediaPlayer p_mi, int i_track)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetTrack(__arg0, i_track);
            return __ret;
        }

        /// <summary>Get current audio channel.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio channel</returns>
        /// <remarks>libvlc_audio_output_channel_t</remarks>
        public static int LibvlcAudioGetChannel(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetChannel(__arg0);
            return __ret;
        }

        /// <summary>Set current audio channel.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="channel">the audio channel,</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>libvlc_audio_output_channel_t</remarks>
        public static int LibvlcAudioSetChannel(global::libvlcsharp.MediaPlayer p_mi, int channel)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetChannel(__arg0, channel);
            return __ret;
        }

        /// <summary>Get current audio delay.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the audio delay (microseconds)</returns>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static long LibvlcAudioGetDelay(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioGetDelay(__arg0);
            return __ret;
        }

        /// <summary>Set current audio delay. The audio delay will be reset to zero each time the media changes.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="i_delay">the audio delay (microseconds)</param>
        /// <returns>0 on success, -1 on error</returns>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public static int LibvlcAudioSetDelay(global::libvlcsharp.MediaPlayer p_mi, long i_delay)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioSetDelay(__arg0, i_delay);
            return __ret;
        }

        /// <summary>Get the number of equalizer presets.</summary>
        /// <returns>number of presets</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static uint LibvlcAudioEqualizerGetPresetCount()
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetPresetCount();
            return __ret;
        }

        /// <summary>Get the name of a particular equalizer preset.</summary>
        /// <param name="u_index">index of the preset, counting from zero</param>
        /// <returns>preset name, or NULL if there is no such preset</returns>
        /// <remarks>
        /// <para>This name can be used, for example, to prepare a preset label or menu in a user</para>
        /// <para>interface.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static string LibvlcAudioEqualizerGetPresetName(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetPresetName(u_index);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the number of distinct frequency bands for an equalizer.</summary>
        /// <returns>number of frequency bands</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static uint LibvlcAudioEqualizerGetBandCount()
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetBandCount();
            return __ret;
        }

        /// <summary>Get a particular equalizer band frequency.</summary>
        /// <param name="u_index">index of the band, counting from zero</param>
        /// <returns>equalizer band frequency (Hz), or -1 if there is no such band</returns>
        /// <remarks>
        /// <para>This value can be used, for example, to create a label for an equalizer band control</para>
        /// <para>in a user interface.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static float LibvlcAudioEqualizerGetBandFrequency(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerGetBandFrequency(u_index);
            return __ret;
        }

        /// <summary>Create a new default equalizer, with all frequency values zeroed.</summary>
        /// <returns>opaque equalizer handle, or NULL on error</returns>
        /// <remarks>
        /// <para>The new equalizer can subsequently be applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The returned handle should be freed via libvlc_audio_equalizer_release() when</para>
        /// <para>it is no longer needed.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.Equalizer LibvlcAudioEqualizerNew()
        {
            var __ret = __Internal.LibvlcAudioEqualizerNew();
            global::libvlcsharp.Equalizer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Equalizer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Equalizer) global::libvlcsharp.Equalizer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Equalizer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a new equalizer, with initial frequency values copied from an existing</para>
        /// <para>preset.</para>
        /// </summary>
        /// <param name="u_index">index of the preset, counting from zero</param>
        /// <returns>opaque equalizer handle, or NULL on error</returns>
        /// <remarks>
        /// <para>The new equalizer can subsequently be applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The returned handle should be freed via libvlc_audio_equalizer_release() when</para>
        /// <para>it is no longer needed.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.Equalizer LibvlcAudioEqualizerNewFromPreset(uint u_index)
        {
            var __ret = __Internal.LibvlcAudioEqualizerNewFromPreset(u_index);
            global::libvlcsharp.Equalizer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Equalizer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Equalizer) global::libvlcsharp.Equalizer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Equalizer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release a previously created equalizer instance.</summary>
        /// <param name="p_equalizer">opaque equalizer handle, or NULL</param>
        /// <remarks>
        /// <para>The equalizer was previously created by using libvlc_audio_equalizer_new() or</para>
        /// <para>libvlc_audio_equalizer_new_from_preset().</para>
        /// <para>It is safe to invoke this method with a NULL p_equalizer parameter for no effect.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static void LibvlcAudioEqualizerRelease(global::libvlcsharp.Equalizer p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            __Internal.LibvlcAudioEqualizerRelease(__arg0);
        }

        /// <summary>Set a new pre-amplification value for an equalizer.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="f_preamp">preamp value (-20.0 to 20.0 Hz)</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The new equalizer settings are subsequently applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The supplied amplification value will be clamped to the -20.0 to +20.0 range.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcAudioEqualizerSetPreamp(global::libvlcsharp.Equalizer p_equalizer, float f_preamp)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerSetPreamp(__arg0, f_preamp);
            return __ret;
        }

        /// <summary>Get the current pre-amplification value from an equalizer.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <returns>preamp value (Hz)</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static float LibvlcAudioEqualizerGetPreamp(global::libvlcsharp.Equalizer p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerGetPreamp(__arg0);
            return __ret;
        }

        /// <summary>Set a new amplification value for a particular equalizer frequency band.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="f_amp">amplification value (-20.0 to 20.0 Hz)</param>
        /// <param name="u_band">index, counting from zero, of the frequency band to set</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The new equalizer settings are subsequently applied to a media player by invoking</para>
        /// <para>libvlc_media_player_set_equalizer().</para>
        /// <para>The supplied amplification value will be clamped to the -20.0 to +20.0 range.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcAudioEqualizerSetAmpAtIndex(global::libvlcsharp.Equalizer p_equalizer, float f_amp, uint u_band)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerSetAmpAtIndex(__arg0, f_amp, u_band);
            return __ret;
        }

        /// <summary>Get the amplification value for a particular equalizer frequency band.</summary>
        /// <param name="p_equalizer">valid equalizer handle, must not be NULL</param>
        /// <param name="u_band">index, counting from zero, of the frequency band to get</param>
        /// <returns>amplification value (Hz); NaN if there is no such frequency band</returns>
        /// <remarks>LibVLC 2.2.0 or later</remarks>
        public static float LibvlcAudioEqualizerGetAmpAtIndex(global::libvlcsharp.Equalizer p_equalizer, uint u_band)
        {
            var __arg0 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcAudioEqualizerGetAmpAtIndex(__arg0, u_band);
            return __ret;
        }

        /// <summary>Apply new equalizer settings to a media player.</summary>
        /// <param name="p_mi">opaque media player handle</param>
        /// <param name="p_equalizer">opaque equalizer handle, or NULL to disable the equalizer for this media player</param>
        /// <returns>zero on success, -1 on error</returns>
        /// <remarks>
        /// <para>The equalizer is first created by invoking libvlc_audio_equalizer_new() or</para>
        /// <para>libvlc_audio_equalizer_new_from_preset().</para>
        /// <para>It is possible to apply new equalizer settings to a media player whether the media</para>
        /// <para>player is currently playing media or not.</para>
        /// <para>Invoking this method will immediately apply the new equalizer settings to the audio</para>
        /// <para>output of the currently playing media if there is any.</para>
        /// <para>If there is no currently playing media, the new equalizer settings will be applied</para>
        /// <para>later if and when new media is played.</para>
        /// <para>Equalizer settings will automatically be applied to subsequently played media.</para>
        /// <para>To disable the equalizer for a media player invoke this method passing NULL for the</para>
        /// <para>p_equalizer parameter.</para>
        /// <para>The media player does not keep a reference to the supplied equalizer so it is safe</para>
        /// <para>for an application to release the equalizer reference any time after this method</para>
        /// <para>returns.</para>
        /// <para>LibVLC 2.2.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaPlayerSetEqualizer(global::libvlcsharp.MediaPlayer p_mi, global::libvlcsharp.Equalizer p_equalizer)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __arg1 = ReferenceEquals(p_equalizer, null) ? global::System.IntPtr.Zero : p_equalizer.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetEqualizer(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Gets the media role.</summary>
        /// <param name="p_mi">media player</param>
        /// <returns>the media player role (</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static int LibvlcMediaPlayerGetRole(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetRole(__arg0);
            return __ret;
        }

        /// <summary>Sets the media role.</summary>
        /// <param name="p_mi">media player</param>
        /// <param name="role">the media player role (</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcMediaPlayerSetRole(global::libvlcsharp.MediaPlayer p_mi, uint role)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerSetRole(__arg0, role);
            return __ret;
        }
    }

    /// <summary>A LibVLC media list holds multiple</summary>
    /// <remarks>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media list (playlist) external API</para>
    /// </remarks>
    public unsafe partial class libvlc_media_list
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_new")]
            internal static extern global::System.IntPtr LibvlcMediaListNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_release")]
            internal static extern void LibvlcMediaListRelease(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_retain")]
            internal static extern void LibvlcMediaListRetain(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_set_media")]
            internal static extern void LibvlcMediaListSetMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_media")]
            internal static extern global::System.IntPtr LibvlcMediaListMedia(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_add_media")]
            internal static extern int LibvlcMediaListAddMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_insert_media")]
            internal static extern int LibvlcMediaListInsertMedia(global::System.IntPtr p_ml, global::System.IntPtr p_md, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_remove_index")]
            internal static extern int LibvlcMediaListRemoveIndex(global::System.IntPtr p_ml, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_count")]
            internal static extern int LibvlcMediaListCount(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_item_at_index")]
            internal static extern global::System.IntPtr LibvlcMediaListItemAtIndex(global::System.IntPtr p_ml, int i_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_index_of_item")]
            internal static extern int LibvlcMediaListIndexOfItem(global::System.IntPtr p_ml, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_is_readonly")]
            internal static extern int LibvlcMediaListIsReadonly(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_lock")]
            internal static extern void LibvlcMediaListLock(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_unlock")]
            internal static extern void LibvlcMediaListUnlock(global::System.IntPtr p_ml);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaListEventManager(global::System.IntPtr p_ml);
        }

        /// <summary>Create an empty media list.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>empty media list, or NULL on error</returns>
        public static global::libvlcsharp.MediaList LibvlcMediaListNew(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaListNew(__arg0);
            global::libvlcsharp.MediaList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaList) global::libvlcsharp.MediaList.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaList.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release media list created with libvlc_media_list_new().</summary>
        /// <param name="p_ml">a media list created with libvlc_media_list_new()</param>
        public static void LibvlcMediaListRelease(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListRelease(__arg0);
        }

        /// <summary>Retain reference to a media list</summary>
        /// <param name="p_ml">a media list created with libvlc_media_list_new()</param>
        public static void LibvlcMediaListRetain(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListRetain(__arg0);
        }

        /// <summary>
        /// <para>Associate media instance with this media list instance.</para>
        /// <para>If another media instance was present it will be released.</para>
        /// <para>The libvlc_media_list_lock should NOT be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">media instance to add</param>
        public static void LibvlcMediaListSetMedia(global::libvlcsharp.MediaList p_ml, global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaListSetMedia(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Get media instance from this media list instance. This action will increase</para>
        /// <para>the refcount on the media instance.</para>
        /// <para>The libvlc_media_list_lock should NOT be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>media instance</returns>
        public static global::libvlcsharp.Media LibvlcMediaListMedia(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListMedia(__arg0);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Add media instance to media list</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">a media instance</param>
        /// <returns>0 on success, -1 if the media list is read-only</returns>
        public static int LibvlcMediaListAddMedia(global::libvlcsharp.MediaList p_ml, global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListAddMedia(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Insert media instance in media list on a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">a media instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>0 on success, -1 if the media list is read-only</returns>
        public static int LibvlcMediaListInsertMedia(global::libvlcsharp.MediaList p_ml, global::libvlcsharp.Media p_md, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListInsertMedia(__arg0, __arg1, i_pos);
            return __ret;
        }

        /// <summary>
        /// <para>Remove media instance from media list on a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>0 on success, -1 if the list is read-only or the item was not found</returns>
        public static int LibvlcMediaListRemoveIndex(global::libvlcsharp.MediaList p_ml, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListRemoveIndex(__arg0, i_pos);
            return __ret;
        }

        /// <summary>
        /// <para>Get count on media list items</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>number of items in media list</returns>
        public static int LibvlcMediaListCount(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>List media instance in media list at a position</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="i_pos">position in array where to insert</param>
        /// <returns>
        /// <para>media instance at position i_pos, or NULL if not found.</para>
        /// <para>In case of success, libvlc_media_retain() is called to increase the refcount</para>
        /// <para>on the media.</para>
        /// </returns>
        public static global::libvlcsharp.Media LibvlcMediaListItemAtIndex(global::libvlcsharp.MediaList p_ml, int i_pos)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListItemAtIndex(__arg0, i_pos);
            global::libvlcsharp.Media __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Media.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Media) global::libvlcsharp.Media.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Media.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Find index position of List media instance in media list.</para>
        /// <para>Warning: the function will return the first matched position.</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <param name="p_md">media instance</param>
        /// <returns>position of media instance or -1 if media not found</returns>
        public static int LibvlcMediaListIndexOfItem(global::libvlcsharp.MediaList p_ml, global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListIndexOfItem(__arg0, __arg1);
            return __ret;
        }

        /// <summary>This indicates if this media list is read-only from a user point of view</summary>
        /// <param name="p_ml">media list instance</param>
        /// <returns>1 on readonly, 0 on readwrite</returns>
        public static int LibvlcMediaListIsReadonly(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListIsReadonly(__arg0);
            return __ret;
        }

        /// <summary>Get lock on media list items</summary>
        /// <param name="p_ml">a media list instance</param>
        public static void LibvlcMediaListLock(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListLock(__arg0);
        }

        /// <summary>
        /// <para>Release lock on media list items</para>
        /// <para>The libvlc_media_list_lock should be held upon entering this function.</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        public static void LibvlcMediaListUnlock(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            __Internal.LibvlcMediaListUnlock(__arg0);
        }

        /// <summary>
        /// <para>Get libvlc_event_manager from this media list instance.</para>
        /// <para>The p_event_manager is immutable, so you don't have to hold the lock</para>
        /// </summary>
        /// <param name="p_ml">a media list instance</param>
        /// <returns>libvlc_event_manager</returns>
        public static global::libvlcsharp.EventManager LibvlcMediaListEventManager(global::libvlcsharp.MediaList p_ml)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>Defines playback modes for playlist.</summary>
    public enum PlaybackMode
    {
        Default = 0,
        Loop = 1,
        Repeat = 2
    }

    /// <summary>The LibVLC media list player plays a</summary>
    /// <remarks>
    /// <para>in a certain order.</para>
    /// <para>This is required to especially support playlist files.</para>
    /// <para>The normal</para>
    /// <para>single media, and does not handle playlist files properly.</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media list player external API</para>
    /// </remarks>
    public unsafe partial class LibvlcMediaListPlayerT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcMediaListPlayerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcMediaListPlayerT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcMediaListPlayerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcMediaListPlayerT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcMediaListPlayerT __CreateInstance(global::libvlcsharp.LibvlcMediaListPlayerT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcMediaListPlayerT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcMediaListPlayerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcMediaListPlayerT.__Internal));
            *(global::libvlcsharp.LibvlcMediaListPlayerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaListPlayerT(global::libvlcsharp.LibvlcMediaListPlayerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaListPlayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class libvlc_media_list_player
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_new")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_release")]
            internal static extern void LibvlcMediaListPlayerRelease(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_retain")]
            internal static extern void LibvlcMediaListPlayerRetain(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerEventManager(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_media_player")]
            internal static extern void LibvlcMediaListPlayerSetMediaPlayer(global::System.IntPtr p_mlp, global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_get_media_player")]
            internal static extern global::System.IntPtr LibvlcMediaListPlayerGetMediaPlayer(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_media_list")]
            internal static extern void LibvlcMediaListPlayerSetMediaList(global::System.IntPtr p_mlp, global::System.IntPtr p_mlist);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play")]
            internal static extern void LibvlcMediaListPlayerPlay(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_pause")]
            internal static extern void LibvlcMediaListPlayerPause(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_is_playing")]
            internal static extern int LibvlcMediaListPlayerIsPlaying(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_get_state")]
            internal static extern global::libvlcsharp.VLCState LibvlcMediaListPlayerGetState(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play_item_at_index")]
            internal static extern int LibvlcMediaListPlayerPlayItemAtIndex(global::System.IntPtr p_mlp, int i_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_play_item")]
            internal static extern int LibvlcMediaListPlayerPlayItem(global::System.IntPtr p_mlp, global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_stop")]
            internal static extern void LibvlcMediaListPlayerStop(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_next")]
            internal static extern int LibvlcMediaListPlayerNext(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_previous")]
            internal static extern int LibvlcMediaListPlayerPrevious(global::System.IntPtr p_mlp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_player_set_playback_mode")]
            internal static extern void LibvlcMediaListPlayerSetPlaybackMode(global::System.IntPtr p_mlp, global::libvlcsharp.PlaybackMode e_mode);
        }

        /// <summary>Create new media_list_player.</summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>media list player instance or NULL on error</returns>
        public static global::libvlcsharp.LibvlcMediaListPlayerT LibvlcMediaListPlayerNew(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerNew(__arg0);
            global::libvlcsharp.LibvlcMediaListPlayerT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.LibvlcMediaListPlayerT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.LibvlcMediaListPlayerT) global::libvlcsharp.LibvlcMediaListPlayerT.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.LibvlcMediaListPlayerT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release a media_list_player after use</para>
        /// <para>Decrement the reference count of a media player object. If the</para>
        /// <para>reference count is 0, then libvlc_media_list_player_release() will</para>
        /// <para>release the media player object. If the media player object</para>
        /// <para>has been released, then it should not be used again.</para>
        /// </summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerRelease(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media player list object. Use</para>
        /// <para>libvlc_media_list_player_release() to decrement reference count.</para>
        /// </summary>
        /// <param name="p_mlp">media player list object</param>
        public static void LibvlcMediaListPlayerRetain(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerRetain(__arg0);
        }

        /// <summary>Return the event manager of this media_list_player.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>the event manager</returns>
        public static global::libvlcsharp.EventManager LibvlcMediaListPlayerEventManager(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Replace media player in media_list_player with this instance.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_mi">media player instance</param>
        public static void LibvlcMediaListPlayerSetMediaPlayer(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp, global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaListPlayerSetMediaPlayer(__arg0, __arg1);
        }

        /// <summary>Get media player of the media_list_player instance.</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>media player instance</returns>
        /// <remarks>the caller is responsible for releasing the returned instance</remarks>
        public static global::libvlcsharp.MediaPlayer LibvlcMediaListPlayerGetMediaPlayer(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerGetMediaPlayer(__arg0);
            global::libvlcsharp.MediaPlayer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaPlayer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaPlayer) global::libvlcsharp.MediaPlayer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaPlayer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set the media list associated with the player</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_mlist">list of media</param>
        public static void LibvlcMediaListPlayerSetMediaList(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp, global::libvlcsharp.MediaList p_mlist)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_mlist, null) ? global::System.IntPtr.Zero : p_mlist.__Instance;
            __Internal.LibvlcMediaListPlayerSetMediaList(__arg0, __arg1);
        }

        /// <summary>Play media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerPlay(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerPlay(__arg0);
        }

        /// <summary>Toggle pause (or resume) media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerPause(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerPause(__arg0);
        }

        /// <summary>Is media list playing?</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>true for playing and false for not playing</returns>
        public static int LibvlcMediaListPlayerIsPlaying(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerIsPlaying(__arg0);
            return __ret;
        }

        /// <summary>Get current libvlc_state of media list player</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>libvlc_state_t for media list player</returns>
        public static global::libvlcsharp.VLCState LibvlcMediaListPlayerGetState(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerGetState(__arg0);
            return __ret;
        }

        /// <summary>Play media list item at position index</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="i_index">index in media list to play</param>
        /// <returns>0 upon success -1 if the item wasn't found</returns>
        public static int LibvlcMediaListPlayerPlayItemAtIndex(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp, int i_index)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPlayItemAtIndex(__arg0, i_index);
            return __ret;
        }

        /// <summary>Play the given media item</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="p_md">the media instance</param>
        /// <returns>0 upon success, -1 if the media is not part of the media list</returns>
        public static int LibvlcMediaListPlayerPlayItem(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp, global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __arg1 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPlayItem(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Stop playing media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        public static void LibvlcMediaListPlayerStop(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerStop(__arg0);
        }

        /// <summary>Play next item from media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>0 upon success -1 if there is no next item</returns>
        public static int LibvlcMediaListPlayerNext(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerNext(__arg0);
            return __ret;
        }

        /// <summary>Play previous item from media list</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <returns>0 upon success -1 if there is no previous item</returns>
        public static int LibvlcMediaListPlayerPrevious(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            var __ret = __Internal.LibvlcMediaListPlayerPrevious(__arg0);
            return __ret;
        }

        /// <summary>Sets the playback mode for the playlist</summary>
        /// <param name="p_mlp">media list player instance</param>
        /// <param name="e_mode">playback mode specification</param>
        public static void LibvlcMediaListPlayerSetPlaybackMode(global::libvlcsharp.LibvlcMediaListPlayerT p_mlp, global::libvlcsharp.PlaybackMode e_mode)
        {
            var __arg0 = ReferenceEquals(p_mlp, null) ? global::System.IntPtr.Zero : p_mlp.__Instance;
            __Internal.LibvlcMediaListPlayerSetPlaybackMode(__arg0, e_mode);
        }
    }

    /// <summary>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media library external API</para>
    /// </summary>
    public unsafe partial class LibvlcMediaLibraryT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcMediaLibraryT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcMediaLibraryT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcMediaLibraryT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcMediaLibraryT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcMediaLibraryT __CreateInstance(global::libvlcsharp.LibvlcMediaLibraryT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcMediaLibraryT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcMediaLibraryT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcMediaLibraryT.__Internal));
            *(global::libvlcsharp.LibvlcMediaLibraryT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcMediaLibraryT(global::libvlcsharp.LibvlcMediaLibraryT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcMediaLibraryT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class libvlc_media_library
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_new")]
            internal static extern global::System.IntPtr LibvlcMediaLibraryNew(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_release")]
            internal static extern void LibvlcMediaLibraryRelease(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_retain")]
            internal static extern void LibvlcMediaLibraryRetain(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_load")]
            internal static extern int LibvlcMediaLibraryLoad(global::System.IntPtr p_mlib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_library_media_list")]
            internal static extern global::System.IntPtr LibvlcMediaLibraryMediaList(global::System.IntPtr p_mlib);
        }

        /// <summary>Create an new Media Library object</summary>
        /// <param name="p_instance">the libvlc instance</param>
        /// <returns>a new object or NULL on error</returns>
        public static global::libvlcsharp.LibvlcMediaLibraryT LibvlcMediaLibraryNew(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryNew(__arg0);
            global::libvlcsharp.LibvlcMediaLibraryT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.LibvlcMediaLibraryT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.LibvlcMediaLibraryT) global::libvlcsharp.LibvlcMediaLibraryT.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.LibvlcMediaLibraryT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Release media library object. This functions decrements the</para>
        /// <para>reference count of the media library object. If it reaches 0,</para>
        /// <para>then the object will be released.</para>
        /// </summary>
        /// <param name="p_mlib">media library object</param>
        public static void LibvlcMediaLibraryRelease(global::libvlcsharp.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            __Internal.LibvlcMediaLibraryRelease(__arg0);
        }

        /// <summary>
        /// <para>Retain a reference to a media library object. This function will</para>
        /// <para>increment the reference counting for this object. Use</para>
        /// <para>libvlc_media_library_release() to decrement the reference count.</para>
        /// </summary>
        /// <param name="p_mlib">media library object</param>
        public static void LibvlcMediaLibraryRetain(global::libvlcsharp.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            __Internal.LibvlcMediaLibraryRetain(__arg0);
        }

        /// <summary>Load media library.</summary>
        /// <param name="p_mlib">media library object</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcMediaLibraryLoad(global::libvlcsharp.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryLoad(__arg0);
            return __ret;
        }

        /// <summary>Get media library subitems.</summary>
        /// <param name="p_mlib">media library object</param>
        /// <returns>media list subitems</returns>
        public static global::libvlcsharp.MediaList LibvlcMediaLibraryMediaList(global::libvlcsharp.LibvlcMediaLibraryT p_mlib)
        {
            var __arg0 = ReferenceEquals(p_mlib, null) ? global::System.IntPtr.Zero : p_mlib.__Instance;
            var __ret = __Internal.LibvlcMediaLibraryMediaList(__arg0);
            global::libvlcsharp.MediaList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaList) global::libvlcsharp.MediaList.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaList.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>Category of a media discoverer</summary>
    /// <remarks>libvlc_media_discoverer_list_get()</remarks>
    public enum MediaDiscovererCategory
    {
        /// <summary>devices, like portable music player</summary>
        Devices = 0,
        /// <summary>LAN/WAN services, like Upnp, SMB, or SAP</summary>
        Lan = 1,
        /// <summary>Podcasts</summary>
        Podcasts = 2,
        /// <summary>Local directories, like Video, Music or Pictures directories</summary>
        Localdirs = 3
    }

    /// <summary>
    /// <para>LibVLC media discovery finds available media via various means.</para>
    /// <para>This corresponds to the service discovery functionality in VLC media player.</para>
    /// <para>Different plugins find potential medias locally (e.g. user media directory),</para>
    /// <para>from peripherals (e.g. video capture device), on the local network</para>
    /// <para>(e.g. SAP) or on the Internet (e.g. Internet radios).</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC media discovery external API</para>
    /// </summary>
    public unsafe partial class MediaDiscoverer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaDiscoverer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaDiscoverer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaDiscoverer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaDiscoverer(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaDiscoverer __CreateInstance(global::libvlcsharp.MediaDiscoverer.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaDiscoverer(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaDiscoverer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaDiscoverer.__Internal));
            *(global::libvlcsharp.MediaDiscoverer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaDiscoverer(global::libvlcsharp.MediaDiscoverer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaDiscoverer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Media discoverer description</summary>
    /// <remarks>libvlc_media_discoverer_list_get()</remarks>
    public unsafe partial class MediaDiscovererDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_longname;

            [FieldOffset(16)]
            internal global::libvlcsharp.MediaDiscovererCategory i_cat;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_media_discoverer_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaDiscovererDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.MediaDiscovererDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.MediaDiscovererDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaDiscovererDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.MediaDiscovererDescription __CreateInstance(global::libvlcsharp.MediaDiscovererDescription.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.MediaDiscovererDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.MediaDiscovererDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaDiscovererDescription.__Internal));
            *(global::libvlcsharp.MediaDiscovererDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MediaDiscovererDescription(global::libvlcsharp.MediaDiscovererDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MediaDiscovererDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MediaDiscovererDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MediaDiscovererDescription(global::libvlcsharp.MediaDiscovererDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.MediaDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance) = *((global::libvlcsharp.MediaDiscovererDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.MediaDiscovererDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.MediaDiscovererCategory ICat
        {
            get
            {
                return ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->i_cat;
            }

            set
            {
                ((global::libvlcsharp.MediaDiscovererDescription.__Internal*) __Instance)->i_cat = value;
            }
        }
    }

    public unsafe partial class libvlc_media_discoverer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_new")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNew(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_start")]
            internal static extern int LibvlcMediaDiscovererStart(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_stop")]
            internal static extern void LibvlcMediaDiscovererStop(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_release")]
            internal static extern void LibvlcMediaDiscovererRelease(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_media_list")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererMediaList(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_is_running")]
            internal static extern int LibvlcMediaDiscovererIsRunning(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_list_get")]
            internal static extern ulong LibvlcMediaDiscovererListGet(global::System.IntPtr p_inst, global::libvlcsharp.MediaDiscovererCategory i_cat, global::System.IntPtr ppp_services);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_list_release")]
            internal static extern void LibvlcMediaDiscovererListRelease(global::System.IntPtr pp_services, ulong i_count);
        }

        /// <summary>Create a media discoverer object by name.</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="psz_name">
        /// <para>service name; use libvlc_media_discoverer_list_get() to get</para>
        /// <para>a list of the discoverer names available in this libVLC instance</para>
        /// </param>
        /// <returns>media discover object or NULL in case of error</returns>
        /// <remarks>
        /// <para>After this object is created, you should attach to media_list events in</para>
        /// <para>order to be notified of new items discovered.</para>
        /// <para>You need to call libvlc_media_discoverer_start() in order to start the</para>
        /// <para>discovery.</para>
        /// <para>libvlc_media_discoverer_media_list</para>
        /// <para>libvlc_media_discoverer_event_manager</para>
        /// <para>libvlc_media_discoverer_start</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::libvlcsharp.MediaDiscoverer LibvlcMediaDiscovererNew(global::libvlcsharp.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererNew(__arg0, psz_name);
            global::libvlcsharp.MediaDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaDiscoverer) global::libvlcsharp.MediaDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start media discovery.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>To stop it, call libvlc_media_discoverer_stop() or</para>
        /// <para>libvlc_media_discoverer_list_release() directly.</para>
        /// <para>libvlc_media_discoverer_stop</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcMediaDiscovererStart(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererStart(__arg0);
            return __ret;
        }

        /// <summary>Stop media discovery.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <remarks>
        /// <para>libvlc_media_discoverer_start</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcMediaDiscovererStop(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            __Internal.LibvlcMediaDiscovererStop(__arg0);
        }

        /// <summary>
        /// <para>Release media discover object. If the reference count reaches 0, then</para>
        /// <para>the object will be released.</para>
        /// </summary>
        /// <param name="p_mdis">media service discover object</param>
        public static void LibvlcMediaDiscovererRelease(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            __Internal.LibvlcMediaDiscovererRelease(__arg0);
        }

        /// <summary>Get media service discover media list.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>list of media items</returns>
        public static global::libvlcsharp.MediaList LibvlcMediaDiscovererMediaList(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererMediaList(__arg0);
            global::libvlcsharp.MediaList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaList) global::libvlcsharp.MediaList.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaList.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Query if media service discover object is running.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>true if running, false if not</returns>
        public static int LibvlcMediaDiscovererIsRunning(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererIsRunning(__arg0);
            return __ret;
        }

        /// <summary>Get media discoverer services by category</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="i_cat">category of services to fetch</param>
        /// <param name="ppp_services">
        /// <para>address to store an allocated array of media discoverer</para>
        /// <para>services (must be freed with libvlc_media_discoverer_list_release() by</para>
        /// <para>the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of media discoverer services (0 on error)</returns>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static ulong LibvlcMediaDiscovererListGet(global::libvlcsharp.Instance p_inst, global::libvlcsharp.MediaDiscovererCategory i_cat, global::libvlcsharp.MediaDiscovererDescription ppp_services)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __arg2 = ReferenceEquals(ppp_services, null) ? global::System.IntPtr.Zero : ppp_services.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererListGet(__arg0, i_cat, __arg2);
            return __ret;
        }

        /// <summary>Release an array of media discoverer services</summary>
        /// <param name="pp_services">array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// <para>libvlc_media_discoverer_list_get()</para>
        /// </remarks>
        public static void LibvlcMediaDiscovererListRelease(global::libvlcsharp.MediaDiscovererDescription pp_services, ulong i_count)
        {
            var __arg0 = ReferenceEquals(pp_services, null) ? global::System.IntPtr.Zero : pp_services.__Instance;
            __Internal.LibvlcMediaDiscovererListRelease(__arg0, i_count);
        }
    }

    /// <summary>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC dialog external API</para>
    /// </summary>
    public enum DialogQuestionType
    {
        Normal = 0,
        Warning = 1,
        Critical = 2
    }

    public unsafe partial class LibvlcDialogId
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcDialogId> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcDialogId>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcDialogId __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcDialogId(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcDialogId __CreateInstance(global::libvlcsharp.LibvlcDialogId.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcDialogId(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcDialogId.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcDialogId.__Internal));
            *(global::libvlcsharp.LibvlcDialogId.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcDialogId(global::libvlcsharp.LibvlcDialogId.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcDialogId(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Dialog callbacks to be implemented</summary>
    public unsafe partial class LibvlcDialogCbs : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr pf_display_error;

            [FieldOffset(8)]
            internal global::System.IntPtr pf_display_login;

            [FieldOffset(16)]
            internal global::System.IntPtr pf_display_question;

            [FieldOffset(24)]
            internal global::System.IntPtr pf_display_progress;

            [FieldOffset(32)]
            internal global::System.IntPtr pf_cancel;

            [FieldOffset(40)]
            internal global::System.IntPtr pf_update_progress;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_dialog_cbs@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcDialogCbs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcDialogCbs>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcDialogCbs __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcDialogCbs(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcDialogCbs __CreateInstance(global::libvlcsharp.LibvlcDialogCbs.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcDialogCbs(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcDialogCbs.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcDialogCbs.__Internal));
            *(global::libvlcsharp.LibvlcDialogCbs.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcDialogCbs(global::libvlcsharp.LibvlcDialogCbs.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcDialogCbs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LibvlcDialogCbs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcDialogCbs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public LibvlcDialogCbs(global::libvlcsharp.LibvlcDialogCbs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcDialogCbs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.LibvlcDialogCbs.__Internal*) __Instance) = *((global::libvlcsharp.LibvlcDialogCbs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.LibvlcDialogCbs __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class libvlc_dialog
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_set_callbacks")]
            internal static extern void LibvlcDialogSetCallbacks(global::System.IntPtr p_instance, global::System.IntPtr p_cbs, global::System.IntPtr p_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_set_context")]
            internal static extern void LibvlcDialogSetContext(global::System.IntPtr p_id, global::System.IntPtr p_context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_get_context")]
            internal static extern global::System.IntPtr LibvlcDialogGetContext(global::System.IntPtr p_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_post_login")]
            internal static extern int LibvlcDialogPostLogin(global::System.IntPtr p_id, [MarshalAs(UnmanagedType.LPStr)] string psz_username, [MarshalAs(UnmanagedType.LPStr)] string psz_password, bool b_store);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_post_action")]
            internal static extern int LibvlcDialogPostAction(global::System.IntPtr p_id, int i_action);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_dialog_dismiss")]
            internal static extern int LibvlcDialogDismiss(global::System.IntPtr p_id);
        }

        /// <summary>Register callbacks in order to handle VLC dialogs</summary>
        /// <param name="p_cbs">a pointer to callbacks, or NULL to unregister callbacks.</param>
        /// <param name="p_data">opaque pointer for the callback</param>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcDialogSetCallbacks(global::libvlcsharp.Instance p_instance, global::libvlcsharp.LibvlcDialogCbs p_cbs, global::System.IntPtr p_data)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __arg1 = ReferenceEquals(p_cbs, null) ? global::System.IntPtr.Zero : p_cbs.__Instance;
            __Internal.LibvlcDialogSetCallbacks(__arg0, __arg1, p_data);
        }

        /// <summary>Associate an opaque pointer with the dialog id</summary>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static void LibvlcDialogSetContext(global::libvlcsharp.LibvlcDialogId p_id, global::System.IntPtr p_context)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            __Internal.LibvlcDialogSetContext(__arg0, p_context);
        }

        /// <summary>Return the opaque pointer associated with the dialog id</summary>
        /// <remarks>LibVLC 3.0.0 and later.</remarks>
        public static global::System.IntPtr LibvlcDialogGetContext(global::libvlcsharp.LibvlcDialogId p_id)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogGetContext(__arg0);
            return __ret;
        }

        /// <summary>Post a login answer</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <param name="psz_username">valid and non empty string</param>
        /// <param name="psz_password">valid string (can be empty)</param>
        /// <param name="b_store">if true, store the credentials</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_display_login</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogPostLogin(global::libvlcsharp.LibvlcDialogId p_id, string psz_username, string psz_password, bool b_store)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogPostLogin(__arg0, psz_username, psz_password, b_store);
            return __ret;
        }

        /// <summary>Post a question answer</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <param name="i_action">1 for action1, 2 for action2</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_display_question</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogPostAction(global::libvlcsharp.LibvlcDialogId p_id, int i_action)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogPostAction(__arg0, i_action);
            return __ret;
        }

        /// <summary>Dismiss a dialog</summary>
        /// <param name="p_id">id of the dialog</param>
        /// <returns>0 on success, or -1 on error</returns>
        /// <remarks>
        /// <para>After this call, p_id won't be valid anymore</para>
        /// <para>libvlc_dialog_cbs.pf_cancel</para>
        /// <para>LibVLC 3.0.0 and later.</para>
        /// </remarks>
        public static int LibvlcDialogDismiss(global::libvlcsharp.LibvlcDialogId p_id)
        {
            var __arg0 = ReferenceEquals(p_id, null) ? global::System.IntPtr.Zero : p_id.__Instance;
            var __ret = __Internal.LibvlcDialogDismiss(__arg0);
            return __ret;
        }
    }

    public unsafe partial class libvlc_vlm
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_release")]
            internal static extern void LibvlcVlmRelease(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_broadcast")]
            internal static extern int LibvlcVlmAddBroadcast(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_vod")]
            internal static extern int LibvlcVlmAddVod(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, int i_options, sbyte** ppsz_options, int b_enabled, [MarshalAs(UnmanagedType.LPStr)] string psz_mux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_del_media")]
            internal static extern int LibvlcVlmDelMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_enabled")]
            internal static extern int LibvlcVlmSetEnabled(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int b_enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_output")]
            internal static extern int LibvlcVlmSetOutput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_input")]
            internal static extern int LibvlcVlmSetInput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_add_input")]
            internal static extern int LibvlcVlmAddInput(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_loop")]
            internal static extern int LibvlcVlmSetLoop(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_set_mux")]
            internal static extern int LibvlcVlmSetMux(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_mux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_change_media")]
            internal static extern int LibvlcVlmChangeMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, [MarshalAs(UnmanagedType.LPStr)] string psz_input, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_play_media")]
            internal static extern int LibvlcVlmPlayMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_stop_media")]
            internal static extern int LibvlcVlmStopMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_pause_media")]
            internal static extern int LibvlcVlmPauseMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_seek_media")]
            internal static extern int LibvlcVlmSeekMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, float f_percentage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_show_media")]
            internal static extern global::System.IntPtr LibvlcVlmShowMedia(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_position")]
            internal static extern float LibvlcVlmGetMediaInstancePosition(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_time")]
            internal static extern int LibvlcVlmGetMediaInstanceTime(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_length")]
            internal static extern int LibvlcVlmGetMediaInstanceLength(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_media_instance_rate")]
            internal static extern int LibvlcVlmGetMediaInstanceRate(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_name, int i_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_vlm_get_event_manager")]
            internal static extern global::System.IntPtr LibvlcVlmGetEventManager(global::System.IntPtr p_instance);
        }

        /// <summary>Release the vlm instance related to the given libvlc_instance_t</summary>
        /// <param name="p_instance">the instance</param>
        public static void LibvlcVlmRelease(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcVlmRelease(__arg0);
        }

        /// <summary>Add a broadcast, with one input.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new broadcast</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new broadcast</param>
        /// <param name="b_loop">Should this broadcast be played in loop ?</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddBroadcast(global::libvlcsharp.Instance p_instance, string psz_name, string psz_input, string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddBroadcast(__arg0, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop);
            return __ret;
        }

        /// <summary>Add a vod, with one input.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new vod media</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new vod</param>
        /// <param name="psz_mux">the muxer of the vod media</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddVod(global::libvlcsharp.Instance p_instance, string psz_name, string psz_input, int i_options, sbyte** ppsz_options, int b_enabled, string psz_mux)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddVod(__arg0, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux);
            return __ret;
        }

        /// <summary>Delete a media (VOD or broadcast).</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to delete</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmDelMedia(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmDelMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Enable or disable a media (VOD or broadcast).</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="b_enabled">the new status</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetEnabled(global::libvlcsharp.Instance p_instance, string psz_name, int b_enabled)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetEnabled(__arg0, psz_name, b_enabled);
            return __ret;
        }

        /// <summary>Set the output for a media.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetOutput(global::libvlcsharp.Instance p_instance, string psz_name, string psz_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetOutput(__arg0, psz_name, psz_output);
            return __ret;
        }

        /// <summary>
        /// <para>Set a media's input MRL. This will delete all existing inputs and</para>
        /// <para>add the specified one.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_input">the input MRL</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetInput(global::libvlcsharp.Instance p_instance, string psz_name, string psz_input)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetInput(__arg0, psz_name, psz_input);
            return __ret;
        }

        /// <summary>Add a media's input MRL. This will add the specified one.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_input">the input MRL</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmAddInput(global::libvlcsharp.Instance p_instance, string psz_name, string psz_input)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmAddInput(__arg0, psz_name, psz_input);
            return __ret;
        }

        /// <summary>Set a media's loop status.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="b_loop">the new status</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetLoop(global::libvlcsharp.Instance p_instance, string psz_name, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetLoop(__arg0, psz_name, b_loop);
            return __ret;
        }

        /// <summary>Set a media's vod muxer.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the media to work on</param>
        /// <param name="psz_mux">the new muxer</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSetMux(global::libvlcsharp.Instance p_instance, string psz_name, string psz_mux)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSetMux(__arg0, psz_name, psz_mux);
            return __ret;
        }

        /// <summary>
        /// <para>Edit the parameters of a media. This will delete all existing inputs and</para>
        /// <para>add the specified one.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the new broadcast</param>
        /// <param name="psz_input">the input MRL</param>
        /// <param name="psz_output">the output MRL (the parameter to the &quot;sout&quot; variable)</param>
        /// <param name="i_options">number of additional options</param>
        /// <param name="ppsz_options">additional options</param>
        /// <param name="b_enabled">boolean for enabling the new broadcast</param>
        /// <param name="b_loop">Should this broadcast be played in loop ?</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmChangeMedia(global::libvlcsharp.Instance p_instance, string psz_name, string psz_input, string psz_output, int i_options, sbyte** ppsz_options, int b_enabled, int b_loop)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmChangeMedia(__arg0, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop);
            return __ret;
        }

        /// <summary>Play the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmPlayMedia(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmPlayMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Stop the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmStopMedia(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmStopMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Pause the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmPauseMedia(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmPauseMedia(__arg0, psz_name);
            return __ret;
        }

        /// <summary>Seek in the named broadcast.</summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">the name of the broadcast</param>
        /// <param name="f_percentage">the percentage to seek to</param>
        /// <returns>0 on success, -1 on error</returns>
        public static int LibvlcVlmSeekMedia(global::libvlcsharp.Instance p_instance, string psz_name, float f_percentage)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmSeekMedia(__arg0, psz_name, f_percentage);
            return __ret;
        }

        /// <summary>
        /// <para>Return information about the named media as a JSON</para>
        /// <para>string representation.</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <param name="psz_name">
        /// <para>the name of the media,</para>
        /// <para>if the name is an empty string, all media is described</para>
        /// </param>
        /// <returns>string with information about named media, or NULL on error</returns>
        /// <remarks>
        /// <para>This function is mainly intended for debugging use,</para>
        /// <para>if you want programmatic access to the state of</para>
        /// <para>a vlm_media_instance_t, please use the corresponding</para>
        /// <para>libvlc_vlm_get_media_instance_xxx -functions.</para>
        /// <para>Currently there are no such functions available for</para>
        /// <para>vlm_media_t though.</para>
        /// </remarks>
        public static string LibvlcVlmShowMedia(global::libvlcsharp.Instance p_instance, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmShowMedia(__arg0, psz_name);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get vlm_media instance position by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>position as float or -1. on error</returns>
        public static float LibvlcVlmGetMediaInstancePosition(global::libvlcsharp.Instance p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstancePosition(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance time by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>time as integer or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceTime(global::libvlcsharp.Instance p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceTime(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance length by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>length of media item or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceLength(global::libvlcsharp.Instance p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceLength(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>Get vlm_media instance playback rate by name or instance id</summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <param name="psz_name">name of vlm media instance</param>
        /// <param name="i_instance">instance id</param>
        /// <returns>playback rate or -1 on error</returns>
        public static int LibvlcVlmGetMediaInstanceRate(global::libvlcsharp.Instance p_instance, string psz_name, int i_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetMediaInstanceRate(__arg0, psz_name, i_instance);
            return __ret;
        }

        /// <summary>
        /// <para>Get libvlc_event_manager from a vlm media.</para>
        /// <para>The p_event_manager is immutable, so you don't have to hold the lock</para>
        /// </summary>
        /// <param name="p_instance">a libvlc instance</param>
        /// <returns>libvlc_event_manager</returns>
        public static global::libvlcsharp.EventManager LibvlcVlmGetEventManager(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcVlmGetEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }
    }

    /// <summary>This structure is opaque. It represents a libvlc log iterator</summary>
    public unsafe partial class LibvlcLogIteratorT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcLogIteratorT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcLogIteratorT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcLogIteratorT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcLogIteratorT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcLogIteratorT __CreateInstance(global::libvlcsharp.LibvlcLogIteratorT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcLogIteratorT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcLogIteratorT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcLogIteratorT.__Internal));
            *(global::libvlcsharp.LibvlcLogIteratorT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcLogIteratorT(global::libvlcsharp.LibvlcLogIteratorT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcLogIteratorT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LibvlcLogMessageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int i_severity;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_type;

            [FieldOffset(16)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(24)]
            internal global::System.IntPtr psz_header;

            [FieldOffset(32)]
            internal global::System.IntPtr psz_message;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_log_message_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcLogMessageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.LibvlcLogMessageT>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.LibvlcLogMessageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcLogMessageT(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.LibvlcLogMessageT __CreateInstance(global::libvlcsharp.LibvlcLogMessageT.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.LibvlcLogMessageT(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.LibvlcLogMessageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcLogMessageT.__Internal));
            *(global::libvlcsharp.LibvlcLogMessageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LibvlcLogMessageT(global::libvlcsharp.LibvlcLogMessageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LibvlcLogMessageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LibvlcLogMessageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcLogMessageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public LibvlcLogMessageT(global::libvlcsharp.LibvlcLogMessageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.LibvlcLogMessageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance) = *((global::libvlcsharp.LibvlcLogMessageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::libvlcsharp.LibvlcLogMessageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ISeverity
        {
            get
            {
                return ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->i_severity;
            }

            set
            {
                ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->i_severity = value;
            }
        }

        public string PszType
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_type);
            }

            set
            {
                ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_type = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszName
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_name);
            }

            set
            {
                ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_name = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszHeader
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_header);
            }

            set
            {
                ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_header = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszMessage
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_message);
            }

            set
            {
                ((global::libvlcsharp.LibvlcLogMessageT.__Internal*) __Instance)->psz_message = Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class deprecated
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_fps")]
            internal static extern float LibvlcMediaPlayerGetFps(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_set_agl")]
            internal static extern void LibvlcMediaPlayerSetAgl(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_player_get_agl")]
            internal static extern uint LibvlcMediaPlayerGetAgl(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_track_description_release")]
            internal static extern void LibvlcTrackDescriptionRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_height")]
            internal static extern int LibvlcVideoGetHeight(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_width")]
            internal static extern int LibvlcVideoGetWidth(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_title_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetTitleDescription(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_get_chapter_description")]
            internal static extern global::System.IntPtr LibvlcVideoGetChapterDescription(global::System.IntPtr p_mi, int i_title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_video_set_subtitle_file")]
            internal static extern int LibvlcVideoSetSubtitleFile(global::System.IntPtr p_mi, [MarshalAs(UnmanagedType.LPStr)] string psz_subtitle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_toggle_teletext")]
            internal static extern void LibvlcToggleTeletext(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_count")]
            internal static extern int LibvlcAudioOutputDeviceCount(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_longname")]
            internal static extern sbyte* LibvlcAudioOutputDeviceLongname(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_device_id")]
            internal static extern sbyte* LibvlcAudioOutputDeviceId(global::System.IntPtr p_instance, [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_get_device_type")]
            internal static extern int LibvlcAudioOutputGetDeviceType(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_audio_output_set_device_type")]
            internal static extern void LibvlcAudioOutputSetDeviceType(global::System.IntPtr p_mp, int device_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse")]
            internal static extern void LibvlcMediaParse(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_parse_async")]
            internal static extern void LibvlcMediaParseAsync(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_is_parsed")]
            internal static extern int LibvlcMediaIsParsed(global::System.IntPtr p_md);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_get_tracks_info")]
            internal static extern int LibvlcMediaGetTracksInfo(global::System.IntPtr p_md, global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_list_add_file_content")]
            internal static extern int LibvlcMediaListAddFileContent(global::System.IntPtr p_ml, [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_new_from_name")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNewFromName(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_localized_name")]
            internal static extern sbyte* LibvlcMediaDiscovererLocalizedName(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_media_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererEventManager(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_wait")]
            internal static extern void LibvlcWait(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_log_verbosity")]
            internal static extern uint LibvlcGetLogVerbosity(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_set_log_verbosity")]
            internal static extern void LibvlcSetLogVerbosity(global::System.IntPtr p_instance, uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_open")]
            internal static extern global::System.IntPtr LibvlcLogOpen(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_close")]
            internal static extern void LibvlcLogClose(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_count")]
            internal static extern uint LibvlcLogCount(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_clear")]
            internal static extern void LibvlcLogClear(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_iterator")]
            internal static extern global::System.IntPtr LibvlcLogGetIterator(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_free")]
            internal static extern void LibvlcLogIteratorFree(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_has_next")]
            internal static extern int LibvlcLogIteratorHasNext(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_iterator_next")]
            internal static extern global::System.IntPtr LibvlcLogIteratorNext(global::System.IntPtr p_iter, global::System.IntPtr p_buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_playlist_play")]
            internal static extern void LibvlcPlaylistPlay(global::System.IntPtr p_instance, int i_id, int i_options, sbyte** ppsz_options);
        }

        /// <summary>Get movie fps rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>frames per second (fps) for this playing movie, or 0 if unspecified</returns>
        /// <remarks>
        /// <para>This function is provided for backward compatibility. It cannot deal with</para>
        /// <para>multiple video tracks. In LibVLC versions prior to 3.0, it would also fail</para>
        /// <para>if the file format did not convey the frame rate explicitly.</para>
        /// <para>Consider using libvlc_media_tracks_get() instead.</para>
        /// </remarks>
        public static float LibvlcMediaPlayerGetFps(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetFps(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_media_player_set_nsobject() instead</remarks>
        public static void LibvlcMediaPlayerSetAgl(global::libvlcsharp.MediaPlayer p_mi, uint drawable)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcMediaPlayerSetAgl(__arg0, drawable);
        }

        /// <remarks>Use libvlc_media_player_get_nsobject() instead</remarks>
        public static uint LibvlcMediaPlayerGetAgl(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcMediaPlayerGetAgl(__arg0);
            return __ret;
        }

        /// <remarks>Use libvlc_track_description_list_release() instead</remarks>
        public static void LibvlcTrackDescriptionRelease(global::libvlcsharp.TrackDescription p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null) ? global::System.IntPtr.Zero : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionRelease(__arg0);
        }

        /// <summary>Get current video height.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel height or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetHeight(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetHeight(__arg0);
            return __ret;
        }

        /// <summary>Get current video width.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel width or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        public static int LibvlcVideoGetWidth(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetWidth(__arg0);
            return __ret;
        }

        /// <summary>Get the description of available titles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available titles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlcsharp.TrackDescription LibvlcVideoGetTitleDescription(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetTitleDescription(__arg0);
            global::libvlcsharp.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get the description of available chapters for specific title.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_title">selected title</param>
        /// <returns>
        /// <para>list containing description of available chapter for title i_title.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        public static global::libvlcsharp.TrackDescription LibvlcVideoGetChapterDescription(global::libvlcsharp.MediaPlayer p_mi, int i_title)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoGetChapterDescription(__arg0, i_title);
            global::libvlcsharp.TrackDescription __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.TrackDescription) global::libvlcsharp.TrackDescription.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.TrackDescription.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Set new video subtitle file.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="psz_subtitle">new video subtitle file</param>
        /// <returns>the success status (boolean)</returns>
        /// <remarks>Use libvlc_media_player_add_slave() instead.</remarks>
        public static int LibvlcVideoSetSubtitleFile(global::libvlcsharp.MediaPlayer p_mi, string psz_subtitle)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcVideoSetSubtitleFile(__arg0, psz_subtitle);
            return __ret;
        }

        /// <summary>Toggle teletext transparent status on video output.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>use libvlc_video_set_teletext() instead.</remarks>
        public static void LibvlcToggleTeletext(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            __Internal.LibvlcToggleTeletext(__arg0);
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always 0.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static int LibvlcAudioOutputDeviceCount(global::libvlcsharp.Instance p_instance, string psz_audio_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceCount(__arg0, psz_audio_output);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceLongname(global::libvlcsharp.Instance p_instance, string psz_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceLongname(__arg0, psz_output, i_device);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceId(global::libvlcsharp.Instance p_instance, string psz_audio_output, int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcAudioOutputDeviceId(__arg0, psz_audio_output, i_device);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        /// <returns>always -1.</returns>
        public static int LibvlcAudioOutputGetDeviceType(global::libvlcsharp.MediaPlayer p_mi)
        {
            var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
            var __ret = __Internal.LibvlcAudioOutputGetDeviceType(__arg0);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        public static void LibvlcAudioOutputSetDeviceType(global::libvlcsharp.MediaPlayer p_mp, int device_type)
        {
            var __arg0 = ReferenceEquals(p_mp, null) ? global::System.IntPtr.Zero : p_mp.__Instance;
            __Internal.LibvlcAudioOutputSetDeviceType(__arg0, device_type);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is synchronous.</para>
        /// <para>This function could block indefinitely.</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse_with_options</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParse(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParse(__arg0);
        }

        /// <summary>Parse a media.</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <remarks>
        /// <para>This fetches (local) art, meta data and tracks information.</para>
        /// <para>The method is the asynchronous of libvlc_media_parse().</para>
        /// <para>To track when this is over you can listen to libvlc_MediaParsedChanged</para>
        /// <para>event. However if the media was already parsed you will not receive this</para>
        /// <para>event.</para>
        /// <para>You can't be sure to receive the libvlc_MediaParsedChanged</para>
        /// <para>event (you can wait indefinitely for this event).</para>
        /// <para>Use libvlc_media_parse_with_options() instead</para>
        /// <para>libvlc_media_parse</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// <para>libvlc_media_get_meta</para>
        /// <para>libvlc_media_get_tracks_info</para>
        /// </remarks>
        public static void LibvlcMediaParseAsync(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            __Internal.LibvlcMediaParseAsync(__arg0);
        }

        /// <summary>Return true is the media descriptor object is parsed</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <returns>true if media object has been parsed otherwise it returns false</returns>
        /// <remarks>
        /// <para>This can return true in case of failure.</para>
        /// <para>Use libvlc_media_get_parsed_status() instead</para>
        /// <para>libvlc_MediaParsedChanged</para>
        /// </remarks>
        public static int LibvlcMediaIsParsed(global::libvlcsharp.Media p_md)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.LibvlcMediaIsParsed(__arg0);
            return __ret;
        }

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>Use libvlc_media_tracks_get() instead</para>
        /// </remarks>
        public static int LibvlcMediaGetTracksInfo(global::libvlcsharp.Media p_md, global::libvlcsharp.MediaTrackInfo tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.__Instance;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaGetTracksInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>@{</summary>
        public static int LibvlcMediaListAddFileContent(global::libvlcsharp.MediaList p_ml, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListAddFileContent(__arg0, psz_uri);
            return __ret;
        }

        /// <remarks>Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start().</remarks>
        public static global::libvlcsharp.MediaDiscoverer LibvlcMediaDiscovererNewFromName(global::libvlcsharp.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererNewFromName(__arg0, psz_name);
            global::libvlcsharp.MediaDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.MediaDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.MediaDiscoverer) global::libvlcsharp.MediaDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.MediaDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media service discover object its localized name.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>localized name or NULL if the media_discoverer is not started</returns>
        /// <remarks>
        /// <para>Useless, use libvlc_media_discoverer_list_get() to get the</para>
        /// <para>longname of the service discovery.</para>
        /// </remarks>
        public static sbyte* LibvlcMediaDiscovererLocalizedName(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererLocalizedName(__arg0);
            return __ret;
        }

        /// <summary>Get event manager from media service discover object.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>event manager object.</returns>
        /// <remarks>
        /// <para>Useless, media_discoverer events are only triggered when calling</para>
        /// <para>libvlc_media_discoverer_start() and libvlc_media_discoverer_stop().</para>
        /// </remarks>
        public static global::libvlcsharp.EventManager LibvlcMediaDiscovererEventManager(global::libvlcsharp.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererEventManager(__arg0);
            global::libvlcsharp.EventManager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.EventManager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.EventManager) global::libvlcsharp.EventManager.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.EventManager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Waits until an interface causes the instance to exit.</para>
        /// <para>You should start at least one interface first, using libvlc_add_intf().</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <remarks>
        /// <para>This function wastes one thread doing basically nothing.</para>
        /// <para>libvlc_set_exit_handler() should be used instead.</para>
        /// </remarks>
        public static void LibvlcWait(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcWait(__arg0);
        }

        /// <summary>
        /// <para>Always returns minus one.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <returns>always -1</returns>
        public static uint LibvlcGetLogVerbosity(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcGetLogVerbosity(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <param name="level">ignored</param>
        public static void LibvlcSetLogVerbosity(global::libvlcsharp.Instance p_instance, uint level)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcSetLogVerbosity(__arg0, level);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>an unique pointer or NULL on error</returns>
        public static global::libvlcsharp.Log LibvlcLogOpen(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            var __ret = __Internal.LibvlcLogOpen(__arg0);
            global::libvlcsharp.Log __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.Log.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.Log) global::libvlcsharp.Log.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.Log.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_open().</summary>
        /// <param name="p_log">libvlc log instance or NULL</param>
        public static void LibvlcLogClose(global::libvlcsharp.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClose(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>always zero</returns>
        public static uint LibvlcLogCount(global::libvlcsharp.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        public static void LibvlcLogClear(global::libvlcsharp.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClear(__arg0);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>an unique pointer or NULL on error or if the parameter was NULL</returns>
        public static global::libvlcsharp.LibvlcLogIteratorT LibvlcLogGetIterator(global::libvlcsharp.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogGetIterator(__arg0);
            global::libvlcsharp.LibvlcLogIteratorT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.LibvlcLogIteratorT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.LibvlcLogIteratorT) global::libvlcsharp.LibvlcLogIteratorT.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.LibvlcLogIteratorT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_get_iterator().</summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        public static void LibvlcLogIteratorFree(global::libvlcsharp.LibvlcLogIteratorT p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            __Internal.LibvlcLogIteratorFree(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">ignored</param>
        /// <returns>always zero</returns>
        public static int LibvlcLogIteratorHasNext(global::libvlcsharp.LibvlcLogIteratorT p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.LibvlcLogIteratorHasNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Always returns NULL.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        /// <param name="p_buf">ignored</param>
        /// <returns>always NULL</returns>
        public static global::libvlcsharp.LibvlcLogMessageT LibvlcLogIteratorNext(global::libvlcsharp.LibvlcLogIteratorT p_iter, global::libvlcsharp.LibvlcLogMessageT p_buf)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __arg1 = ReferenceEquals(p_buf, null) ? global::System.IntPtr.Zero : p_buf.__Instance;
            var __ret = __Internal.LibvlcLogIteratorNext(__arg0, __arg1);
            global::libvlcsharp.LibvlcLogMessageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::libvlcsharp.LibvlcLogMessageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::libvlcsharp.LibvlcLogMessageT) global::libvlcsharp.LibvlcLogMessageT.NativeToManagedMap[__ret];
            else __result0 = global::libvlcsharp.LibvlcLogMessageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start playing (if there is any item in the playlist).</summary>
        /// <param name="p_instance">the playlist instance</param>
        /// <param name="i_id">
        /// <para>the item to play. If this is a negative number, the next</para>
        /// <para>item will be selected. Otherwise, the item with the given ID will be</para>
        /// <para>played</para>
        /// </param>
        /// <param name="i_options">the number of options to add to the item</param>
        /// <param name="ppsz_options">the options to add to the item</param>
        /// <remarks>
        /// <para>Additionnal playlist item options can be specified for addition to the</para>
        /// <para>item before it is played.</para>
        /// </remarks>
        public static void LibvlcPlaylistPlay(global::libvlcsharp.Instance p_instance, int i_id, int i_options, sbyte** ppsz_options)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.__Instance;
            __Internal.LibvlcPlaylistPlay(__arg0, i_id, i_options, ppsz_options);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr _0);
    }
}
