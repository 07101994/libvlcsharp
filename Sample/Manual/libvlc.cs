// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Security;
using System.Text;
using Sample.Manual;

namespace libvlcsharp
{
    /// <summary>Logging messages level.</summary>
    /// <remarks>Future LibVLC versions may define new levels.</remarks>
    public enum LogLevel
    {
        /// <summary>Debug message</summary>
        Debug = 0,
        /// <summary>Important informational message</summary>
        Notice = 2,
        /// <summary>Warning (potential error) message</summary>
        Warning = 3,
        /// <summary>Error message</summary>
        Error = 4
    }

    /// <summary>This structure is opaque. It represents a libvlc instance</summary>
    /// <summary>
    /// <para>Event manager that belongs to a libvlc object, and from whom events can</para>
    /// <para>be received.</para>
    /// </summary>
    /// <summary>Type of a LibVLC event.</summary>
    /// <summary>Callback function notification</summary>
    /// <param name="libvlcEvent">the event triggering the callback</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void LibvlcCallbackT(IntPtr libvlcEvent, IntPtr data);

    public class Instance
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        internal struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_new")]
            internal static extern unsafe IntPtr LibVLCNew(int argc, sbyte** argv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_release")]
            internal static extern void LibVLCRelease(IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_add_intf")]
            internal static extern int LibVLCAddInterface(IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_set_exit_handler")]
            internal static extern void LibVLCSetExitHandler(IntPtr instance, IntPtr cb, IntPtr opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_set_user_agent")]
            internal static extern void LibVLCSetUserAgent(IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name, 
                [MarshalAs(UnmanagedType.LPStr)] string http);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_set_app_id")]
            internal static extern void LibVLCSetAppId(IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string id, 
                [MarshalAs(UnmanagedType.LPStr)] string version, [MarshalAs(UnmanagedType.LPStr)] string icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_unset")]
            internal static extern void LibVLCLogUnset(IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_set_file")]
            internal static extern void LibVLCLogSetFile(IntPtr instance, IntPtr stream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_filter_list_get")]
            internal static extern IntPtr LibVLCAudioFilterListGet(IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_video_filter_list_get")]
            internal static extern IntPtr LibVLCVideoFilterListGet(IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_list_get")]
            internal static extern IntPtr LibVLCAudioOutputListGet(IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_device_list_get")]
            internal static extern IntPtr LibVLCAudioOutputDeviceListGet(IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string aout);

        }

        public IntPtr NativeReference { get; protected set; }

        internal static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Instance> NativeToManagedMap 
            = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Instance>();

        protected bool __ownsNativeInstance;

        /// <summary>
        /// <para>Create and initialize a libvlc instance.</para>
        /// <para>This functions accept a list of &quot;command line&quot; arguments similar to the</para>
        /// <para>main(). These arguments affect the LibVLC instance default configuration.</para>
        /// </summary>
        /// <param name="argc">the number of arguments (should be 0)</param>
        /// <param name="args">list of arguments (should be NULL)</param>
        /// <returns>the libvlc instance or NULL in case of error</returns>
        /// <remarks>
        /// <para>LibVLC may create threads. Therefore, any thread-unsafe process</para>
        /// <para>initialization must be performed before calling libvlc_new(). In particular</para>
        /// <para>and where applicable:</para>
        /// <para>- setlocale() and textdomain(),</para>
        /// <para>- setenv(), unsetenv() and putenv(),</para>
        /// <para>- with the X11 display system, XInitThreads()</para>
        /// <para>(see also libvlc_media_player_set_xwindow()) and</para>
        /// <para>- on Microsoft Windows, SetErrorMode().</para>
        /// <para>- sigprocmask() shall never be invoked; pthread_sigmask() can be used.</para>
        /// <para>On POSIX systems, the SIGCHLD signalmust notbe ignored, i.e. the</para>
        /// <para>signal handler must set to SIG_DFL or a function pointer, not SIG_IGN.</para>
        /// <para>Also while LibVLC is active, the wait() function shall not be called, and</para>
        /// <para>any call to waitpid() shall use a strictly positive value for the first</para>
        /// <para>parameter (i.e. the PID). Failure to follow those rules may lead to a</para>
        /// <para>deadlock or a busy loop.</para>
        /// <para>Also on POSIX systems, it is recommended that the SIGPIPE signal be blocked,</para>
        /// <para>even if it is not, in principles, necessary, e.g.:</para>
        /// <para>On Microsoft Windows Vista/2008, the process error mode</para>
        /// <para>SEM_FAILCRITICALERRORS flagmustbe set before using LibVLC.</para>
        /// <para>On later versions, that is optional and unnecessary.</para>
        /// <para>Also on Microsoft Windows (Vista and any later version), setting the default</para>
        /// <para>DLL directories to SYSTEM32 exclusively is strongly recommended for</para>
        /// <para>security reasons:</para>
        /// <para>Arguments are meant to be passed from the command line to LibVLC, just like</para>
        /// <para>VLC media player does. The list of valid arguments depends on the LibVLC</para>
        /// <para>version, the operating system and platform, and set of available LibVLC</para>
        /// <para>plugins. Invalid or unsupported arguments will cause the function to fail</para>
        /// <para>(i.e. return NULL). Also, some arguments may alter the behaviour or</para>
        /// <para>otherwise interfere with other LibVLC functions.</para>
        /// <para>There is absolutely no warranty or promise of forward, backward and</para>
        /// <para>cross-platform compatibility with regards to libvlc_new() arguments.</para>
        /// <para>We recommend that you do not use them, other than when debugging.</para>
        /// </remarks>
        public Instance(int argc, string[] args)
        {         
            unsafe
            {
                if (args == null || !args.Any())
                    NativeReference = Internal.LibVLCNew(argc, null);
                else
                {

                    fixed (byte* arg0 = Encoding.ASCII.GetBytes(args[0]),
                        arg1 = Encoding.ASCII.GetBytes(args[1]),
                        arg2 = Encoding.ASCII.GetBytes(args[2]))
                    {
                        sbyte*[] arr = { (sbyte*)arg0, (sbyte*)arg1, (sbyte*)arg2 };
                        fixed (sbyte** argv = arr)
                        {
                            NativeReference = Internal.LibVLCNew(argc, argv);
                        }
                    }
                }
            }

            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        /// <para>Decrement the reference count of a libvlc instance, and destroy it</para>
        /// <para>if it reaches zero.</para>
        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (NativeReference == IntPtr.Zero)
                return;

            Internal.LibVLCRelease(NativeReference);
            
            NativeToManagedMap.TryRemove(NativeReference, out var dummy);
            NativeReference = IntPtr.Zero;
        }
        
        public static bool operator ==(Instance obj1, Instance obj2)
        {
            return obj1?.NativeReference == obj2?.NativeReference;
        }

        public static bool operator !=(Instance obj1, Instance obj2)
        {
            return obj1?.NativeReference != obj2?.NativeReference;
        }

        /**
         * Try to start a user interface for the libvlc instance.
         *
         * \param name  interface name, or empty string for default
        */
        public bool AddInterface(string name)
        {
            return Internal.LibVLCAddInterface(NativeReference, name ?? string.Empty) == 0;
        }
        
        /// <summary>
        /// <para>Registers a callback for the LibVLC exit event. This is mostly useful if</para>
        /// <para>the VLC playlist and/or at least one interface are started with</para>
        /// <para>libvlc_playlist_play() or libvlc_add_intf() respectively.</para>
        /// <para>Typically, this function will wake up your application main loop (from</para>
        /// <para>another thread).</para>
        /// </summary>
        /// <param name="cb">
        /// <para>callback to invoke when LibVLC wants to exit,</para>
        /// <para>or NULL to disable the exit handler (as by default)</para>
        /// </param>
        /// <param name="opaque">data pointer for the callback</param>
        /// <remarks>
        /// <para>This function should be called before the playlist or interface are</para>
        /// <para>started. Otherwise, there is a small race condition: the exit event could</para>
        /// <para>be raised before the handler is registered.</para>
        /// <para>This function and libvlc_wait() cannot be used at the same time.</para>
        /// </remarks>
        public void SetExitHandler(Delegates.Action_IntPtr cb, IntPtr opaque)
        {
            var cbFunctionPointer = cb == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            Internal.LibVLCSetExitHandler(NativeReference, cbFunctionPointer, opaque);
        }
        
        /// <summary>
        /// <para>Sets the application name. LibVLC passes this as the user agent string</para>
        /// <para>when a protocol requires it.</para>
        /// </summary>
        /// <param name="name">human-readable application name, e.g. &quot;FooBar player 1.2.3&quot;</param>
        /// <param name="http">HTTP User Agent, e.g. &quot;FooBar/1.2.3 Python/2.6.0&quot;</param>
        /// <remarks>LibVLC 1.1.1 or later</remarks>
        public void SetUserAgent(string name, string http)
        {
            Internal.LibVLCSetUserAgent(NativeReference, name, http);
        }

        /// <summary>
        /// <para>Sets some meta-information about the application.</para>
        /// <para>See also libvlc_set_user_agent().</para>
        /// </summary>
        /// <param name="id">Java-style application identifier, e.g. &quot;com.acme.foobar&quot;</param>
        /// <param name="version">application version numbers, e.g. &quot;1.2.3&quot;</param>
        /// <param name="icon">application icon name, e.g. &quot;foobar&quot;</param>
        /// <remarks>LibVLC 2.1.0 or later.</remarks>
        public void SetAppId(string id, string version, string icon)
        {
            Internal.LibVLCSetAppId(NativeReference, id, version, icon);
        }

        /// <summary>Unsets the logging callback.</summary>
        /// <remarks>
        /// <para>This function deregisters the logging callback for a LibVLC instance.</para>
        /// <para>This is rarely needed as the callback is implicitly unset when the instance</para>
        /// <para>is destroyed.</para>
        /// <para>This function will wait for any pending callbacks invocation to</para>
        /// <para>complete (causing a deadlock if called from within the callback).</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public  void UnsetLog()
        {
            Internal.LibVLCLogUnset(NativeReference);
        }

        //TODO: void logSet(LogCb&& logCb)

        /// <summary>Sets up logging to a file.</summary>
        /// <param name="stream">
        /// <para>FILE pointer opened for writing</para>
        /// <para>(the FILE pointer must remain valid until libvlc_log_unset())</para>
        /// </param>
        /// <remarks>LibVLC 2.1.0 or later</remarks>
        public void SetLogFile(IntPtr stream)
        {
            Internal.LibVLCLogSetFile(NativeReference, stream);
        }

        /// <summary>Returns a list of audio filters that are available.</summary>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public IEnumerable<ModuleDescription> AudioFilters
        {
            get
            {
                return Retrieve(
                    () => Marshal.PtrToStructure<ModuleDescription.Internal>(
                        Internal.LibVLCAudioFilterListGet(NativeReference)),
                    intern => ModuleDescription.__CreateInstance(intern),
                    module => module.PNext);
            }
        }

        private IEnumerable<TU> Retrieve<T, TU>(Func<T> retrieve, Func<T, TU> create, Func<TU, TU> next)
        {
            var structure = retrieve();
            //if (ptr == IntPtr.Zero) return Enumerable.Empty<T>();

            var obj = create(structure);

            var resultList = new List<TU>();
            while (obj != null)
            {
                resultList.Add(obj);
                obj = next(obj);
            }
            return resultList;
        }


        /// <summary>Returns a list of video filters that are available.</summary>
        /// <returns>
        /// <para>a list of module descriptions. It should be freed with libvlc_module_description_list_release().</para>
        /// <para>In case of an error, NULL is returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_module_description_t</para>
        /// <para>libvlc_module_description_list_release</para>
        /// </remarks>
        public IEnumerable<ModuleDescription> VideoFilters
        {
            get
            {
                return Retrieve(
                    () => Marshal.PtrToStructure<ModuleDescription.Internal>(
                        Internal.LibVLCVideoFilterListGet(NativeReference)),
                    intern => ModuleDescription.__CreateInstance(intern),
                    module => module.PNext);

                //return Retrieve(() => Internal.LibVLCVideoFilterListGet(NativeReference), 
                //    ptr => ModuleDescription.NativeToManagedMap.ContainsKey(ptr) ?
                //            ModuleDescription.NativeToManagedMap[ptr] : ModuleDescription.__CreateInstance(ptr),
                //    module => module.PNext);
            }
        }

        /// <summary>Gets the list of available audio output modules.</summary>
        /// <returns>list of available audio outputs. It must be freed with</returns>
        /// <remarks>
        /// <para>libvlc_audio_output_list_release</para>
        /// <para>libvlc_audio_output_t .</para>
        /// <para>In case of error, NULL is returned.</para>
        /// </remarks>
        public IEnumerable<AudioOutputDescription> AudioOutputs
        {
            get
            {
                return Retrieve(
                    () => Marshal.PtrToStructure<AudioOutputDescription.Internal>(
                        Internal.LibVLCAudioOutputListGet(NativeReference)),
                    intern => AudioOutputDescription.__CreateInstance(intern),
                    module => module.PNext);

                //return Retrieve(() => Internal.LibVLCAudioOutputListGet(NativeReference),
                //    ptr => AudioOutputDescription.NativeToManagedMap.ContainsKey(ptr) ?
                //        AudioOutputDescription.NativeToManagedMap[ptr] : AudioOutputDescription.__CreateInstance(ptr),
                //    audioOutput => audioOutput.PNext);
            }
        }

        /// <summary>Gets a list of audio output devices for a given audio output module,</summary>
        /// <param name="audioOutputName">
        /// <para>audio output name</para>
        /// <para>(as returned by libvlc_audio_output_list_get())</para>
        /// </param>
        /// <returns>
        /// <para>A NULL-terminated linked list of potential audio output devices.</para>
        /// <para>It must be freed with libvlc_audio_output_device_list_release()</para>
        /// </returns>
        /// <remarks>
        /// <para>libvlc_audio_output_device_set().</para>
        /// <para>Not all audio outputs support this. In particular, an empty (NULL)</para>
        /// <para>list of devices doesnotimply that the specified audio output does</para>
        /// <para>not work.</para>
        /// <para>The list might not be exhaustive.</para>
        /// <para>Some audio output devices in the list might not actually work in</para>
        /// <para>some circumstances. By default, it is recommended to not specify any</para>
        /// <para>explicit audio device.</para>
        /// <para>LibVLC 2.1.0 or later.</para>
        /// </remarks>
        public IEnumerable<AudioOutputDevice> AudioOutputDevices(string audioOutputName)
        {
            return Retrieve(
                () => Marshal.PtrToStructure<AudioOutputDevice.Internal>(
                    Internal.LibVLCAudioOutputDeviceListGet(NativeReference, audioOutputName)),
                intern => AudioOutputDevice.__CreateInstance(intern),
                module => module.PNext);

            //return Retrieve(() => Internal.LibVLCAudioOutputDeviceListGet(NativeReference, audioOutputName),
            //    ptr => AudioOutputDevice.NativeToManagedMap.ContainsKey(ptr)
            //        ? AudioOutputDevice.NativeToManagedMap[ptr]
            //        : AudioOutputDevice.__CreateInstance(ptr),
            //    audioOutputDevice => audioOutputDevice.PNext);
        }
        
        

        public void SetDialogHandlers()
        {
            
        }
    }

    public unsafe partial class EventManager
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.EventManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.EventManager>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.EventManager __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.EventManager(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.EventManager __CreateInstance(global::libvlcsharp.EventManager.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.EventManager(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.EventManager.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.EventManager.__Internal));
            *(global::libvlcsharp.EventManager.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private EventManager(global::libvlcsharp.EventManager.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Log
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Log(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.Log __CreateInstance(global::libvlcsharp.Log.__Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.Log.__Internal));
            *(global::libvlcsharp.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::libvlcsharp.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Description of a module.</summary>
    public unsafe partial class ModuleDescription : IDisposable
    {
        //[StructLayout(LayoutKind.Explicit, Size = 40)]
        [StructLayout(LayoutKind.Sequential)]
        public partial struct Internal
        {
            //[FieldOffset(0)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_name;

            //[FieldOffset(8)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_shortname;

            //[FieldOffset(16)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_longname;

            //[FieldOffset(24)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_help;

            //[FieldOffset(32)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr p_next;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_module_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "libvlc_module_description_list_release")]
            internal static extern void LibVLCModuleDescriptionListRelease(IntPtr moduleDescriptionList);
        }

        public IntPtr NativeReference { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ModuleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::libvlcsharp.ModuleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::libvlcsharp.ModuleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ModuleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::libvlcsharp.ModuleDescription __CreateInstance(global::libvlcsharp.ModuleDescription.Internal native, bool skipVTables = false)
        {
            return new global::libvlcsharp.ModuleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::libvlcsharp.ModuleDescription.Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.Internal));
            *(global::libvlcsharp.ModuleDescription.Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleDescription(global::libvlcsharp.ModuleDescription.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        private void ModuleDescriptionListRelease()
        {
            Internal.LibVLCModuleDescriptionListRelease(NativeReference);
        }

        protected ModuleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            NativeReference = new global::System.IntPtr(native);
        }

        public ModuleDescription()
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        public ModuleDescription(global::libvlcsharp.ModuleDescription _0)
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::libvlcsharp.ModuleDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
            *((global::libvlcsharp.ModuleDescription.Internal*) NativeReference) = *((global::libvlcsharp.ModuleDescription.Internal*) _0.NativeReference);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (NativeReference == IntPtr.Zero)
                return;


            NativeToManagedMap.TryRemove(NativeReference, out var dummy);

            ModuleDescriptionListRelease();

            NativeReference = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*)((global::libvlcsharp.ModuleDescription.Internal*)NativeReference)->psz_name;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_name = (global::System.IntPtr) value;
            }
        }

        public string Name => new String(PszName);

        public sbyte* PszShortname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_shortname;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_shortname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_longname;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_longname = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszHelp
        {
            get
            {
                return (sbyte*) ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_help;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->psz_help = (global::System.IntPtr) value;
            }
        }

        public global::libvlcsharp.ModuleDescription PNext
        {
            get
            {
                global::libvlcsharp.ModuleDescription __result0;
                //Internal.
                if (((global::libvlcsharp.ModuleDescription.Internal*)NativeReference)->p_next == IntPtr.Zero) __result0 = null;
                else if (NativeToManagedMap.ContainsKey(((Internal*) NativeReference)->p_next))
                    __result0 = NativeToManagedMap[((Internal*) NativeReference)->p_next];
                else __result0 = __CreateInstance(((Internal*) NativeReference)->p_next);
                return __result0;
            }

            set
            {
                ((global::libvlcsharp.ModuleDescription.Internal*) NativeReference)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.NativeReference;
            }
        }
    }

    public unsafe partial class libvlc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_errmsg")]
            internal static extern global::System.IntPtr LibvlcErrmsg();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clearerr")]
            internal static extern void LibvlcClearerr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_printerr")]
            internal static extern global::System.IntPtr LibvlcPrinterr([MarshalAs(UnmanagedType.LPStr)] string fmt);

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_retain")]
            internal static extern void LibvlcRetain(global::System.IntPtr p_instance);

           
            
          
          
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_version")]
            internal static extern global::System.IntPtr LibvlcGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_compiler")]
            internal static extern global::System.IntPtr LibvlcGetCompiler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_changeset")]
            internal static extern global::System.IntPtr LibvlcGetChangeset();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_free")]
            internal static extern void LibvlcFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_attach")]
            internal static extern int LibvlcEventAttach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_detach")]
            internal static extern void LibvlcEventDetach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr p_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_type_name")]
            internal static extern global::System.IntPtr LibvlcEventTypeName(int event_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_context")]
            internal static extern void LibvlcLogGetContext(global::System.IntPtr ctx, sbyte** module, sbyte** file, uint* line);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_object")]
            internal static extern void LibvlcLogGetObject(global::System.IntPtr ctx, sbyte** name, sbyte** header, ulong* id);

        

          

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clock")]
            internal static extern long LibvlcClock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?libvlc_delay@@YA_J_J@Z")]
            internal static extern long LibvlcDelay(long pts);
        }

        /// <summary>
        /// <para>A human-readable error message for the last LibVLC error in the calling</para>
        /// <para>thread. The resulting string is valid until another error occurs (at least</para>
        /// <para>until the next LibVLC call).</para>
        /// </summary>
        /// <remarks>This will be NULL if there was no error.</remarks>
        public static string LibvlcErrmsg()
        {
            var __ret = __Internal.LibvlcErrmsg();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Clears the LibVLC error status for the current thread. This is optional.</para>
        /// <para>By default, the error status is automatically overridden when a new error</para>
        /// <para>occurs, and destroyed when the thread exits.</para>
        /// </summary>
        public static void LibvlcClearerr()
        {
            __Internal.LibvlcClearerr();
        }

        /// <summary>
        /// <para>Sets the LibVLC error status and message for the current thread.</para>
        /// <para>Any previous error is overridden.</para>
        /// </summary>
        /// <param name="fmt">the format string</param>
        /// <param name="args">the arguments</param>
        /// <returns>a nul terminated string in any case</returns>
        public static string LibvlcPrinterr(string fmt)
        {
            var __ret = __Internal.LibvlcPrinterr(fmt);
            return Marshal.PtrToStringAnsi(__ret);
        }

        

        /// <summary>
        /// <para>Increments the reference count of a libvlc instance.</para>
        /// <para>The initial reference count is 1 after libvlc_new() returns.</para>
        /// </summary>
        /// <param name="p_instance">the instance to reference</param>
        public static void LibvlcRetain(global::libvlcsharp.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            __Internal.LibvlcRetain(__arg0);
        }

        

       

       

        
        /// <summary>Retrieve libvlc version.</summary>
        /// <returns>a string containing the libvlc version</returns>
        /// <remarks>Example: &quot;1.1.0-git The Luggage&quot;</remarks>
        public static string LibvlcGetVersion()
        {
            var __ret = __Internal.LibvlcGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc compiler version.</summary>
        /// <returns>a string containing the libvlc compiler version</returns>
        /// <remarks>Example: &quot;gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)&quot;</remarks>
        public static string LibvlcGetCompiler()
        {
            var __ret = __Internal.LibvlcGetCompiler();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc changeset.</summary>
        /// <returns>a string containing the libvlc changeset</returns>
        /// <remarks>Example: &quot;aa9bce0bc4&quot;</remarks>
        public static string LibvlcGetChangeset()
        {
            var __ret = __Internal.LibvlcGetChangeset();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Frees an heap allocation returned by a LibVLC function.</para>
        /// <para>If you know you're using the same underlying C run-time as the LibVLC</para>
        /// <para>implementation, then you can call ANSI C free() directly instead.</para>
        /// </summary>
        /// <param name="ptr">the pointer</param>
        public static void LibvlcFree(global::System.IntPtr ptr)
        {
            __Internal.LibvlcFree(ptr);
        }

        /// <summary>Register for an event notification.</summary>
        /// <param name="p_event_manager">
        /// <para>the event manager to which you want to attach to.</para>
        /// <para>Generally it is obtained by vlc_my_object_event_manager() where</para>
        /// <para>my_object is the object you want to listen to.</para>
        /// </param>
        /// <param name="i_event_type">the desired event to which we want to listen</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="user_data">user provided data to carry with the event</param>
        /// <returns>0 on success, ENOMEM on error</returns>
        public static int LibvlcEventAttach(global::libvlcsharp.EventManager p_event_manager, int i_event_type, global::libvlcsharp.LibvlcCallbackT f_callback, global::System.IntPtr user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            var __ret = __Internal.LibvlcEventAttach(__arg0, i_event_type, __arg2, user_data);
            return __ret;
        }

        /// <summary>Unregister an event notification.</summary>
        /// <param name="p_event_manager">the event manager</param>
        /// <param name="i_event_type">the desired event to which we want to unregister</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="p_user_data">user provided data to carry with the event</param>
        public static void LibvlcEventDetach(global::libvlcsharp.EventManager p_event_manager, int i_event_type, global::libvlcsharp.LibvlcCallbackT f_callback, global::System.IntPtr p_user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            __Internal.LibvlcEventDetach(__arg0, i_event_type, __arg2, p_user_data);
        }

        /// <summary>Get an event's type name.</summary>
        /// <param name="event_type">the desired event</param>
        public static string LibvlcEventTypeName(int event_type)
        {
            var __ret = __Internal.LibvlcEventTypeName(event_type);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Gets log message debug infos.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="module">module name storage (or NULL) [OUT]</param>
        /// <param name="file">source code file name storage (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves self-debug information about a log message:</para>
        /// <para>- the name of the VLC module emitting the message,</para>
        /// <para>- the name of the source code module (i.e. file) and</para>
        /// <para>- the line number within the source code module.</para>
        /// <para>The returned module name and file name will be NULL if unknown.</para>
        /// <para>The returned line number will similarly be zero if unknown.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetContext(global::libvlcsharp.Log ctx, sbyte** module, sbyte** file, ref uint line)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (uint* __refParamPtr3 = &line)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetContext(__arg0, module, file, __arg3);
            }
        }

        /// <summary>Gets log message info.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="name">object name storage (or NULL) [OUT]</param>
        /// <param name="header">object header (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves meta-information about a log message:</para>
        /// <para>- the type name of the VLC object emitting the message,</para>
        /// <para>- the object header if any, and</para>
        /// <para>- a temporaly-unique object identifier.</para>
        /// <para>This information is mainly meant formanualtroubleshooting.</para>
        /// <para>The returned type name may be &quot;generic&quot; if unknown, but it cannot be NULL.</para>
        /// <para>The returned header will be NULL if unset; in current versions, the header</para>
        /// <para>is used to distinguish for VLM inputs.</para>
        /// <para>The returned object ID will be zero if the message is not associated with</para>
        /// <para>any VLC object.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetObject(global::libvlcsharp.Log ctx, sbyte** name, sbyte** header, ref ulong id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __refParamPtr3 = &id)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetObject(__arg0, name, header, __arg3);
            }
        }

       

      

       

       

      

        /// <summary>
        /// <para>Return the current time as defined by LibVLC. The unit is the microsecond.</para>
        /// <para>Time increases monotonically (regardless of time zone changes and RTC</para>
        /// <para>adjustements).</para>
        /// <para>The origin is arbitrary but consistent across the whole system</para>
        /// <para>(e.g. the system uptim, the time since the system was booted).</para>
        /// </summary>
        /// <remarks>On systems that support it, the POSIX monotonic clock is used.</remarks>
        public static long LibvlcClock()
        {
            var __ret = __Internal.LibvlcClock();
            return __ret;
        }

        /// <summary>Return the delay (in microseconds) until a certain timestamp.</summary>
        /// <param name="pts">timestamp</param>
        /// <returns>
        /// <para>negative if timestamp is in the past,</para>
        /// <para>positive if it is in the future</para>
        /// </returns>
        public static long LibvlcDelay(long pts)
        {
            var __ret = __Internal.LibvlcDelay(pts);
            return __ret;
        }
    }
}
