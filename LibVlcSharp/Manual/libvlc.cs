// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>Logging messages level.</summary>
    /// <remarks>Future LibVLC versions may define new levels.</remarks>
    public enum LogLevel
    {
        /// <summary>Debug message</summary>
        Debug = 0,
        /// <summary>Important informational message</summary>
        Notice = 2,
        /// <summary>Warning (potential error) message</summary>
        Warning = 3,
        /// <summary>Error message</summary>
        Error = 4
    }

    /// <summary>This structure is opaque. It represents a libvlc instance</summary>
    /// <summary>
    /// <para>Event manager that belongs to a libvlc object, and from whom events can</para>
    /// <para>be received.</para>
    /// </summary>
    /// <summary>Type of a LibVLC event.</summary>
    /// <summary>Callback function notification</summary>
    /// <param name="libvlcEvent">the event triggering the callback</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void LibvlcCallbackT(IntPtr libvlcEvent, IntPtr data);

    public unsafe partial class EventManager
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.EventManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.EventManager>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.EventManager __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.EventManager(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.EventManager __CreateInstance(global::VideoLAN.LibVLC.EventManager.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.EventManager(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.EventManager.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.EventManager.__Internal));
            *(global::VideoLAN.LibVLC.EventManager.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private EventManager(global::VideoLAN.LibVLC.EventManager.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Log
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Log(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.Log __CreateInstance(global::VideoLAN.LibVLC.Log.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.Log.__Internal));
            *(global::VideoLAN.LibVLC.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::VideoLAN.LibVLC.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Description of a module.</summary>
    public unsafe partial class ModuleDescription : IDisposable
    {
        //[StructLayout(LayoutKind.Explicit, Size = 40)]
        [StructLayout(LayoutKind.Sequential)]
        public partial struct Internal
        {
            //[FieldOffset(0)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_name;

            //[FieldOffset(8)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_shortname;

            //[FieldOffset(16)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_longname;

            //[FieldOffset(24)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr psz_help;

            //[FieldOffset(32)]
            //[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utf8StringMarshaler))]
            internal IntPtr p_next;

            //[SuppressUnmanagedCodeSecurity]
            //[DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            //    EntryPoint="??0libvlc_module_description_t@@QEAA@AEBU0@@Z")]
            //internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

           
        }

        public IntPtr NativeReference { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ModuleDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.ModuleDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.ModuleDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ModuleDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.ModuleDescription __CreateInstance(global::VideoLAN.LibVLC.ModuleDescription.Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.ModuleDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.ModuleDescription.Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.Internal));
            *(global::VideoLAN.LibVLC.ModuleDescription.Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleDescription(global::VideoLAN.LibVLC.ModuleDescription.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }
        
        protected ModuleDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            NativeReference = new global::System.IntPtr(native);
        }

        public ModuleDescription()
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
        }

        public ModuleDescription(global::VideoLAN.LibVLC.ModuleDescription _0)
        {
            NativeReference = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.ModuleDescription.Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[NativeReference] = this;
            *((global::VideoLAN.LibVLC.ModuleDescription.Internal*) NativeReference) = *((global::VideoLAN.LibVLC.ModuleDescription.Internal*) _0.NativeReference);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (NativeReference == IntPtr.Zero)
                return;


            NativeToManagedMap.TryRemove(NativeReference, out var dummy);


            NativeReference = IntPtr.Zero;
        }

        public string Name => Marshal.PtrToStringAnsi(((Internal*)NativeReference)->psz_name);

        public string Shortname => Marshal.PtrToStringAnsi(((Internal*)NativeReference)->psz_shortname);

        public string Longname => Marshal.PtrToStringAnsi(((Internal*)NativeReference)->psz_longname);
      
        public string Help => Marshal.PtrToStringAnsi(((Internal*)NativeReference)->psz_help);
      
        public ModuleDescription Next
        {
            get
            {
                global::VideoLAN.LibVLC.ModuleDescription __result0;
                if (((global::VideoLAN.LibVLC.ModuleDescription.Internal*)NativeReference)->p_next == IntPtr.Zero) __result0 = null;
                else if (NativeToManagedMap.ContainsKey(((Internal*) NativeReference)->p_next))
                    __result0 = NativeToManagedMap[((Internal*) NativeReference)->p_next];
                else __result0 = __CreateInstance(((Internal*) NativeReference)->p_next);
                return __result0;
            }

            set
            {
                ((global::VideoLAN.LibVLC.ModuleDescription.Internal*) NativeReference)->p_next = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.NativeReference;
            }
        }
    }

    public unsafe partial class libvlc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_errmsg")]
            internal static extern global::System.IntPtr LibvlcErrmsg();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clearerr")]
            internal static extern void LibvlcClearerr();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_printerr")]
            internal static extern global::System.IntPtr LibvlcPrinterr([MarshalAs(UnmanagedType.LPStr)] string fmt);

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_retain")]
            internal static extern void LibvlcRetain(global::System.IntPtr p_instance);

           
            
          
          
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_version")]
            internal static extern global::System.IntPtr LibvlcGetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_compiler")]
            internal static extern global::System.IntPtr LibvlcGetCompiler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_get_changeset")]
            internal static extern global::System.IntPtr LibvlcGetChangeset();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_free")]
            internal static extern void LibvlcFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_attach")]
            internal static extern int LibvlcEventAttach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_detach")]
            internal static extern void LibvlcEventDetach(global::System.IntPtr p_event_manager, int i_event_type, global::System.IntPtr f_callback, global::System.IntPtr p_user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_event_type_name")]
            internal static extern global::System.IntPtr LibvlcEventTypeName(int event_type);

        
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_log_get_object")]
            internal static extern void LibvlcLogGetObject(global::System.IntPtr ctx, sbyte** name, sbyte** header, ulong* id);

        

          

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_clock")]
            internal static extern long LibvlcClock();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?libvlc_delay@@YA_J_J@Z")]
            internal static extern long LibvlcDelay(long pts);
        }

        /// <summary>
        /// <para>A human-readable error message for the last LibVLC error in the calling</para>
        /// <para>thread. The resulting string is valid until another error occurs (at least</para>
        /// <para>until the next LibVLC call).</para>
        /// </summary>
        /// <remarks>This will be NULL if there was no error.</remarks>
        public static string LibvlcErrmsg()
        {
            var __ret = __Internal.LibvlcErrmsg();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Clears the LibVLC error status for the current thread. This is optional.</para>
        /// <para>By default, the error status is automatically overridden when a new error</para>
        /// <para>occurs, and destroyed when the thread exits.</para>
        /// </summary>
        public static void LibvlcClearerr()
        {
            __Internal.LibvlcClearerr();
        }

        /// <summary>
        /// <para>Sets the LibVLC error status and message for the current thread.</para>
        /// <para>Any previous error is overridden.</para>
        /// </summary>
        /// <param name="fmt">the format string</param>
        /// <param name="args">the arguments</param>
        /// <returns>a nul terminated string in any case</returns>
        public static string LibvlcPrinterr(string fmt)
        {
            var __ret = __Internal.LibvlcPrinterr(fmt);
            return Marshal.PtrToStringAnsi(__ret);
        }

        

        /// <summary>
        /// <para>Increments the reference count of a libvlc instance.</para>
        /// <para>The initial reference count is 1 after libvlc_new() returns.</para>
        /// </summary>
        /// <param name="p_instance">the instance to reference</param>
        public static void LibvlcRetain(global::VideoLAN.LibVLC.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            __Internal.LibvlcRetain(__arg0);
        }

        

       

       

        
        /// <summary>Retrieve libvlc version.</summary>
        /// <returns>a string containing the libvlc version</returns>
        /// <remarks>Example: &quot;1.1.0-git The Luggage&quot;</remarks>
        public static string LibvlcGetVersion()
        {
            var __ret = __Internal.LibvlcGetVersion();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc compiler version.</summary>
        /// <returns>a string containing the libvlc compiler version</returns>
        /// <remarks>Example: &quot;gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)&quot;</remarks>
        public static string LibvlcGetCompiler()
        {
            var __ret = __Internal.LibvlcGetCompiler();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Retrieve libvlc changeset.</summary>
        /// <returns>a string containing the libvlc changeset</returns>
        /// <remarks>Example: &quot;aa9bce0bc4&quot;</remarks>
        public static string LibvlcGetChangeset()
        {
            var __ret = __Internal.LibvlcGetChangeset();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Frees an heap allocation returned by a LibVLC function.</para>
        /// <para>If you know you're using the same underlying C run-time as the LibVLC</para>
        /// <para>implementation, then you can call ANSI C free() directly instead.</para>
        /// </summary>
        /// <param name="ptr">the pointer</param>
        public static void LibvlcFree(global::System.IntPtr ptr)
        {
            __Internal.LibvlcFree(ptr);
        }

        /// <summary>Register for an event notification.</summary>
        /// <param name="p_event_manager">
        /// <para>the event manager to which you want to attach to.</para>
        /// <para>Generally it is obtained by vlc_my_object_event_manager() where</para>
        /// <para>my_object is the object you want to listen to.</para>
        /// </param>
        /// <param name="i_event_type">the desired event to which we want to listen</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="user_data">user provided data to carry with the event</param>
        /// <returns>0 on success, ENOMEM on error</returns>
        public static int LibvlcEventAttach(global::VideoLAN.LibVLC.EventManager p_event_manager, int i_event_type, global::VideoLAN.LibVLC.LibvlcCallbackT f_callback, global::System.IntPtr user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            var __ret = __Internal.LibvlcEventAttach(__arg0, i_event_type, __arg2, user_data);
            return __ret;
        }

        /// <summary>Unregister an event notification.</summary>
        /// <param name="p_event_manager">the event manager</param>
        /// <param name="i_event_type">the desired event to which we want to unregister</param>
        /// <param name="f_callback">the function to call when i_event_type occurs</param>
        /// <param name="p_user_data">user provided data to carry with the event</param>
        public static void LibvlcEventDetach(global::VideoLAN.LibVLC.EventManager p_event_manager, int i_event_type, global::VideoLAN.LibVLC.LibvlcCallbackT f_callback, global::System.IntPtr p_user_data)
        {
            var __arg0 = ReferenceEquals(p_event_manager, null) ? global::System.IntPtr.Zero : p_event_manager.__Instance;
            var __arg2 = f_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(f_callback);
            __Internal.LibvlcEventDetach(__arg0, i_event_type, __arg2, p_user_data);
        }

        /// <summary>Get an event's type name.</summary>
        /// <param name="event_type">the desired event</param>
        public static string LibvlcEventTypeName(int event_type)
        {
            var __ret = __Internal.LibvlcEventTypeName(event_type);
            return Marshal.PtrToStringAnsi(__ret);
        }


        /// <summary>Gets log message info.</summary>
        /// <param name="ctx">message context (as passed to the</param>
        /// <param name="name">object name storage (or NULL) [OUT]</param>
        /// <param name="header">object header (or NULL) [OUT]</param>
        /// <param name="line">source code file line number storage (or NULL) [OUT]</param>
        /// <remarks>
        /// <para>This function retrieves meta-information about a log message:</para>
        /// <para>- the type name of the VLC object emitting the message,</para>
        /// <para>- the object header if any, and</para>
        /// <para>- a temporaly-unique object identifier.</para>
        /// <para>This information is mainly meant formanualtroubleshooting.</para>
        /// <para>The returned type name may be &quot;generic&quot; if unknown, but it cannot be NULL.</para>
        /// <para>The returned header will be NULL if unset; in current versions, the header</para>
        /// <para>is used to distinguish for VLM inputs.</para>
        /// <para>The returned object ID will be zero if the message is not associated with</para>
        /// <para>any VLC object.</para>
        /// <para>The returned module name and source code file name, if non-NULL,</para>
        /// <para>are only valid until the logging callback returns.</para>
        /// <para>LibVLC 2.1.0 or later</para>
        /// </remarks>
        public static void LibvlcLogGetObject(global::VideoLAN.LibVLC.Log ctx, sbyte** name, sbyte** header, ref ulong id)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            fixed (ulong* __refParamPtr3 = &id)
            {
                var __arg3 = __refParamPtr3;
                __Internal.LibvlcLogGetObject(__arg0, name, header, __arg3);
            }
        }

       

      

       

       

      

        /// <summary>
        /// <para>Return the current time as defined by LibVLC. The unit is the microsecond.</para>
        /// <para>Time increases monotonically (regardless of time zone changes and RTC</para>
        /// <para>adjustements).</para>
        /// <para>The origin is arbitrary but consistent across the whole system</para>
        /// <para>(e.g. the system uptim, the time since the system was booted).</para>
        /// </summary>
        /// <remarks>On systems that support it, the POSIX monotonic clock is used.</remarks>
        public static long LibvlcClock()
        {
            var __ret = __Internal.LibvlcClock();
            return __ret;
        }

        /// <summary>Return the delay (in microseconds) until a certain timestamp.</summary>
        /// <param name="pts">timestamp</param>
        /// <returns>
        /// <para>negative if timestamp is in the past,</para>
        /// <para>positive if it is in the future</para>
        /// </returns>
        public static long LibvlcDelay(long pts)
        {
            var __ret = __Internal.LibvlcDelay(pts);
            return __ret;
        }
    }
}
